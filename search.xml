<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>KMP算法</title>
    <url>/2024/10/09/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>前言：个人关于KMP算法的一点理解</p>
<span id="more"></span>
<p>在介绍KMP算法前我们先介绍BP算法，暴力匹配算法，先上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BP</span><span class="params">(<span class="type">char</span>* str,<span class="type">char</span>* s)</span><span class="comment">//s为给定子串，str为带查找字符串，查找到则返回s在str中首次出现的位置，否则返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str)-<span class="built_in">strlen</span>(s);i++)&#123;	<span class="comment">//从str第一个字符开始其后字符依次与s匹配，注意边界</span></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;							<span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(s);j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i+j]!=s[j])&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;							<span class="comment">//若出现不匹配字符，停止本次操作，进行下一次匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其复杂度分析得到其复杂度为O(mn)（m，n分别为子串与查找串的长度）。</p>
<p>接下来以查找串T=”aaabbaaaba”，子串P=”aaaba”为例分析其改进方法。</p>
<p><img src="../imgs/KMP%E7%AE%97%E6%B3%95/image-20241009194912582-17285422622071.png" alt></p>
<p>首先以我们的思维来讲，通过观察第一次匹配，我们一般会直接跳到最后一步，但这个算法却只能一步步进行匹配，我们可以从这里改进：①改变两次相邻匹配之间跳过的“<strong>步长</strong>”；②下一次匹配从子串第几个字符开始，即<strong>开始匹配位置</strong>。同时保证不出错。而KMP算法能帮我们解决这个问题。下面来详细讲讲这个算法：设s为子串，str为查找串</p>
<p>我们通过构建next[]数组来确定步长及下一次匹配的开始位置，开始介绍next[]数组之前，我们先讲一下其功能及原理：当子串匹配到第i位时字串与查找串不再匹配（隐含条件：前i-1位都匹配，可以做化简算法的突破口），此时我们通过使用next数组能够得到我们下一次匹配跳len(s)-next[i]位，并且下一次匹配从s[next[i]]开始，虽然这里查找串是未知的，但子串是给定已知的，而前i-1位都匹配的条件并不会影响子串，所以我们可以通过子串来构建next数组。</p>
<p>我们为了方便理解，先给出一个不准确的描述：先来一个next[]数组中next[i]记录的是由子串s的前i-1位字符所成字符串（记为si）的最长相同前缀后缀的长度，（si的前缀/后缀均是其真子串）举个例子s=”aadgaadc”:(注意！这里next[i]的值并不完全正确，仅为方便理解，后面会讲为什么)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i的值</th>
<th>前缀</th>
<th>后缀</th>
<th>next[i]</th>
<th>si</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-1</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>a</td>
<td>1</td>
<td>aa</td>
</tr>
<tr>
<td>3</td>
<td>a,aa</td>
<td>d,ad</td>
<td>0</td>
<td>aad</td>
</tr>
<tr>
<td>4</td>
<td>a,aa,aad</td>
<td>g,dg,adg</td>
<td>0</td>
<td>aadg</td>
</tr>
<tr>
<td>5</td>
<td>a,aa,aad,aadg</td>
<td>a,ga,dga,adga</td>
<td>1</td>
<td>aadga</td>
</tr>
<tr>
<td>6</td>
<td>a,aa,aad,aadg,aadga</td>
<td>a,aa,gaa,dgaa,adgaa</td>
<td>2</td>
<td>aadgaa</td>
</tr>
<tr>
<td>7</td>
<td>a,aa,aad,aadg,aadga,aadgaa</td>
<td>d,ad,aad,gaad,dgaad,adgaad</td>
<td>3</td>
<td>aadgaad</td>
</tr>
</tbody>
</table>
</div>
<p>现在我们再讲一遍其原理：子串第i位不匹配，但是其前i-1位子串都匹配，（拿上表i=7举例）查找串此时对应的位置就是aadgaad，我们就可以把它移到前后缀相匹配的位置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配串</th>
<th>a</th>
<th>a</th>
<th>d</th>
<th>g</th>
<th>a</th>
<th>a</th>
<th>d</th>
<th>a</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>这次子串</td>
<td>a</td>
<td>a</td>
<td>d</td>
<td>g</td>
<td>a</td>
<td>a</td>
<td>d</td>
<td>(c)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>下次子串</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>a</td>
<td>a</td>
<td>d(相同，移动)</td>
<td>g</td>
<td>a</td>
<td>a</td>
<td>d</td>
</tr>
</tbody>
</table>
</div>
<p>此时，我们可以发现，移动了i-next[i]（7-3=4）位，这是有普遍性的，为了这个普遍性，我们特地规定了next[0]=-1,否则无法移动，next[1]=0也是同样的道理，同时移动后从子串的next[i]位开始比较，于是我们可以把（假设）已经得到next数组之后的代码写出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> *str, <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//事实上，我们只需要两个变量，一个变量记录查找串当前比较位置，一个变量记录子串当前比较位置，比较结果相同则二者均自增，不同则查找出按当前位置不变，子串通过next数组来改变，再利用strlen(s)与该变量的大小比较判断是否完全匹配，若是，则返回第一次完全匹配的开始位置</span></span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配next数组的空间</span></span><br><span class="line">    <span class="built_in">get_next</span>(s, next); <span class="comment">// 计算next数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 初始化i和j，分别用于匹配串和子串的索引</span></span><br><span class="line">    <span class="comment">// 遍历匹配串S</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">        <span class="comment">// 如果j为-1或当前字符匹配，则继续匹配下一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || str[i] == s[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果字符不匹配，则根据PMT数组回退j的位置</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果j等于模式串的长度，则找到了匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">strlen</span>(S)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 返回匹配的起始索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果没有找到匹配，则返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开始优化next数组：</p>
<p>1.上文已经提到的next[0]=-1,next[1]=0或-1（如aaa，next数组全是-1）;</p>
<p>2.有一种可能的情况：s[i]==s[next[i]]；在上面我们已经知道了s[i]与匹配串不匹配，那么下一次操作时我们会再次比较s[next[i]]与匹配串同一位置的字符，显然会匹配失败，为提高效率，我们应该避免，于是我们通过分析该过程来改进next数组：假设这种情况会发生，我们仅需要计算两次操作后总共移动多少位，从哪一位开始比较即可：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>移动几位</th>
<th>从哪一位比较</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次</td>
<td>i-next[i]</td>
<td>next[i]（这一位不匹配）</td>
</tr>
<tr>
<td>第二次</td>
<td>next[i]-next[next[i]]</td>
<td>next[next[i]]</td>
</tr>
</tbody>
</table>
</div>
<p>两次综合，移动了i-next[i]+next[i]-next[next[i]] = next[next[i]]位，从第next[next[i]]位开始比较。</p>
<p>于是，为了延续前面的规律，我们这样改进next数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==s[next[i]])&#123;</span><br><span class="line">    next[i] = next[next[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将两步乃至多部化简成了一步，使效率更高。</p>
<p><strong>代码</strong>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> *next)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;			<span class="comment">//i指向后缀结尾的后一位，j指向前缀结尾</span></span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(s)<span class="number">-1</span>)&#123;	<span class="comment">//j记录最长相同前后缀的长度，要及时更新</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[i]!=s[j])	<span class="comment">//当第i与j位不匹配时，j要向前找，而且一定</span></span><br><span class="line">            j = next[j];			<span class="comment">//要保证i前面的几位后缀要与开始的几位前缀匹配\，用j = next[j]可以快速利用前面的结果实现这个。终止条件里的j&gt;=0对应j=-1的情况，这\是由于next[0]=-1即一位都匹配不了，所以终止循环，向下走</span></span><br><span class="line">		i++;				</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])				<span class="comment">//如果出现相等的情况(上文提及)，这样操作</span></span><br><span class="line">            next[i] = next[j];		</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是O(m+n),m,n分别为子串与查找串的长度。</p>
<p>总之，主要的代码和思维就这些，代码可能有些晦涩难懂，建议自己写几个子串和查找串，然后根据代码手推几次，就理解了。</p>
<p>24/10/10 补充</p>
<p>这几天做了道题，关于KMP算法的，题目给出的并不是简单的字符串，而是一种复合体：第一位记载”字符数组”的原本内容，虽然我误打误撞搞出来了正确结果，但next数组求错了，所以我对这种情况专门写了一段代码（第一位是干扰项，不处理），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">const</span> <span class="type">char</span> s[],<span class="type">int</span> next[])</span>&#123;</span><br><span class="line"><span class="comment">////这是正常情况，用于对比</span></span><br><span class="line"><span class="comment">//	int i=0,j=-1;</span></span><br><span class="line"><span class="comment">//	next[0] = -1;</span></span><br><span class="line"><span class="comment">//    while(i&lt;strlen(s)-1)&#123;</span></span><br><span class="line"><span class="comment">//        while(j&gt;=0 &amp;&amp; s[i]!=s[j])</span></span><br><span class="line"><span class="comment">//            j = next[j];</span></span><br><span class="line"><span class="comment">//		i++;</span></span><br><span class="line"><span class="comment">//        j++;</span></span><br><span class="line"><span class="comment">//        if(s[i]==s[j])</span></span><br><span class="line"><span class="comment">//            next[i] = next[j];</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            next[i] = j;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;<span class="comment">//原理是将next数组的每个值都+1，方便跳过第一个数据</span></span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//不搞也行</span></span><br><span class="line">	next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;s[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span> &amp;&amp; s[i]!=s[j])</span><br><span class="line">            j = next[j];</span><br><span class="line">		i++;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">            next[i] = next[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=s[<span class="number">0</span>];i++)</span><br><span class="line">        next[i]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BM算法</title>
    <url>/2024/10/10/BM%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>参考文章</p>
<p><a href="https://blog.csdn.net/zniahfag/article/details/51338264?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=BM&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-51338264.142^v100^pc_search_result_base6&amp;spm=1018.2226.3001.4187">1</a></p>
<p><a href="https://blog.csdn.net/EQUINOX1/article/details/133256159?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=BM&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-133256159.142^v100^pc_search_result_base6&amp;spm=1018.2226.3001.4187">2</a></p>
<span id="more"></span>
<p>首先让我们来看一组字符：（规范名称，待匹配的字符串称文本串，用于匹配的子串称为模式串）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文本串</th>
<th>I</th>
<th>t</th>
<th></th>
<th>w</th>
<th>o</th>
<th>u</th>
<th>l</th>
<th>d</th>
<th></th>
<th>b</th>
<th>e</th>
<th></th>
<th>.</th>
<th>.</th>
<th>.</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td>w</td>
<td>o</td>
<td><strong>r</strong></td>
<td>d</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>d</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>我们发现，当’r’与’u’不匹配时，KMP算法会将’w’移到原先’r’的位置上，’w’与’u’对齐，但通过我们观察，”word”字符中没有’u’，所以”woul”与”word”不会再匹配，应该将模式串后移4位（匹配位置还没有到would的d上），这里可以作为我们算法优化的突破点。</p>
<p>进行深入分析，我们发现：KMP算法并未充分利用文本串的已知信息（即文本串与模式串不匹配的位置的信息），如果充分利用此信息，我们可以将模式串移动更多，使算法效率更高，于是便有了我们今天介绍的算法——BM算法，事实上，现在大部分情况下的字符匹配都是用的BM算法而非KMP算法。</p>
<p>BM算法实质上是令模式串移动的距离尽可能地大，而为了实现这个目标，BM算法包含了两个算法：</p>
<ul>
<li>坏字符算法</li>
<li>好后缀算法</li>
</ul>
<p>首先介绍坏字符算法：</p>
<p>如下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文本串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>s</th>
<th>c</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式串</strong></td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>我们根据这个表来模拟匹配并讲解过程：</p>
<p>首先将模式串从后向前与文本串匹配，模式串第一次匹配的字符a与c显然不匹配，并且模式串中不含c字符，于是直接将其右移4（模式串长度）位，文本串中的aba均未参与匹配，很显然的效率提升。</p>
<p>这种直接后移整个匹配串的情况比较少见，很有可能模式串与文本串不匹配的字符在模式串中存在，于是有<strong>第二种情况</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文本串</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>b</th>
<th>c</th>
<th>c</th>
<th>a</th>
<th>a</th>
<th>c</th>
<th>c</th>
<th>b</th>
<th>a</th>
<th>c</th>
<th>d</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式串</strong></td>
<td>b</td>
<td>c</td>
<td><strong>c</strong></td>
<td>a</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td>b</td>
<td>c</td>
<td><strong>c</strong></td>
<td>a</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td>b</td>
<td>c</td>
<td><strong>c</strong></td>
<td>a</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>第一次匹配时，模式串的a与文本串的c不匹配，于是从模式串当前匹配位置（a）向前找最近的c字符（向前查找由其从后往前的匹配顺序决定），将查找到的最近的c字符与文本串的c字符对齐，进行下次匹配，又发现第二个模式串a与文本串的c不匹配，再次查找最近的c并对齐，匹配成功。</p>
<p>思路就是这样，现在我们其中的细节问题——如何判断字符是否在模式串中，如何获得距模式串当前匹配位置最近的某字符。</p>
<p>我们通过构建数组来解决这些问题，以模式串P=”at_that”为例讲解数组构建过程：</p>
<p>将这个数组命名为delta1[]，其长度为7，该数组记录模式串中每个字符相对于最右端<strong>最近</strong>的距离，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>P:</th>
<th>*</th>
<th>a</th>
<th>t</th>
<th>_</th>
<th>t</th>
<th>h</th>
<th>a</th>
<th>t</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>delta1</strong></td>
<td>7</td>
<td>1</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>其代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASIZE 256</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_delta1</span><span class="params">(<span class="type">char</span> *P, <span class="type">int</span> m, <span class="type">int</span> delta1[])</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASIZE; ++i)</span><br><span class="line">        delta1[i] = m;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">     	delta1[P[i]] = m - i - <span class="number">1</span>;</span><br><span class="line">&#125;	<span class="comment">//从参考网站copy的</span></span><br><span class="line"><span class="comment">/*解释</span></span><br><span class="line"><span class="comment">字符的范围是0~255(字符值和int值的转换)，所以我们开一个大小位256的delta1数组用</span></span><br><span class="line"><span class="comment">于存储，m就是P的长度，第一个for循环将所有字符的距离都设为最大距离，第二个for循环</span></span><br><span class="line"><span class="comment">针对P的，将P中字符从前向后遍历，更新P中字符的delta1值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>那么这个数组如何使用呢？使用方法比较简单，假设P[i]匹配失败，且此时文本串对应位置字符为s，则查找delta1[s]，右移delta[s]+i-strlen(P)位，当然此时可能会出现小于0的情况。</p>
<p>举个例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>t</th>
<th>c</th>
<th>c</th>
<th>c</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本串</td>
<td>t</td>
<td>c</td>
<td>d</td>
<td>c</td>
<td>b</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>delta1</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>右移2+2-5=-1位，出错。所以需要好后缀算法来解决这个问题，这里有个细节，就是储存每一位字符距右端的距离也可以解决这个问题，但是经过实践，加入好后缀算法更快。</p>
<p>先对好后缀做个说明：</p>
<p>假设模式串为：P=”xxxx<strong>abcd</strong>ffff<strong>abcd</strong>“假设匹配过程中移动到其右数第一个f时不匹配（abcd都匹配），那我们就将xxxx后的abcd移到原先abcd的位置，再继续比较，这里与P最后与文本串相匹配的abcd子串记为好后缀。</p>
<p>将记载数组好后缀信息的数组记为suffix[]，记载移动位数的数组gs[]，通过suffix的辅助来构建gs表，先做四点说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 9;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 6;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 13;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 6;</p>
<p><strong>代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">suffixes</span><span class="params">(<span class="type">char</span> *pattern, <span class="type">int</span> pattern_len, <span class="type">int</span> suffix[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    [m<span class="number">-1</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (i = pattern_len<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>&amp;&amp;pattern[j] == p[m<span class="number">-1</span> - (i - j)])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        suffix[i] = i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preBmGs</span><span class="params">(<span class="type">char</span> *pattern, <span class="type">int</span> pattern_len, <span class="type">int</span> bmGs[])</span> &#123;</span><br><span class="line">     <span class="type">int</span> i, j, suffix[XSIZE];</span><br><span class="line">     suffixes(pattern, pattern_len, suffix);</span><br><span class="line">     <span class="comment">//都初始化为找不子串匹配到好后缀的</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pattern_len; ++i)</span><br><span class="line">        bmGs[i] = pattern_len; </span><br><span class="line">     j = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//最大前缀</span></span><br><span class="line">     <span class="keyword">for</span> (i = pattern_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (suff[i] == i + <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">for</span> (; j &lt; pattern_len - <span class="number">1</span> - i; ++j)</span><br><span class="line">             <span class="keyword">if</span> (bmGs[j] == pattern_len)</span><br><span class="line">                bmGs[j] = pattern_len - <span class="number">1</span> - i;</span><br><span class="line">    <span class="comment">//模式串中有子串匹配上好后缀</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= pattern_len - <span class="number">2</span>; ++i)</span><br><span class="line">       bmGs[pattern_len - <span class="number">1</span> - suff[i]] = pattern_len - <span class="number">1</span> - i;</span><br><span class="line">&#125;				<span class="comment">//复制的</span></span><br></pre></td></tr></table></figure>
<p>这里本人时间原因，就不解释了。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法-最大子列</title>
    <url>/2024/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97/</url>
    <content><![CDATA[<p>原题：有一数列 A~1~,A~2~,A~3~…A~n~,其中可能有负数，假设其子列A~1~,……A~j~(i&lt;=j)，使得$\sum_{i=i}^{j}x_i$取到最大值，请设计函数求该最大值。</p>
<p>分析：首先我们很自然地想到使用穷举法来实现，从此出发，先将这种简单的思路实现。</p>
<span id="more"></span>
<p><strong>代码一：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tsum=msum=A[<span class="number">0</span>];<span class="comment">//tsum记录代码运行中得到的下标从i到j的子列求和值，msum记录最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tsum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k-i;k&lt;=j;k++)</span><br><span class="line">				tsum+=A[i];</span><br><span class="line">			<span class="keyword">if</span>(tsum&gt;msum)</span><br><span class="line">				msum = tsum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们分析这段代码，其时间复杂度为O(n^3^)，好像并不慢，但如果数据很多，似乎就有些慢了，所以我们在这里将其优化：</p>
<p><strong>代码二</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tsum=msum=A[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tsum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tsum+=A[i];</span><br><span class="line">			<span class="keyword">if</span>(tsum&gt;msum)</span><br><span class="line">				msum = tsum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过观察，我们发现代码二优化了代码一中从A~1~到A~j~的相加过程，即当i不变，j++时，tsum不需要从i一直加到j，只需要在原结果上加上A~j~，其时间复杂度为O(n^2^)大大提高了运算效率。</p>
<p>但是，算法能否再次优化使得效率<strong>再次提高</strong>呢？答案是肯定的，我们先观察代码再做分析。</p>
<p><strong>代码三：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tsum=msum=A[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		tsum+=A[j];</span><br><span class="line">		<span class="keyword">if</span>(tsum&gt;msum)</span><br><span class="line">			msum = tsum;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tsum &lt; <span class="number">0</span>)</span><br><span class="line">			tsum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析这段代码，我们得到这段代码的时间复杂度时O(n)，运算效率很高，对比前面两段代码，这段代码将i优化掉了，实际上，我们将i的初始值交给了<u>else if(tsum &lt; 0)</u>这段语句，这条语句第一次生效前，i可以理解为0，tsum为从数列下标0到j的元素求和，如果tsum小于0，则说明我们接下来要求的子列和的结果为一个负数剩下的子列求和相加，为了求最大值，我们要将负数去掉，也就是更新i的值，使得我们能得到尽可能大的tsum值，而<u>if(tsum&gt;msum)</u>确保了我们不会因为更新i而错过最大值。</p>
<h4><span id="总结"><strong>总结：</strong></span></h4><p>我们从最简单粗暴的思路出发，不断将算法优化，最终得到了比较完美的算法。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序1</title>
    <url>/2024/10/10/%E6%8E%92%E5%BA%8F1/</url>
    <content><![CDATA[<p>注：这篇文章偏笔记性质，所以解释较少。同时，本文分时间复杂度，最好情况时间复杂度，最坏情况时间复杂度，空间复杂度及应用几个方面分析算法好坏。</p>
<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#1-插入排序">1 插入排序</a><ul>
<li><a href="#11-直接插入排序">1.1 直接插入排序</a></li>
<li><a href="#12-折半插入排序">1.2 折半插入排序</a></li>
<li><a href="#13-shell排序">1.3 Shell排序</a></li>
</ul>
</li>
<li><a href="#2-选择排序">2 选择排序</a><ul>
<li><a href="#21-直接选择排序">2.1 直接选择排序</a></li>
<li><a href="#22-树形选择排序">2.2 树形选择排序</a></li>
</ul>
</li>
<li><a href="#3交换排序">3交换排序</a><ul>
<li><a href="#31冒泡排序">3.1冒泡排序</a></li>
<li><a href="#32快速排序">3.2快速排序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="1-插入排序">1 插入排序</span></h2><h3><span id="11-直接插入排序">1.1 直接插入排序</span></h3><p>直接插入排序是一种最简单的排序方法（思路简单），整个排序过程为先将第一个元素视为有序数列，然后从第二个元素开始插入，直到将最后一个元素插入前面的有序列中。其最好情况时间复杂度为O(n)，即数组已经顺序排好，最坏情况时间复杂度为O(n^2^)，逆序，平均为O(n^2^)，其优点是可以用来排打乱了少数数据，大部分数据仍然有序的数据组。其基本过程如下图：<img src="../imgs/%E6%8E%92%E5%BA%8F1/image-20241008200428256-17285765494311.png" alt></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectInsertionSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        j = i;</span><br><span class="line">        temp = A[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; temp&lt;A[j<span class="number">-1</span>])&#123;</span><br><span class="line">            A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="12-折半插入排序">1.2 折半插入排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryInsertionSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,k,r;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        temp = A[i];</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        r = i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            m = (k+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;A[m])</span><br><span class="line">                r = m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k = m+<span class="number">1</span>;</span><br><span class="line">       	&#125;     </span><br><span class="line">        <span class="keyword">for</span>(r=i;r&gt;k;r--)</span><br><span class="line">        	A[r] = A[r<span class="number">-1</span>];        </span><br><span class="line">        A[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="13-shell排序">1.3 Shell排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n,<span class="type">int</span> s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(k=s;k&gt;<span class="number">0</span>;k&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;n;i++)&#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            j = i-k;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;AA[j])&#123;</span><br><span class="line">                A[j+k] = A[j];</span><br><span class="line">                j-=k;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j+k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-选择排序">2 选择排序</span></h2><h3><span id="21-直接选择排序">2.1 直接选择排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DirectSelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[i])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="keyword">if</span>(i!=k)&#123;</span><br><span class="line">            temp = A[k];</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            A[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="22-树形选择排序">2.2 树形选择排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nothing now</span></span><br></pre></td></tr></table></figure>
<h2><span id="3交换排序">3交换排序</span></h2><h3><span id="31冒泡排序">3.1冒泡排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>,flag=(<span class="type">bool</span>)<span class="number">1</span>;i&gt;<span class="number">0</span>&amp;&amp;flag;i--)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;					<span class="comment">//设置未交换标志</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j+<span class="number">1</span>]&lt;A[j])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;			<span class="comment">//有交换发生，置标志</span></span><br><span class="line">                temp = A[j+<span class="number">1</span>];			<span class="comment">//交换</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="32快速排序">3.2快速排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    i = low;</span><br><span class="line">    j = high;</span><br><span class="line">    temp = A[i];	<span class="comment">/*将第一个元素设为中心值*/</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="comment">/*从后向前将进行比较，知道当前记录的数值小于中心值*/</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; temp&lt;A[j]) j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            A[i++] = A[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; temp&gt;=A[i]) i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            A[j--] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    A[i] = temp;</span><br><span class="line">    Quick(A,low,--j);</span><br><span class="line">    Quick(A,++i,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治思想</title>
    <url>/2024/10/09/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<p>分治思想即将复杂问题分解成一个个规模较小的子问题，最后得到可以直接求解的子问题，从而自底向上求解，两个重点：子问题规模更小，可以得到能直接求解的子问题。</p>
<p><strong>题目：</strong>给定一个数n，将其分解成若干个正整数之和，以6为例，6=6，6=5+1，6=4+2，6=4+1+1，6=3+3，6=3+2+1，6=3+1+1+1，6=2+2+2，6=2+2+1+1，6=2+1+1+1+1，6=1+1+1+1+1+1，共11种，请设计函数，求数n分解方法有多少种；</p>
<span id="more"></span>
<p><strong>思路：</strong>根据题目，自然地联想到用递归解决，递归的核心是将问题分解成规模更小的子问题而求解，先假设函数为Q(n)，现在我们思考Q(n)与Q(n-1)之间的关系，但经过探究，我们可以发现，这种关系难以寻找，于是我们加入变量m，函数Q(n,m)表示n分解成若干个不大于m的数之和方法种数，对函数Q(n,m)，其可以分解为Q(n,m-1)与n分解成不若干个包含m的数之和方法种数之和，注意到m与n都为定值，所以n分解成不若干个包含m的数之和方法种数之和等于将（n-m）分解成若干个不大于m的数之和方法种数，即Q(n-m,m)，<strong>于是得到Q(n,m)=Q(n,m-1)+Q(n-m,m)</strong>，此即为递推式，之后我们讨论终止条件与限定条件，如下，不赘述。（思考：若n分解成的加数不允许有重复，那么怎么写递推式？Q(n,m)=Q(n,m-1)+Q(n-m,m-1)）</p>
<script type="math/tex; mode=display">
Q(n,m)=
\begin{equation}
    \left\{
        \begin{array}{lr}
        1 & m = 1 &or& n=1\\\\
        Q(n,n) & n<m\\\\
        1+Q(n,n-1) & n=m\\\\
        Q(n,m-1)+Q(n-m,m) & n>m>1\\
        \end{array}
    \right. 
\end{equation}</script><p><img src="../imgs/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-10%20235758.png" alt></p>
<p><strong>题目变式1：</strong>若将题目加入限制条件：将n分解为k个数之和，递推式又该怎么写？令函数为Q(n,k)，做如下操作：将n分解成的k个数都减去1，则有两种情况：1、n分解成的k个数都大于1，这种情况的分解方法数等于Q(n-k,k)；2、n分解成的k个数至少一个等于1，把等于1的数单独拿出来（相当于这个已经固定了），这种情况的种数为Q(n-1,k-1)。于是我们得到：<strong>Q(n,k)=Q(n-k,k)+Q(n-1,k-1)</strong>，再设定终止情况就OK了。</p>
<p><strong>题目变式2：</strong>如果n只能分解成k个奇数或者k个偶数，递推式又该如何写？这里我们假设奇数的函数为f(n,k)，偶数为g(n,k)，我们故技重施，对奇数有f(n,k)=g(n-k,k)+f(n-1,k-1)，对偶数有g(n,k)=f(n-k,k)（符合条件的最小的偶数为2，大于1）。</p>
<p><strong>题目变式3：</strong>如果将n分解成k个不同的数，又该怎么写？答案是<strong>Q(n,k)=Q(n-k,k)+Q(n-k,k-1)</strong></p>
<p><strong>解释：</strong>如果有且仅有一个1，那么剩下的数必然全大于等于1，所以将剩下的所有组成数都减去1，结果不变的同时还可以减小问题规模，这是表达式为Q(n-1-(k-1),k-1)=Q(n-k,k-1),如果没有1，将所有数都减去1，得到Q(n-k,k)，于是我们得到了这个式子。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈实现表达式运算</title>
    <url>/2024/10/10/%E6%A0%88%E5%AE%9E%E7%8E%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#1栈的实现">1.栈的实现</a><ul>
<li><a href="#11基本函数">1.1基本函数</a></li>
<li><a href="#12代码实现">1.2代码实现</a></li>
</ul>
</li>
<li><a href="#2中缀以及后缀表达式">2.中缀以及后缀表达式</a><ul>
<li><a href="#21中缀表达式">2.1中缀表达式</a></li>
<li><a href="#22后缀表达式">2.2后缀表达式</a></li>
</ul>
</li>
<li><a href="#3用栈实现表达式求值">3.用栈实现表达式求值</a><ul>
<li><a href="#31后缀表达式求值">3.1后缀表达式求值</a></li>
<li><a href="#32中缀表达式求值">3.2中缀表达式求值</a></li>
</ul>
</li>
<li><a href="#4中后缀表达式转换">4.中后缀表达式转换</a></li>
<li><a href="#5补充错误后缀表达式的判断及处理">5.补充——错误后缀表达式的判断及处理</a></li>
</ul>
<!-- tocstop -->
<p>说明：这篇博客以代码为主</p>
<span id="more"></span>
<h2><span id="1栈的实现">1.栈的实现</span></h2><h3><span id="11基本函数">1.1基本函数</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//存储栈的元素值（1个） </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span><span class="comment">//存储下一个元素（朝栈底方向）节点的地址 </span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LinkStack *<span class="title function_">InitStack</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(LinkStack *s)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.判断栈是否为空</span></span><br><span class="line"><span class="comment">若为空，返回1；</span></span><br><span class="line"><span class="comment">否则，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(LinkStack *s)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Push</span><span class="params">(LinkStack *s,ElemType e)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.出栈 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6.取栈顶元素 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.输出</span></span><br><span class="line"><span class="comment">从栈顶 至 栈底 全部输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkStack *s)</span></span><br></pre></td></tr></table></figure>
<h3><span id="12代码实现">1.2代码实现</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//存储栈的元素值（1个） </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span><span class="comment">//存储下一个元素（朝栈底方向）节点的地址 </span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空：s-&gt;next==NULL </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LinkStack *<span class="title function_">InitStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack *s;</span><br><span class="line">	s=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(LinkStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType m;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s,ElemType *e)</span>;</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//出栈</span></span><br><span class="line">		Pop(s,&amp;m); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">free</span>(s); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.判断栈是否为空</span></span><br><span class="line"><span class="comment">若为空，返回1；</span></span><br><span class="line"><span class="comment">否则，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(LinkStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Push</span><span class="params">(LinkStack *s,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack *t;</span><br><span class="line">	<span class="comment">//1.构造一个节点t，存储元素值e </span></span><br><span class="line">	t=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	t-&gt;data=e;</span><br><span class="line">	<span class="comment">//2.把t节点添加到头节点的后面 </span></span><br><span class="line">	t-&gt;next=s-&gt;next;</span><br><span class="line">	s-&gt;next=t;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.出栈 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack *t; </span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.让t指向栈顶元素节点</span></span><br><span class="line">		t=s-&gt;next;</span><br><span class="line">		<span class="comment">//2.把栈顶元素值存储到*e中</span></span><br><span class="line">		*e=t-&gt;data;</span><br><span class="line">		<span class="comment">//3.删除</span></span><br><span class="line">		s-&gt;next=t-&gt;next;</span><br><span class="line">		<span class="comment">//4.释放存储空间</span></span><br><span class="line">		<span class="built_in">free</span>(t); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空，不能出栈！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6.取栈顶元素 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		*e=s-&gt;next-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空，不能取栈顶元素！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.输出</span></span><br><span class="line"><span class="comment">从栈顶 至 栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(s-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s-&gt;next-&gt;data);</span><br><span class="line">		s = s-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack s;</span><br><span class="line">	s = *InitStack();</span><br><span class="line">    Push(&amp;s,<span class="number">1</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">2</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">3</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">4</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">5</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">6</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">7</span>);</span><br><span class="line">	</span><br><span class="line">	ElemType *e;</span><br><span class="line">	e = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	    </span><br><span class="line">	GetTop(&amp;s,e);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*e);</span><br><span class="line"> 	Pop(&amp;s,e);</span><br><span class="line"> </span><br><span class="line"> 	GetTop(&amp;s,e);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*e);	</span><br><span class="line"> 	</span><br><span class="line"> 	display(&amp;s);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> 	</span><br><span class="line"> 	GetTop(&amp;s,e);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*e); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2><span id="2中缀以及后缀表达式">2.中缀以及后缀表达式</span></h2><h3><span id="21中缀表达式">2.1中缀表达式</span></h3><p><strong>例：2*(3+4)-8/2</strong></p>
<p>说明：日常所见绝大多数运算都是运算顺序与符号的出现顺序不一定相同</p>
<h3><span id="22后缀表达式">2.2后缀表达式</span></h3><p><strong>例：2 3 + 4 *82/-</strong></p>
<p>说明：没有括号，运算顺序与符号出现的前后顺序一致</p>
<h2><span id="3用栈实现表达式求值">3.用栈实现表达式求值</span></h2><h3><span id="31后缀表达式求值">3.1后缀表达式求值</span></h3><p><strong>运算方式：</strong>构造一个数栈，扫描表达式，若是数字则入栈，若是运算符则取出两个数字运算，并将结果放入数栈中，最后数栈中仅剩的一个元素即为表达式的计算结果。</p>
<p><strong>示例</strong>：</p>
<p>初始</p>
<p>​        表达式：234+*82/-</p>
<p>​        操作数栈：{ }</p>
<p>第一步</p>
<p>​        表达式：34+*82/-</p>
<p>​        操作数栈：{2 }</p>
<p>第二步</p>
<p>​        表达式：4+*82/-</p>
<p>​        操作数栈：{2,3 }</p>
<p>第三步</p>
<p>​        表达式：+*82/-</p>
<p>​        操作数栈：{2,3,4 }</p>
<p>第四步</p>
<p>​        表达式：*82/-</p>
<p>​        操作数栈：{2,7 }</p>
<p>第五步</p>
<p>​        表达式：82/-</p>
<p>​        操作数栈：{14 }</p>
<p>第六步</p>
<p>​        表达式：2/-</p>
<p>​        操作数栈：{14,8 }</p>
<p>第七步</p>
<p>​        表达式：/-</p>
<p>​        操作数栈：{14,8,2 }</p>
<p>第八步</p>
<p>​        表达式：-</p>
<p>​        操作数栈：{14,4 }</p>
<p>第九步</p>
<p>​        表达式：</p>
<p>​        操作数栈：{10 }</p>
<p>计算结束</p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EvaluatePostfix</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size=<span class="number">80</span>;   <span class="type">char</span> buf[size];   <span class="type">int</span> i=<span class="number">0</span>,k;</span><br><span class="line">    Stack *Spnd = new Stack(size);</span><br><span class="line">    <span class="built_in">printf</span>(“Input Postfix\n”);  <span class="built_in">scanf</span>(“%s”, buf);</span><br><span class="line">    <span class="keyword">while</span> (buf[i]!=‘\<span class="number">0</span>’)</span><br><span class="line">    &#123;   <span class="keyword">switch</span>(buf[i])</span><br><span class="line">        &#123;   <span class="keyword">case</span> ‘+’: </span><br><span class="line">  k= Spnd.Pop()+ Spnd.Pop(); Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ‘-’: </span><br><span class="line">  k= Spnd.Pop(); k=Spnd.Pop()-k; Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ‘*’: </span><br><span class="line">  k=Spnd.Pop()*Spnd.Pop(); Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ‘/’: </span><br><span class="line">  k=Spnd.Pop(); k=Spnd.Pop()/k; Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">  Spnd.Push((<span class="type">int</span>)(buf[i]<span class="number">-48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(“The value is %d\n”, Spnd.Pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="32中缀表达式求值">3.2中缀表达式求值</span></h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>当前</th>
<th>运算符</th>
<th>栈顶</th>
<th>元素</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前</td>
<td></td>
<td>空</td>
<td>（</td>
<td>+或-</td>
<td>*或/</td>
</tr>
<tr>
<td>获取</td>
<td>（</td>
<td>W进栈</td>
<td>W进栈</td>
<td>W进栈</td>
<td>W进栈</td>
</tr>
<tr>
<td>的运</td>
<td>）</td>
<td>Error</td>
<td>T出栈</td>
<td>T出栈并计算</td>
<td>T出栈并计算</td>
</tr>
<tr>
<td>算符</td>
<td>*或/</td>
<td>W进栈</td>
<td>W进栈</td>
<td>T出栈并计算</td>
<td>W进栈</td>
</tr>
<tr>
<td>W</td>
<td>+或-</td>
<td>W进栈</td>
<td>W进栈</td>
<td>T出栈并计算</td>
<td>T出栈并计算</td>
</tr>
</tbody>
</table>
</div>
<p><strong>运算方式：</strong>构造两个栈，数栈与运算符栈，扫描表达式，若是数则直接进数栈，若是运算符则判断其<strong>上一个运算符</strong>是否能运算（将扫描到的运算符W与栈顶元素T比较，见上表），若能运算，则运算符出栈，并且数栈弹出两个数来运算，结果再存进数栈，然后刚刚扫描到的元素再与当前栈顶元素比较，能运算则重复上述操作，否则运算符进栈，继续扫描表达式。</p>
<p>注意：右括号不会进运算符栈，一旦扫描到右括号，则运算符弹栈，直到弹出左括号。</p>
<p>关键：</p>
<ul>
<li>保持运算符栈的栈顶运算符在运算符栈中具有最高优先级</li>
<li>通过出栈来保证这一点</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 20	 <span class="comment">// 栈初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INCREMENT 10   <span class="comment">//栈满后，每次扩充的容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPRESS_MAX 1024 <span class="comment">//后缀表达式 长度不能超过1024</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"> </span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">EleType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EleType* top;<span class="comment">//栈顶指针</span></span><br><span class="line">	EleType* base;<span class="comment">//栈底指针</span></span><br><span class="line">	<span class="type">int</span> stackSize;<span class="comment">//栈容量</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//开辟空间</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;base = <span class="built_in">stack</span>-&gt;top = (EleType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(EleType));</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">stack</span>-&gt;base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;stackSize = STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">push</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>, EleType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//压栈之前检测容量是否足够</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top - <span class="built_in">stack</span>-&gt;base == <span class="built_in">stack</span>-&gt;stackSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//超出容量 进行扩容，使用realloc函数，会拷贝原内存内容</span></span><br><span class="line">		<span class="built_in">stack</span>-&gt;base = (EleType*)<span class="built_in">realloc</span>(<span class="built_in">stack</span>-&gt;base, <span class="built_in">stack</span>-&gt;stackSize + STACK_INCREMENT);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">stack</span>-&gt;base)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;base + <span class="built_in">stack</span>-&gt;stackSize;</span><br><span class="line">		<span class="built_in">stack</span>-&gt;stackSize += STACK_INCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">stack</span>-&gt;top = e;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">pop</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>, EleType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span> || e == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空栈</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="built_in">stack</span>-&gt;base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">	*e = *<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取栈顶元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">GetTop</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>, EleType *e)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*e = *(<span class="built_in">stack</span>-&gt;top - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断栈是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmptyStack</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="built_in">stack</span>-&gt;base) &#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">销毁栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">DestroyStack</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//销毁栈 是释放栈在内存中占用的空间资源</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">stack</span>-&gt;base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;base);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;stackSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span>* <span class="title function_">MidExpToAfterExp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* midExp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//后缀表达式</span></span><br><span class="line">	<span class="type">char</span>* afterExp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*EXPRESS_MAX);</span><br><span class="line">	<span class="built_in">memset</span>(afterExp, <span class="number">0</span>, EXPRESS_MAX);</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//afterExp下标</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;<span class="comment">//preExp下标</span></span><br><span class="line"> </span><br><span class="line">	SeqStack&lt;<span class="type">char</span>&gt; <span class="built_in">stack</span>;<span class="comment">// + - * / ( ）符号栈</span></span><br><span class="line">	InitStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="type">char</span> numBuf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//连续的数字不能超过10位，也就是中缀表达式中数字不能超过10位</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> numIndex = <span class="number">0</span>;<span class="comment">//numBuf 下标</span></span><br><span class="line">	<span class="keyword">while</span> (midExp[k])</span><br><span class="line">	&#123;</span><br><span class="line">		ch = midExp[k++];</span><br><span class="line">		<span class="comment">//忽略中缀表达式中的空格</span></span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//回车代表中缀输入完毕</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1、若是数字就输出</span></span><br><span class="line">		<span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果输入连续的数字，不是连续的数字 循环完毕 会走 2、非数字</span></span><br><span class="line">			<span class="keyword">while</span> (((ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || <span class="string">&#x27;.&#x27;</span> == ch) &amp;&amp; numIndex &lt; <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				numBuf[numIndex++] = ch;</span><br><span class="line">				afterExp[j++] = ch;</span><br><span class="line">				ch = midExp[k++];</span><br><span class="line">			&#125;</span><br><span class="line">			numBuf[numIndex] = <span class="number">0</span>;</span><br><span class="line">			afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//回车代表中缀输入完毕</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//忽略中缀表达式中的空格</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2、非数字</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			numIndex = <span class="number">0</span>;<span class="comment">//进入这个if 数字肯定不连续了，下标重置为0</span></span><br><span class="line">						 <span class="comment">//右括号一定弹栈</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&#x27;)&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//判断中缀表达式中括号是否匹配,如果成对出现</span></span><br><span class="line">				<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch)</span><br><span class="line">					&#123;</span><br><span class="line">						flag = <span class="number">0</span>;<span class="comment">//走到这里说明是()括号成对出现</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					afterExp[j++] = ch;</span><br><span class="line">					afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (flag)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;中缀表达式输入错误\n&quot;</span>);</span><br><span class="line">					<span class="comment">//exit(0);</span></span><br><span class="line">					<span class="keyword">return</span>	<span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"> </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// + - 符号是优先级最低的，一定是先依次弹栈再压栈。</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;+&#x27;</span> == ch || <span class="string">&#x27;-&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">char</span> top;</span><br><span class="line">				GetTop(&amp;<span class="built_in">stack</span>, &amp;top);</span><br><span class="line">				<span class="comment">//栈空或者栈顶为左括号 直接压栈</span></span><br><span class="line">				<span class="keyword">if</span> (IsEmptyStack(&amp;<span class="built_in">stack</span>) || <span class="string">&#x27;(&#x27;</span> == top)</span><br><span class="line">				&#123;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">char</span> cur = ch;</span><br><span class="line">					<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">						<span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//不是因为)右括号而弹栈，多弹的(左括号压回去</span></span><br><span class="line">							push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						afterExp[j++] = ch;</span><br><span class="line">						afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line"> </span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// * / 符号优先级只比 + -高，栈空或栈顶为(+-符号栈才直接压栈，其他情况先依次弹栈再压栈</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == ch || <span class="string">&#x27;/&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">char</span> top;</span><br><span class="line">				GetTop(&amp;<span class="built_in">stack</span>, &amp;top);</span><br><span class="line">				<span class="comment">//栈空或者栈顶为左括号同样直接压栈</span></span><br><span class="line">				<span class="keyword">if</span> (IsEmptyStack(&amp;<span class="built_in">stack</span>) || <span class="string">&#x27;(&#x27;</span> == top || <span class="string">&#x27;-&#x27;</span> == top || <span class="string">&#x27;+&#x27;</span> == top)</span><br><span class="line">				&#123;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == top || <span class="string">&#x27;/&#x27;</span> == top)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">char</span> cur = ch;</span><br><span class="line">					<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">						<span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch || <span class="string">&#x27;-&#x27;</span> == ch || <span class="string">&#x27;+&#x27;</span> == ch)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//不是因为)右括号而弹栈 * / 优先级高于栈顶 + - 就不弹栈了，多弹的压回去</span></span><br><span class="line">							push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						afterExp[j++] = ch;</span><br><span class="line">						afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;中缀表达式输入错误\n&quot;</span>);</span><br><span class="line">				<span class="comment">//exit(0);</span></span><br><span class="line">				<span class="keyword">return</span>	<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//符号栈内容不为空 依次出栈并打印</span></span><br><span class="line">	<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">		afterExp[j++] = ch;</span><br><span class="line">		afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> afterExp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过栈对后缀表达式进行求值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">GetResultAfterExp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* afterExp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == afterExp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// a b 是表达式中的2个操作数</span></span><br><span class="line">	<span class="type">double</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;<span class="comment">// afterExp 下标</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;<span class="comment">//后缀表达式中的字符</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">char</span> numBuf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//连续的数字不能超过10位，也就是后缀表达式中数字不能超过10位</span></span><br><span class="line">	<span class="type">int</span> numIndex = <span class="number">0</span>;<span class="comment">//numBuf 下标</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	SeqStack&lt;<span class="type">double</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">	InitStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">while</span> (afterExp[k])</span><br><span class="line">	&#123;</span><br><span class="line">		ch = afterExp[k++];</span><br><span class="line">		<span class="comment">//是数值</span></span><br><span class="line">		<span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (((ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) || ch == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; numIndex &lt; <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				numBuf[numIndex++] = ch;</span><br><span class="line">				ch = afterExp[k++];</span><br><span class="line">			&#125;</span><br><span class="line">			numBuf[numIndex] = <span class="number">0</span>;</span><br><span class="line">			<span class="type">double</span> num = atoi(numBuf);</span><br><span class="line">			push(&amp;<span class="built_in">stack</span>, num);</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//是符号或者空格</span></span><br><span class="line">		<span class="keyword">if</span> (ch&lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			numIndex = <span class="number">0</span>;<span class="comment">//进入这个if 数字肯定不连续了，下标重置为0</span></span><br><span class="line">			<span class="comment">// 是空格</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> c = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">switch</span> (ch)</span><br><span class="line">				&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b + a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>,c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b - a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b * a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b / a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="comment">//throw &quot;后缀表达式错误&quot;;</span></span><br><span class="line">					<span class="comment">//printf(&quot;后缀表达式错误\n&quot;);</span></span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		afterExp++;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算完毕 将计算结果从栈中弹出</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//throw &quot;后缀表达式错误&quot;;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;后缀表达式错误\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入中缀表达式(#表示退出)：&quot;</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//中缀表达式</span></span><br><span class="line">		<span class="type">char</span>* midExp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*EXPRESS_MAX);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(midExp, <span class="number">0</span>, EXPRESS_MAX);</span><br><span class="line">		fgets(midExp, <span class="number">1024</span>, <span class="built_in">stdin</span>);<span class="comment">//midExp 包含换行符</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> == midExp[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SeqStack&lt;<span class="type">char</span>&gt; charStack;</span><br><span class="line">		<span class="comment">//后缀表达式</span></span><br><span class="line">		<span class="type">char</span>* afterExp = MidExpToAfterExp(midExp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;对应的后缀表达式：%s\n&quot;</span>, afterExp);</span><br><span class="line"> </span><br><span class="line">		<span class="type">double</span> result = GetResultAfterExp(afterExp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;表达式计算结  果：%.2f\n&quot;</span>, result);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="4中后缀表达式转换">4.中后缀表达式转换</span></h2><p><strong>以一个过程模拟一下：</strong>分号表示扫描到表达式当前的位置</p>
<p>初始<br>中缀：2*(3+4)-8/2<br>后缀：<br>运算符栈：{ }</p>
<p>第一步<br>中缀：2;*(3+4)-8/2<br>后缀：2<br>运算符栈：{ }</p>
<p>第二步<br>中缀：2*;(3+4)-8/2<br>后缀：2<br>运算符栈：{* }</p>
<p>第三步<br>中缀：2*(;3+4)-8/2<br>后缀：2<br>运算符栈：{*,( }</p>
<p>第四步<br>中缀：2*(3;+4)-8/2<br>后缀：23<br>运算符栈：{*,( }</p>
<p>第五步<br>中缀：2*(3+;4)-8/2<br>后缀：23<br>运算符栈：{*,(,+}</p>
<p>第六步<br>中缀：2*(3+4;)-8/2<br>后缀：234<br>运算符栈：{*,(,+ }</p>
<p>第七步<br>中缀：2*(3+4);-8/2<br>后缀：234+<br>运算符栈：{* }</p>
<p>第八步<br>中缀：2*(3+4)-;8/2<br>后缀：234+*<br>运算符栈：{- }</p>
<p>第九步<br>中缀：2*(3+4)-8;/2<br>后缀：234+*8<br>运算符栈：{- }</p>
<p>第十步<br>中缀：2*(3+4)-8/;2<br>后缀：234+*8<br>运算符栈：{-,/ }</p>
<p>第十一步<br>中缀：2*(3+4)-8/2;<br>后缀：234+*82<br>运算符栈：{-,/ }</p>
<p>第十二步<br>中缀：2*(3+4)-8/2;<br>后缀：234+*82/<br>运算符栈：{- }</p>
<p>第十三步<br>中缀：2*(3+4)-8/2;<br>后缀：234+*82/-<br>运算符栈：{ }<br>结束</p>
<p><strong>实现过程的文字描述：</strong></p>
<p>中缀表达式转换为后缀表达式的过程<br>1 后缀表达式清空，运算符栈清空。<br>2 扫描表达式，每获取一个单词w，分五种情况处理：<br>(1) w为操作数：则w加入后缀表达式尾部<br>(2) 运算符栈空或w为“(”：w进运算符栈<br>(3) w为“)”：<br>   (3.1) 直到运算符栈顶为“(”，反复出栈且将出栈运算符加入后缀表达式尾部；     (3.2) 然后将“(”出栈<br>(4) w为“*”或“/”：<br>   (4.1) 若运算符栈顶为“*”或“/”，则出栈且将出栈运算符加入后缀表达式尾部;    (4.2) w进运算符栈<br>(5) w为“＋”“－”：<br>   (5.1) 直到运算符栈顶为“(”或空，反复出栈且将出栈运算符加入后缀表达式尾部;  (5.2) w进运算符栈<br>3 直到运算符栈空，反复出栈且将出栈运算符加入后缀表达式尾部</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="5补充错误后缀表达式的判断及处理">5.补充——错误后缀表达式的判断及处理</span></h2><p>判断表达式错误与否的主要方法：</p>
<ol>
<li>运算结束后<strong>运算符栈</strong>是否<strong>为空</strong>，<strong>数栈</strong>是否<strong>只有一个元素</strong></li>
<li>扫描到右括号时弹栈直到弹出左括号。</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>银行排队-优先级队列</title>
    <url>/2024/10/15/%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>数据结构与算法大作业1：模拟银行</p>
<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#介绍"><strong>介绍：</strong></a><ul>
<li><a href="#背景介绍"><strong>背景介绍：</strong></a></li>
<li><a href="#变量说明"><strong>变量说明：</strong></a></li>
<li><a href="#模拟过程说明"><strong>模拟过程说明：</strong></a></li>
</ul>
</li>
<li><a href="#程序说明"><strong>程序说明：</strong></a><ul>
<li><a href="#基础程序"><strong>基础程序：</strong></a></li>
<li><a href="#题目"><strong>题目</strong></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="介绍"><strong>介绍：</strong></span></h2><h3><span id="背景介绍"><strong>背景介绍：</strong></span></h3><p>队列在计算机中的应用十分广泛，例如操作系统中的作业管理、进程调度、I/O请求处理等要用到队 列，排序算法中的基数排序，图的宽度优先遍历、缓冲区的循环使用等都用到队列，实时程序要处理一 些随机到达的离散事件也要用到队列。 下面介绍的事件驱动模拟是队列应用的典型例子之一。 </p>
<p>我们利用程序来模拟研究银行中客户到达（Arrival）和离开（Departure）的情况。我们把客户到达 和离开银行这两个时刻发生的事情称为“事件”（Event），则整个模拟程序将按事件发生的先后顺序进行 处理，这种模拟称为事件驱动模拟。 假设在一个不少于两个（n≥2）出纳窗口的银行中，每个出纳窗口在某一时刻只能接待一位客户，在客 户较多时需在每个窗口顺序排队。对于刚进人银行的客户，如果某个窗口正空闲，客户可立即上前办理 业务；否则，他会根据队伍人数的多少和队伍前进的快慢来决定选择窗口。程序模拟的结果要得出每位 客户的平均等待时间和每位出纳员的忙度，以此来衡量服务的效率。</p>
<h3><span id="变量说明"><strong>变量说明：</strong></span></h3><p>模拟程序要处理的数据有两类：一类是客户数据；另一类是出纳员数据。有关客户的情况体现在事件 中。</p>
<p>事件描述应包括的数据如下。 (1) time: 事件发生的时间(客户到达/离开的时刻，以分钟为单位，从模拟开始运行起计算)。 (2) etype: 事件类型(到达/离开)。 (3) customerID: 客户编号。 (4) tellerID: 客户选择服务的窗口编号。 (5) waittime: 客户必须等待的时间。 (6) servicetime: 客户需要的服务时间。 对于一个到达事件来说，必须有time、etype和customerID这3项数据，后3项数在到达事件中不需 要。对于离开事件来说，这6项数据都是必需的。 </p>
<p>服务效率与每个窗口的出纳员有关，出纳员数据如下。 (1) finishService: 窗口空闲时刻预告(即窗口当前的客户队伍什么时候可服务完毕) (2) totalCustomerCount: 该出纳员服务过的客户总数。 (3) totalCustomerWait: 该窗口客户总的等待时间。 (4) totalService: 该出纳员总的服务时间。 出纳员数据可用一个结构来描述，多个出纳员的数据组成一个结构数组。</p>
<h3><span id="模拟过程说明"><strong>模拟过程说明：</strong></span></h3><p>用随机数发生器产生一个时间作为下一个客户的到达时间，则可生成下一个客户的到达事件。如果产 生的时间超过了银行的下班时间，则不生成下一个客户到达事件。所有的客户到达事件和客户离开事件 按事件生成的先后顺序进入队列。这个队列的队列元素是事件，称为事件队列。 这个队列的入队操作与一般队列一样在队尾插入，但出队操作却不是从队头删除，而是从队列中选取 事件发生时间最早，即time值最小的队列元素删除，这种队列是优先级队列，在这里 time就是优先级。 如果两个队列元素的优先级相同则删除时按它们在队列中的先后顺序进行。 首先介绍事件是如何驱动模拟的。模拟从银行上班时开始，设置一些系统初始条件之后，就给出第一 个事件firstEvent，将这个事件加入事件优先队列中，该事件是事件队列初态中的唯一队列元素。其数据 成员是0、Arrival、1、0、0、0，分别对应time、etype、 customerID、tellerID、waittime、 servicetime，即表示客户1在0时刻到达。后面3个数据对于到达事件来说是不用的，这里暂且置为0。 对于每个客户到达事件，模拟程序将自动生成该客户的离开事件和下一个客户的到达事件。首先访问 出纳员数据finishService，就可知当前排在哪个窗口(tellerID)可以最先获得服务；用窗口空闲时刻预告  finishService 减去客户到达时刻time，就可得到客户的等待时间 wailtime；用随机数发生器可产生该客 户需要服务的时间servicetime；finishService加上servicetime 就是客户的离开时刻。如此就可生成该客 户的离开事件。 在生成离开事件之前，还要对选中窗口的出纳员数据做相应的更新。窗口空闲时刻预告finishService 应做如下修改：如果窗口空闲时刻预告 finishService为0，表示现在无客户，当前到达的事件立即可获得 服务，应把该窗口空闲时刻预告置为当前客户的到达时刻time，这时，离开事件中的客户等待时间 waittime为0；否则，窗口空闲时刻预告应为 finishService 与客户需要的服务时间 servicetime之和（即 该客户的离开时间）。该窗口接待客户的总数、客户总等待时间和总的服务时间都要对应该客户的信息 进行相应地增加。 模拟程序从事件队列中用删除操作取一个客户事件。如果是到达事件，则生成一个该客户离开事件和 一个下一客户到达事件(如果下一客户到达时间超过银行下班时间，则不生成下一客户到达事件)，并将这 两个事件入队。如果是离开事件，则根据离开事件的数据对该窗口空闲时刻预告做如下修改：如果该窗 口再没有其他等待服务的客户，则 finishService 置为0，一旦事件队列为空，则模拟结束。尽管客户到 达时间不能超过银行的下班时间，但客户的离开时间可能在银行下班时间之后，所以模拟结束时可能超 出原定的模拟时间长度。模拟结束时将输出模拟的结果数据。</p>
<h2><span id="程序说明"><strong>程序说明：</strong></span></h2><h3><span id="基础程序"><strong>基础程序：</strong></span></h3><p>程序一共有3个头文件与1个源文件，以下为代码展示</p>
<h4><span id="simh"><strong>sim.h</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下均为 sim.h 内容 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMULATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMULATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;event.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> Event DataType;  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apqueue.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 出纳窗口信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tellerStats</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> finishService;     <span class="comment">/* 空闲时间预告 */</span></span><br><span class="line">    <span class="type">int</span> totalCustomerCount; <span class="comment">/* 服务过的客户总数 */</span>    <span class="type">int</span> totalCustomerWait; <span class="comment">/* 客户总的等待时间 */</span></span><br><span class="line">    <span class="type">int</span> totalService;       <span class="comment">/* 总的服务时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tellerStats</span> <span class="title">TellerStats</span>;</span></span><br><span class="line"><span class="comment">/* 模拟结构数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simulation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> simulationLength;       <span class="comment">/* 模拟时间长度 */</span></span><br><span class="line">    <span class="type">int</span> numTellers;             <span class="comment">/* 出纳窗口数 */</span></span><br><span class="line">    <span class="type">int</span> nextCustomer;           <span class="comment">/* 下一个客户编码 */</span></span><br><span class="line">    <span class="type">int</span> arrivalLow, arrivalHigh; <span class="comment">/* 下一个客户到达的时间区间 */</span></span><br><span class="line">    <span class="type">int</span> serviceLow, serviceHigh; <span class="comment">/* 客户需要服务的时间区间 */</span></span><br><span class="line">    TellerStats tstat[<span class="number">11</span>];       <span class="comment">/* 出纳窗口信息 */</span></span><br><span class="line">    PQueue pq;                   <span class="comment">/* 优先级队列 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">simulation</span> <span class="title">Simulation</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSimulation</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 事件驱动模拟的初始化 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextArrivalTime</span><span class="params">(Simulation* s)</span>;     <span class="comment">/* 计算下一客户到达时间，随机生成 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_ServiceTime</span><span class="params">(Simulation*)</span>;       <span class="comment">/* 计算客户服务时间，随机生成 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAvailableTeller</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 计算下一个可供服务的出纳窗口号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RunSimulation</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 运行事件模拟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintSimulationResults</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 输出模拟结果 */</span></span><br><span class="line"><span class="comment">/* 事件驱动模拟的初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSimulation</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Event* firstevent = (Event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Event));</span><br><span class="line">    <span class="comment">/* 初始化出纳窗口信息，注意这里限制最多10个窗口，并且编号是从1开始的 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        s-&gt;tstat[i].finishService = <span class="number">0</span>;</span><br><span class="line">        s-&gt;tstat[i].totalService = <span class="number">0</span>;</span><br><span class="line">        s-&gt;tstat[i].totalCustomerWait = <span class="number">0</span>;</span><br><span class="line">        s-&gt;tstat[i].totalCustomerCount = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    s-&gt;nextCustomer = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 输入事件模拟相关数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the simulation time in minutes: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;simulationLength);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of bank tellers: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;numTellers); <span class="comment">/* 注意这里不能超过10个 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the range of arrival times in minutes: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;s-&gt;arrivalLow, &amp;s-&gt;arrivalHigh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the range of service times in minutes: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;s-&gt;serviceLow, &amp;s-&gt;serviceHigh); </span><br><span class="line">    <span class="comment">/* 生成第一个到达事件并加入事件优先级队列 */</span></span><br><span class="line">    InitEvent(firstevent, <span class="number">0</span>, arrival, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    InitPQueue(&amp;(s-&gt;pq));</span><br><span class="line">    PQInsert(&amp;(s-&gt;pq), *firstevent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 计算下一客户到达时间，按照所给区间随机生成 */</span><span class="type">int</span> <span class="title function_">NextArrivalTime</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;arrivalLow + rand() % (s-&gt;arrivalHigh - s-&gt;arrivalLow + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 计算客户的服务时间，按照所给区间随机生成 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_ServiceTime</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;serviceLow + rand() % (s-&gt;serviceHigh - s-&gt;serviceLow + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 计算下一个可供服务的出纳窗口号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAvailableTeller</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> minfinishindex = <span class="number">1</span>; <span class="comment">/* 初始化最快空闲窗口为第一个窗口 */</span></span><br><span class="line">    <span class="type">int</span> minfinish = s-&gt;tstat[<span class="number">1</span>].finishService; <span class="comment">/* 初始化最快空闲时间预告为第一个窗口的</span></span><br><span class="line"><span class="comment">空闲时间预告 */</span></span><br><span class="line">    <span class="type">int</span> num[<span class="number">1000</span>], m, i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 遍历所有窗口，找到最小空闲时间预告以及对应的窗口编号，如果存在多个最小窗口则随机选择其中</span></span><br><span class="line"><span class="comment">一个 */</span></span><br><span class="line">    m = <span class="number">1</span>;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;tstat[i].finishService &lt; minfinish) &#123;</span><br><span class="line">            minfinish = s-&gt;tstat[i].finishService;</span><br><span class="line">            num[<span class="number">0</span>] = i;</span><br><span class="line">            m = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[i].finishService == minfinish)</span><br><span class="line">                num[m++] = i;</span><br><span class="line">       &#125; </span><br><span class="line">    minfinishindex = num[rand() % m];</span><br><span class="line">    <span class="keyword">return</span> minfinishindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行事件驱动模拟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RunSimulation</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    Event* e = (Event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Event));</span><br><span class="line">    Event* newevent = (Event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Event));</span><br><span class="line">    <span class="type">int</span> nexttime, tellerID, servicetime, waittime;</span><br><span class="line">    <span class="comment">/* 遍历事件优先级队列，直到队列为空 */</span></span><br><span class="line">    <span class="keyword">while</span> (!PQEmpty(&amp;(s-&gt;pq)))</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">/* 获得下一个事件的优先级，此处指的是时间产生时间time */</span></span><br><span class="line">        *e = PQDelete(&amp;(s-&gt;pq));</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;etype == arrival)&#123;</span><br><span class="line">            <span class="comment">/* 处理到达事件 */</span></span><br><span class="line">            nexttime = e-&gt;time + NextArrivalTime(s);</span><br><span class="line">            <span class="keyword">if</span> (nexttime &gt; s-&gt;simulationLength)</span><br><span class="line">                <span class="comment">/* 如果到达事件在下班时刻之后，则不处理到达事件 */</span>                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/* 生成下一客户到达事件并加入事件优先级队列 */</span></span><br><span class="line">                s-&gt;nextCustomer++;</span><br><span class="line">                InitEvent(newevent, nexttime, arrival, s-&gt;nextCustomer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                PQInsert(&amp;(s-&gt;pq), *newevent);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Time: %2d\tarrival of customer %d\n&quot;</span>, e-&gt;time, e-</span><br><span class="line">&gt;customerID);</span><br><span class="line">            <span class="comment">/* 生成到达事件的离开事件 */</span></span><br><span class="line">            servicetime = Get_ServiceTime(s);</span><br><span class="line">            <span class="comment">/* 计算可供服务的出纳窗口 */</span></span><br><span class="line">            tellerID = NextAvailableTeller(s);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 如果选定的出纳窗口是空闲的，则更新完成时间预告为当前到达事件时间，以便后续更新完</span></span><br><span class="line"><span class="comment">成时间 */</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[tellerID].finishService == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">                 s-&gt;tstat[tellerID].finishService = e-&gt;time;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">/* 计算等待时间 */</span></span><br><span class="line">            waittime = s-&gt;tstat[tellerID].finishService - e-&gt;time;</span><br><span class="line">            <span class="comment">/* 按照当前到达事件信息修改选定出纳窗口信息 */</span></span><br><span class="line">            s-&gt;tstat[tellerID].totalCustomerWait += waittime;</span><br><span class="line">            s-&gt;tstat[tellerID].totalCustomerCount++;</span><br><span class="line">            s-&gt;tstat[tellerID].totalService += servicetime;</span><br><span class="line">            s-&gt;tstat[tellerID].finishService += servicetime;</span><br><span class="line">            <span class="comment">/* 将生成的离开事件加入优先级队列 */</span></span><br><span class="line">            InitEvent(newevent, s-&gt;tstat[tellerID].finishService,</span><br><span class="line">                departure, e-&gt;customerID, tellerID, waittime, servicetime);</span><br><span class="line">            PQInsert(&amp;(s-&gt;pq), *newevent);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">/* 处理离开事件 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Time: %2d\tdeparture of customer %d\n&quot;</span>, e-&gt;time, e-</span><br><span class="line">&gt;customerID);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\tTeller %d\tWait %d\tService %d\n&quot;</span>, e-&gt;tellerID, e-</span><br><span class="line">&gt;waittime, e-&gt;servicetime);</span><br><span class="line">            tellerID =e-&gt;tellerID;</span><br><span class="line">            <span class="comment">/* 如果窗口在处理离开事件后空闲，则修改该出纳窗口的空闲时间预告 */</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;time == s-&gt;tstat[tellerID].finishService)</span><br><span class="line">                s-&gt;tstat[tellerID].finishService = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/* 修改总的服务时间，注意可能受离开事件影响导致实际总的服务时间大于预定的服务时间 */</span></span><br><span class="line">    s-&gt;simulationLength = (e-&gt;time &lt;= s-&gt;simulationLength)</span><br><span class="line">        ? s-&gt;simulationLength : e-&gt;time;</span><br><span class="line">&#125;<span class="number">1.4</span> 模拟执行 </span><br><span class="line">下面代码是事件驱动的主程序。</span><br><span class="line"><span class="number">2.</span> 实验要求 </span><br><span class="line">基于课本P46给出的代码（如上所述），实现以下功能。</span><br><span class="line"><span class="comment">/* 输出模拟结果 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintSimulationResults</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cumCustomers = <span class="number">0</span>, cumWait = <span class="number">0</span>, i;</span><br><span class="line">    <span class="type">int</span> avgCustWait, tellerWorkPercent;</span><br><span class="line">    <span class="type">float</span> tellerWork;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        cumCustomers += s-&gt;tstat[i].totalCustomerCount; </span><br><span class="line">        cumWait += s-&gt;tstat[i].totalCustomerWait;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n******** Simulation Summary ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Simulation of %d minutes\n&quot;</span>, s-&gt;simulationLength);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tNo. of Customers: %d\n&quot;</span>, cumCustomers);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tAverage Customer Wait: &quot;</span>);</span><br><span class="line">    avgCustWait = (<span class="type">int</span>)((<span class="type">float</span>)cumWait / cumCustomers + <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d minutes\n&quot;</span>, avgCustWait);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\tTeller #%d\tWorking &quot;</span>, i);</span><br><span class="line">        <span class="comment">/* 显示每个出纳窗口的服务时间占比 */</span></span><br><span class="line">        tellerWork = (<span class="type">float</span>)(s-&gt;tstat[i].totalService) / s-&gt;simulationLength;</span><br><span class="line">        tellerWorkPercent = (<span class="type">int</span>)(tellerWork * <span class="number">100.0</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tellerWorkPercent);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* SIMULATION */</span></span></span><br></pre></td></tr></table></figure>
<h4><span id="apqueueh"><strong>apqueue.h</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下为apqueue.h内容，定义优先级队列 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PRIORITYQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIORITYQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 队列最大长度 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxPQSize 50</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pQueue</span>&#123;</span></span><br><span class="line"> <span class="comment">/* 优先级队列数组和计数器 */</span></span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> DataType pqlist[MaxPQSize]; <span class="comment">//Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pQueue</span> <span class="title">PQueue</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPQueue</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="comment">/* 优先级队列修改操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PQInsert</span><span class="params">(PQueue* pq, DataType item)</span>;</span><br><span class="line">DataType <span class="title function_">PQDelete</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearPQ</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="comment">/* 优先级队列检测函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQEmpty</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">PQFull</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">PQLength</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="comment">/* 初始化优先级队列计数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPQueue</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> pq-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将元素插入优先级队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PQInsert</span><span class="params">(PQueue* pq, DataType item)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 如果优先级队列的计数器达到最大限制，则终止程序 */</span></span><br><span class="line"> <span class="keyword">if</span> (pq-&gt;count == MaxPQSize)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Priority queue overflow!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将元素放在队列的后面并递增计数 */</span></span><br><span class="line"> pq-&gt;pqlist[pq-&gt;count] = item;</span><br><span class="line"> pq-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 从优先级队列中删除一个元素并返回其值 */</span></span><br><span class="line">DataType <span class="title function_">PQDelete</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> DataType min;</span><br><span class="line"> <span class="type">int</span> i, minindex = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 在优先级队列中查找最小值及其索引 */</span></span><br><span class="line"> min = pq-&gt;pqlist[<span class="number">0</span>];   <span class="comment">/* 假设pqlist[0]是最小值 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line"> <span class="keyword">if</span> (CompareEvent(&amp;pq-&gt;pqlist[i], &amp;min))</span><br><span class="line"> &#123;</span><br><span class="line"> min = pq-&gt;pqlist[i];</span><br><span class="line"> minindex = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将第二小元素移动到minindex并递减计数 */</span></span><br><span class="line"> pq-&gt;pqlist[minindex] = pq-&gt;pqlist[pq-&gt;count - <span class="number">1</span>]; </span><br><span class="line"> pq-&gt;count--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* qlist为空，终止程序 */</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Deleting from an empty priority queue!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 返回最小值 */</span></span><br><span class="line"> <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回优先级队列元素个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQLength</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> pq-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试优先级队列是否为空 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQEmpty</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> pq-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试优先级队列是否已满 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQFull</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> pq-&gt;count == MaxPQSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 通过将计数重置为0来清除优先级队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearPQ</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> pq-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4><span id="eventh"><strong>event.h</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下均为 event.h 内容 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">eventType</span> &#123;</span> arrival, departure &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">eventType</span> <span class="title">EventType</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">isVip</span> &#123;</span> notVip, Vip &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">isVip</span> <span class="title">IsVip</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> time;</span><br><span class="line">	EventType etype;</span><br><span class="line">	<span class="type">int</span> customerID;</span><br><span class="line">	<span class="type">int</span> tellerID;</span><br><span class="line">	<span class="type">int</span> waittime;</span><br><span class="line">	<span class="type">int</span> servicetime;</span><br><span class="line">	IsVip id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">Event</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事件初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitEvent</span><span class="params">(Event* e, <span class="type">int</span> t, EventType et, <span class="type">int</span> cn, <span class="type">int</span> tn, <span class="type">int</span> wt, <span class="type">int</span> st, IsVip iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	e-&gt;time = t;</span><br><span class="line">	e-&gt;etype = et;</span><br><span class="line">	e-&gt;customerID = cn;</span><br><span class="line">	e-&gt;tellerID = tn;</span><br><span class="line">	e-&gt;waittime = wt;</span><br><span class="line">	e-&gt;servicetime = st;</span><br><span class="line">	e-&gt;id = iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件时间为事件优先级队列的优先级，如果事件时间相等则优先执行离开事件 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CompareEvent</span><span class="params">(Event* e1, Event* e2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (e1-&gt;time &lt; e2-&gt;time ||</span><br><span class="line">		(e1-&gt;time == e2-&gt;time &amp;&amp; e1-&gt;etype == departure))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// e1出队</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (e1-&gt;time &gt; e2-&gt;time ||</span><br><span class="line">		(e1-&gt;time == e2-&gt;time &amp;&amp; e2-&gt;etype == departure))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// e2出队</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="eventc"><strong>event.c</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下均为 event.c 内容 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 生命模拟结构的存储空间 */</span></span><br><span class="line">    Simulation* S = (Simulation*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Simulation));</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">/* 设置随机数种子 */</span></span><br><span class="line">    InitSimulation(S);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行事件驱动模拟 */</span></span><br><span class="line">    RunSimulation(S);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出模拟结果 */</span></span><br><span class="line">    PrintSimulationResults(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="题目"><strong>题目</strong></span></h3><p>在原有代码基础上添加VIP窗口功能，VIP窗口的出纳员只服务VIP用户，当VIP用户到达后可以在本窗口 按照到达先后顺序等待。</p>
<p><strong>第一题约定</strong>  约定1号出纳员所在的1号窗口为VIP窗口，且银行中只有一个VIP窗口。 约定普通用户只能在普通窗口排队等候，其选择窗口的优先级为：空普通窗口&gt;非空普通窗口。 约定用户排队过程中选定窗口后就会一直在该队列中等待，不会更换排队队伍。 约定用户之间无法感知对方是处理何种业务，不知道其业务所需的具体时间和剩余时间。 约定模拟时间外不产生用户到达事件，但是银行将会处理完所有用户到达事件。</p>
<h4><span id="11"><strong>1.1</strong></span></h4><p><strong>题目：</strong> 约定VIP用户可以在普通窗口和VIP窗口排队等候，其选择窗口的优先级为：空VIP窗口&gt;空普通窗口&gt;非空 VIP窗口&gt;非空普通窗口。</p>
<p><strong>实现思路：</strong>原先代码已经实现了一个纯普通用户排队的代码，这题不涉及VIP用户的插队，所以只添加VIP与notVIP变量，再在原先基础上添加规定VIP用户窗口选择的函数就行，建议直接在NextAvailableTeller (Simulation* s) 上修改</p>
<h4><span id="12"><strong>1.2</strong></span></h4><p><strong>题目：</strong>约定VIP用户可以在VIP窗口排队等候，或者在普通窗口队列中插队（即排到普通窗口队列最前面）。 约定插队的VIP用户在普通窗口中按照到达顺序先后进行排队。 约定VIP用户选择窗口的优先级为：空VIP窗口&gt;空普通窗口&gt;插队到普通窗口队列。</p>
<p>第二问<strong>实现思路：</strong>参考NextAvailableTeller（）函数实现普通用户窗口选择的方法（通过比较窗口变量tstat的finishService变量并取最小值来实现），给tstat添加变量vipFinishService，它的值是新的VIP客户到这个窗口需要等待的时间（分析可知，它的值仅与当前正在服务的用户完成服务所需时间与排队中的VIP用户所需服务时间有关，与finishService变量不同的是当队列新加入普通用户（并且这个用户在排队中），finishService需要增加，而vipFinishService不需要），所以假设已经实现了这个变量，先把VIP用户窗口选择函数敲出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim.h</span></span><br><span class="line"><span class="comment">/* 计算下一个可供服务的出纳窗口号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">VipNextAvailableTeller</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minfinishindex = <span class="number">1</span>;						<span class="comment">/* 初始化最快空闲窗口为第一个窗口(vip专用窗口为1) */</span></span><br><span class="line">    <span class="type">int</span> minfinish = s-&gt;tstat[<span class="number">1</span>].vipFinishService;	<span class="comment">/* 初始化最快空闲时间预告为第一个窗口的空闲时间预告 */</span></span><br><span class="line">    <span class="type">int</span> num[<span class="number">1000</span>], m, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有窗口，找到最小空闲时间预告以及对应的窗口编号，如果存在多个最小窗口则随机选择其中一个 */</span></span><br><span class="line">    m = <span class="number">1</span>;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;tstat[<span class="number">1</span>].vipFinishService == <span class="number">0</span>)<span class="comment">//检查VIP窗口是否为空，若空则直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">sim.h	<span class="comment">//如果VIP窗口不为空，则遍历寻找所有窗口中最快的</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;tstat[i].vipFinishService &lt; minfinish) &#123;</span><br><span class="line">            minfinish = s-&gt;tstat[i].vipFinishService;</span><br><span class="line">            num[<span class="number">0</span>] = i;</span><br><span class="line">            m = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[i].vipFinishService == minfinish)</span><br><span class="line">                num[m++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;tstat[<span class="number">1</span>].vipFinishService == minfinish)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    minfinishindex = num[rand() % m];</span><br><span class="line">    <span class="keyword">return</span> minfinishindex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再就是vipFinishService这个变量的更新，这点就参考finishService的操作，观察代码，finishService只在RunSimulation中改变，就从这里改（不用完全明白为什么，利用finishService简化思路）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim.h</span></span><br><span class="line"><span class="comment">/* 运行事件驱动模拟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RunSimulation</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">			......</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[tellerID].finishService == <span class="number">0</span>)</span><br><span class="line">            &#123; </span><br><span class="line">                s-&gt;tstat[tellerID].finishService = e-&gt;time;</span><br><span class="line">                s-&gt;tstat[tellerID].vipFinishService = e-&gt;time;</span><br><span class="line">                <span class="keyword">if</span>(newevent-&gt;id==notVip)		<span class="comment">//防止特殊情况：有一个普通用户正在服务</span></span><br><span class="line">                    s-&gt;tstat[tellerID].vipFinishService += servicetime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算等待时间 */</span></span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//e-&gt;time就是新客户的到达时间，新客户的到达事件是newevent，e是刚刚出队列的事件</span></span><br><span class="line">            <span class="keyword">if</span> (newevent-&gt;id == notVip)</span><br><span class="line">                waittime = s-&gt;tstat[tellerID].finishService - e-&gt;time;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                waittime = s-&gt;tstat[tellerID].vipFinishService - e-&gt;time;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 按照当前到达事件信息修改选定出纳窗口信息 */</span></span><br><span class="line">    </span><br><span class="line">            s-&gt;tstat[tellerID].finishService += servicetime;</span><br><span class="line">            <span class="keyword">if</span>(newevent-&gt;id==Vip)<span class="comment">//vip才加</span></span><br><span class="line">                s-&gt;tstat[tellerID].vipFinishService += servicetime;</span><br><span class="line">            <span class="comment">/* 将生成的离开事件加入优先级队列 */</span></span><br><span class="line">            <span class="keyword">if</span>(newevent-&gt;id==notVip)</span><br><span class="line">                InitEvent(newevent, s-&gt;tstat[tellerID].finishService,</span><br><span class="line">                    departure, e-&gt;customerID, tellerID, waittime, servicetime, newevent-&gt;id);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                InitEvent(newevent, s-&gt;tstat[tellerID].vipFinishService,</span><br><span class="line">                    departure, e-&gt;customerID, tellerID, waittime, servicetime, newevent-&gt;id);</span><br><span class="line">                PQInsertVip(&amp;(s-&gt;pq), tellerID, servicetime, nexttime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PQInsert(&amp;(s-&gt;pq), *newevent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 处理离开事件 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">            tellerID = e-&gt;tellerID;</span><br><span class="line">            <span class="comment">/* 如果窗口在处理离开事件后空闲，则修改该出纳窗口的空闲时间预告 */</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;time == s-&gt;tstat[tellerID].finishService)</span><br><span class="line">            &#123;</span><br><span class="line">                s-&gt;tstat[tellerID].finishService = <span class="number">0</span>;</span><br><span class="line">                s-&gt;tstat[tellerID].vipFinishService = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是VIP插队之后的数据更新，构造PQInsertVip()，用来插入并更新队列数据，它的自变量有：VIP到达时间，VIP插入的窗口，VIP所需的服务时间servicetime，然后遍历整个队列，如果队列的元素与刚到达的VIP的服务窗口相同，并且是还未开始服务的普通用户，那么这个用户就会被VIP插队，直接结果是该用户的waittime增加VIP所需的服务时间（servicetime），该用户原定的离开时间增加servicetime，事实上只需要这些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apqueue.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PQInsertVip</span><span class="params">(PQueue* pq, <span class="type">int</span> index, <span class="type">int</span> serviceTime, <span class="type">int</span> VipArriveTime)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在优先级队列中更新vip插入后的客户情况</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].tellerID == index &amp;&amp; pq-&gt;pqlist[i].id==notVip &amp;&amp; pq-&gt;pqlist[i].time-pq-&gt;pqlist[i].servicetime&gt;VipArriveTime</span><br><span class="line">				&amp;&amp; pq-&gt;pqlist[i].etype==departure)</span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;pqlist[i].waittime += serviceTime;</span><br><span class="line">				pq-&gt;pqlist[i].time += serviceTime;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="2"><strong>2</strong></span></h4><p><strong>题目</strong>：约定只有出纳员服务完当前用户后，才会重新计算所有排队的用户中的VIP用户的等待时间，如果等待时 间已到达最长等待时间，将优先服务等待时间长的VIP用户。 约定等待时间满的VIP顾客，可以更换柜台服务。即所有柜台出纳员会按照等待时间由长到短的顺序服务 所有队列中的VIP用户。（对于VIP用户而言，打破最初不能更换队伍的约定） 无VIP窗口情况下，银行规定，VIP用户等待时间不得超过X分钟，VIP用户与普通用户之间设置排队策 略。 请同学们按照如下提示修改代码，使得VIP用户最多等待waitHigh时间。注意：出纳员只需要照顾本队列 中的VIP用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sim.h</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the longest waitting time the customer can tolerate in minutes: &quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;waitHigh);</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong>针对题意，我们可以这样理解：无VIP窗口，VIP1在waittime不超过最大等待时间的情况下正常排队（不插队），但如果正常插入时会超时，就插队，但是要注意，如果窗口前面有VIP2，这个VIP1只能插入到VIP2的后面，如果VIP1仍然等待超时，可能需要二者一起插队，这样太麻烦了，所以我化简了这个过程，这会导致运行结果有一点错误，但思路大大化简。分析题目，我们可以得到三个条件：</p>
<ul>
<li>1.我们当且仅当一个窗口的上一个用户被服务完后，再检查是否有超时VIP需要插队，这种情况下<strong>只有一个位置</strong>可以插队，插队优先级：全局中实际等待时间超时的VIP&gt;当前窗口中预计等待时间超时的VIP</li>
<li>2.所有VIP用户的最大等待时间都相同，所以当全部窗口中来得最早的、还在排队中的VIP用户未到达最大等待时间，那么所有的VIP用户此时都未到达最大等待时间，从而也就不需要更换窗口插队，如果有VIP用户需要换窗口插队，那么只能时全部窗口中来得最早的、还在排队中的VIP用户（其他用户此时的等待时间都比这个用户少） ，所以我们实现跨窗口插队时，只考虑全部窗口中来得最早的、还在排队中的VIP用户</li>
<li>3.用户的实际等待时间超时，全局遍历选窗口插队，预计等待时间waittime超时，在当前窗口插队，且优先级：前者大于后者</li>
</ul>
<p>有了这三点过程，我们进行过程模拟说明下：当某窗口s某用户接受完服务并离开的时刻，先遍历全局，检查是否有实际等待时间超时的VIP用户vip1，如果有，让其插队到s（s窗口可是该用户最快接受服务），（不需要遍历s窗口的VIP用户，因为即使遍历出来也要等待vip1服务完才能插队，也不需要循环遍历，找出所有等待超时的VIP用户，因为即使有，当前也没有服务窗口）如果没有（按结论2，全局都没有），则遍历整个窗口，检查是否有预计等待时间waittime超时的VIP用户，有则插到窗口最前面否则按正常顺序进行，（这是理想情况，但实际上前面说了，难以实现，简化之后的版本仅检查该窗口来得最早的VIP），没有则按正常顺序进行。</p>
<p><strong>错误分析：</strong></p>
<p>如下表队列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>出纳员</th>
<th>普通用户</th>
<th>普通用户</th>
<th>VIP1</th>
<th>VIP2</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>若VIP1的waittime不超时，而VIP2超时，这个代码不能将VIP1、VIP2都向前移使二者都不超时，只能在VIP1正在接受服务时才处理VIP2.</p>
<p><strong>代码修改：</strong>（代码模板为教辅源代码，但是需要1_2中用的PQInsertVip函数实现数据插入之后的更新）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apqueue.h</span></span><br><span class="line"><span class="comment">//查找当前窗口中是否有waittime超时的VIP用户，有则让它插队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Change</span><span class="params">(PQueue* pq, <span class="type">int</span> tellerID,<span class="type">int</span> high,<span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> max = <span class="number">999</span>;</span><br><span class="line">	<span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].etype == departure &amp;&amp; pq-&gt;pqlist[i].id == Vip &amp;&amp; pq-&gt;pqlist[i].tellerID==tellerID)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime &lt; max) &#123;</span><br><span class="line">					max = pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime;</span><br><span class="line">					index = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(index &amp;&amp; pq-&gt;pqlist[index].waittime&gt;high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> arriveTime = pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].waittime - pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		PQInsertVip(pq, tellerID, pq-&gt;pqlist[index].servicetime, arriveTime);</span><br><span class="line">		pq-&gt;pqlist[index].time = time + pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		pq-&gt;pqlist[index].waittime = time - arriveTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///由于VIP的最大等待时间都相同，所以查找现在所有窗口中是否有</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allChange</span><span class="params">(PQueue* pq, <span class="type">int</span> ID, <span class="type">int</span> high, <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> max = <span class="number">9999</span>;</span><br><span class="line">	<span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)<span class="comment">//在所有等待中的VIP顾客中找到最早到的VIP，判断其等待时间是否超限</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].etype == departure &amp;&amp; pq-&gt;pqlist[i].id == Vip)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime &lt; max) &#123;</span><br><span class="line">					max = pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime;</span><br><span class="line">					index = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> arrivetime = pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].waittime - pq-&gt;pqlist[index].servicetime;</span><br><span class="line">	<span class="keyword">if</span> (index &amp;&amp; time-arrivetime &gt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> address = pq-&gt;pqlist[index].tellerID;</span><br><span class="line">		<span class="type">int</span> arriveTime = pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].waittime - pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].etype == departure &amp;&amp; pq-&gt;pqlist[i].tellerID == address</span><br><span class="line">				&amp;&amp; pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].servicetime &gt; pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].servicetime)</span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;pqlist[i].time -= pq-&gt;pqlist[index].servicetime;</span><br><span class="line">				pq-&gt;pqlist[i].waittime -= pq-&gt;pqlist[index].servicetime;</span><br><span class="line">			&#125;</span><br><span class="line">		PQInsertVip(pq, ID, pq-&gt;pqlist[index].servicetime, arriveTime);</span><br><span class="line">		pq-&gt;pqlist[index].time = time + pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		pq-&gt;pqlist[index].waittime = time - arriveTime;</span><br><span class="line">		pq-&gt;pqlist[index].tellerID = ID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//return k;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim.h      </span></span><br><span class="line"><span class="comment">//上一个事件出队列之后进行如下操作</span></span><br><span class="line">			<span class="type">int</span> flag = allChange(&amp;(s-&gt;pq), e-&gt;tellerID, s-&gt;waitHigh, e-&gt;time);<span class="comment">/*扫描全部未进行的VIP，</span></span><br><span class="line"><span class="comment">            //是否有超时的如果有就先插队，实现一个更新函数，更新排在其前面的和</span></span><br><span class="line"><span class="comment">            //插队的，在此调用,如果插队了，后面的函数就不用调用了*/</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                Change(&amp;(s-&gt;pq),e-&gt;tellerID,s-&gt;waitHigh,e-&gt;time);<span class="comment">//在这个窗口中找到来得最早的vip，判断是否等待超时</span></span><br><span class="line">            <span class="comment">//如果超时，移到最前面</span></span><br></pre></td></tr></table></figure>
<h4><span id="3"><strong>3</strong></span></h4><p> 综合考虑各类角色等待时间：被VIP插队的用户越多，普通用户越不满；VIP等待的时间越长，VIP越不 满；有人排队但有窗口闲置时，银行不满。</p>
<p>请通过实验数据说明如何设置排队机制可能是最优的。 建议：参考题目设置，逐步放开随机化的元素进行分析，可站在用户的角度或者银行的角度说明。</p>
<p><strong>设计思路：</strong>银行不设置VIP窗口，VIP可以查到队列最前面，如果前面也有VIP则按时间顺序排，event增加两个变量waittime0：记录普通用户开始排队时的预计等待时间，flag：标志变量，有0，1两种取值，初值为0，如果VIP用户插队之后，遍历所有离开事件，对所有普通用户，若其当前的等待时间大于等于2倍的waittime0，将其身份设为VIP，flag置为0。</p>
<p>解释一下：从用户的角度，一直被插队会不满，所以需要设置一个限度，超过这个限度后该用户不可再被插队，有三种方案：用户等待时间到达一定时间后不能再被插队；用户被多少人插队之后不可再被插队；用户在预计等待时间超过初始预计等待时间的几倍后不可再被插队。这几种方案中，由于用户初始预计等待时间差别极大，所以最后一种更适合。</p>
]]></content>
      <tags>
        <tag>数据结构与算法 大作业</tag>
      </tags>
  </entry>
</search>
