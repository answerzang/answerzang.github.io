<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>KMP算法</title>
    <url>/2024/10/09/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>前言：个人关于KMP算法的一点理解</p>
<span id="more"></span>
<p>在介绍KMP算法前我们先介绍BP算法，暴力匹配算法，先上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BP</span><span class="params">(<span class="type">char</span>* str,<span class="type">char</span>* s)</span><span class="comment">//s为给定子串，str为带查找字符串，查找到则返回s在str中首次出现的位置，否则返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str)-<span class="built_in">strlen</span>(s);i++)&#123;	<span class="comment">//从str第一个字符开始其后字符依次与s匹配，注意边界</span></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;							<span class="comment">//判断条件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(s);j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i+j]!=s[j])&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;							<span class="comment">//若出现不匹配字符，停止本次操作，进行下一次匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对其复杂度分析得到其复杂度为O(mn)（m，n分别为子串与查找串的长度）。</p>
<p>接下来以查找串T=”aaabbaaaba”，子串P=”aaaba”为例分析其改进方法。</p>
<p><img src="../imgs/KMP%E7%AE%97%E6%B3%95/image-20241009194912582-17285422622071.png" alt></p>
<p>首先以我们的思维来讲，通过观察第一次匹配，我们一般会直接跳到最后一步，但这个算法却只能一步步进行匹配，我们可以从这里改进：①改变两次相邻匹配之间跳过的“<strong>步长</strong>”；②下一次匹配从子串第几个字符开始，即<strong>开始匹配位置</strong>。同时保证不出错。而KMP算法能帮我们解决这个问题。下面来详细讲讲这个算法：设s为子串，str为查找串</p>
<p>我们通过构建next[]数组来确定步长及下一次匹配的开始位置，开始介绍next[]数组之前，我们先讲一下其功能及原理：当子串匹配到第i位时字串与查找串不再匹配（隐含条件：前i-1位都匹配，可以做化简算法的突破口），此时我们通过使用next数组能够得到我们下一次匹配跳i-next[i]位，并且下一次匹配从s[next[i]]开始，虽然这里查找串是未知的，但子串是给定已知的，而前i-1位都匹配的条件并不会影响子串，所以我们可以通过子串来构建next数组。</p>
<p>我们为了方便理解，先给出一个不准确的描述：先来一个next[]数组中next[i]记录的是由子串s的前i-1位字符所成字符串（记为si）的最长相同前缀后缀的长度，（si的前缀/后缀均是其真子串）举个例子s=”aadgaadc”:(注意！这里next[i]的值并不完全正确，仅为方便理解，后面会讲为什么)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>i的值</th>
<th>前缀</th>
<th>后缀</th>
<th>next[i]</th>
<th>si</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-</td>
<td>-</td>
<td>-1</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>a</td>
<td>1</td>
<td>aa</td>
</tr>
<tr>
<td>3</td>
<td>a,aa</td>
<td>d,ad</td>
<td>0</td>
<td>aad</td>
</tr>
<tr>
<td>4</td>
<td>a,aa,aad</td>
<td>g,dg,adg</td>
<td>0</td>
<td>aadg</td>
</tr>
<tr>
<td>5</td>
<td>a,aa,aad,aadg</td>
<td>a,ga,dga,adga</td>
<td>1</td>
<td>aadga</td>
</tr>
<tr>
<td>6</td>
<td>a,aa,aad,aadg,aadga</td>
<td>a,aa,gaa,dgaa,adgaa</td>
<td>2</td>
<td>aadgaa</td>
</tr>
<tr>
<td>7</td>
<td>a,aa,aad,aadg,aadga,aadgaa</td>
<td>d,ad,aad,gaad,dgaad,adgaad</td>
<td>3</td>
<td>aadgaad</td>
</tr>
</tbody>
</table>
</div>
<p>现在我们再讲一遍其原理：子串第i位不匹配，但是其前i-1位子串都匹配，（拿上表i=7举例）查找串此时对应的位置就是aadgaad，我们就可以把它移到前后缀相匹配的位置</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配串</th>
<th>a</th>
<th>a</th>
<th>d</th>
<th>g</th>
<th>a</th>
<th>a</th>
<th>d</th>
<th>a</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>这次子串</td>
<td>a</td>
<td>a</td>
<td>d</td>
<td>g</td>
<td>a</td>
<td>a</td>
<td>d</td>
<td>(c)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>下次子串</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>a</td>
<td>a</td>
<td>d(相同，移动)</td>
<td>g</td>
<td>a</td>
<td>a</td>
<td>d</td>
</tr>
</tbody>
</table>
</div>
<p>此时，我们可以发现，移动了i-next[i]（7-3=4）位，这是有普遍性的，为了这个普遍性，我们特地规定了next[0]=-1,否则无法移动，next[1]=0也是同样的道理，同时移动后从子串的next[i]位开始比较，于是我们可以把（假设）已经得到next数组之后的代码写出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(<span class="type">char</span> *str, <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//事实上，我们只需要两个变量，一个变量记录查找串当前比较位置，一个变量记录子串当前比较位置，比较结果相同则二者均自增，不同则查找出按当前位置不变，子串通过next数组来改变，再利用strlen(s)与该变量的大小比较判断是否完全匹配，若是，则返回第一次完全匹配的开始位置</span></span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(m * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配next数组的空间</span></span><br><span class="line">    <span class="built_in">get_next</span>(s, next); <span class="comment">// 计算next数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">// 初始化i和j，分别用于匹配串和子串的索引</span></span><br><span class="line">    <span class="comment">// 遍历匹配串S</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">strlen</span>(str)) &#123;</span><br><span class="line">        <span class="comment">// 如果j为-1或当前字符匹配，则继续匹配下一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || str[i] == s[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果字符不匹配，则根据PMT数组回退j的位置</span></span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果j等于模式串的长度，则找到了匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">strlen</span>(S)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 返回匹配的起始索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果没有找到匹配，则返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们开始优化next数组：</p>
<p>1.上文已经提到的next[0]=-1,next[1]=0或-1（如aaa，next数组全是-1）;</p>
<p>2.有一种可能的情况：s[i]==s[next[i]]；在上面我们已经知道了s[i]与匹配串不匹配，那么下一次操作时我们会再次比较s[next[i]]与匹配串同一位置的字符，显然会匹配失败，为提高效率，我们应该避免，于是我们通过分析该过程来改进next数组：假设这种情况会发生，我们仅需要计算两次操作后总共移动多少位，从哪一位开始比较即可：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>移动几位</th>
<th>从哪一位比较</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次</td>
<td>i-next[i]</td>
<td>next[i]（这一位不匹配）</td>
</tr>
<tr>
<td>第二次</td>
<td>next[i]-next[next[i]]</td>
<td>next[next[i]]</td>
</tr>
</tbody>
</table>
</div>
<p>两次综合，移动了i-next[i]+next[i]-next[next[i]] = next[next[i]]位，从第next[next[i]]位开始比较。</p>
<p>于是，为了延续前面的规律，我们这样改进next数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==s[next[i]])&#123;</span><br><span class="line">    next[i] = next[next[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将两步乃至多部化简成了一步，使效率更高。</p>
<p><strong>代码</strong>如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> *next)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">-1</span>;			<span class="comment">//i指向后缀结尾的后一位，j指向前缀结尾</span></span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;<span class="built_in">strlen</span>(s)<span class="number">-1</span>)&#123;	<span class="comment">//j记录最长相同前后缀的长度，要及时更新</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; s[i]!=s[j])	<span class="comment">//当第i与j位不匹配时，j要向前找，而且一定</span></span><br><span class="line">            j = next[j];			<span class="comment">//要保证i前面的几位后缀要与开始的几位前缀匹配\，用j = next[j]可以快速利用前面的结果实现这个。终止条件里的j&gt;=0对应j=-1的情况，这\是由于next[0]=-1即一位都匹配不了，所以终止循环，向下走</span></span><br><span class="line">		i++;				</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])				<span class="comment">//如果出现相等的情况(上文提及)，这样操作</span></span><br><span class="line">            next[i] = next[j];		</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是O(m+n),m,n分别为子串与查找串的长度。</p>
<p>总之，主要的代码和思维就这些，代码可能有些晦涩难懂，建议自己写几个子串和查找串，然后根据代码手推几次，就理解了。</p>
<p>24/10/10 补充</p>
<p>这几天做了道题，关于KMP算法的，题目给出的并不是简单的字符串，而是一种复合体：第一位记载”字符数组”的原本内容，虽然我误打误撞搞出来了正确结果，但next数组求错了，所以我对这种情况专门写了一段代码（第一位是干扰项，不处理），如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(<span class="type">const</span> <span class="type">char</span> s[],<span class="type">int</span> next[])</span>&#123;</span><br><span class="line"><span class="comment">////这是正常情况，用于对比</span></span><br><span class="line"><span class="comment">//	int i=0,j=-1;</span></span><br><span class="line"><span class="comment">//	next[0] = -1;</span></span><br><span class="line"><span class="comment">//    while(i&lt;strlen(s)-1)&#123;</span></span><br><span class="line"><span class="comment">//        while(j&gt;=0 &amp;&amp; s[i]!=s[j])</span></span><br><span class="line"><span class="comment">//            j = next[j];</span></span><br><span class="line"><span class="comment">//		i++;</span></span><br><span class="line"><span class="comment">//        j++;</span></span><br><span class="line"><span class="comment">//        if(s[i]==s[j])</span></span><br><span class="line"><span class="comment">//            next[i] = next[j];</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            next[i] = j;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;<span class="comment">//原理是将next数组的每个值都+1，方便跳过第一个数据</span></span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//不搞也行</span></span><br><span class="line">	next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;s[<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">1</span> &amp;&amp; s[i]!=s[j])</span><br><span class="line">            j = next[j];</span><br><span class="line">		i++;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">            next[i] = next[j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=s[<span class="number">0</span>];i++)</span><br><span class="line">        next[i]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BM算法</title>
    <url>/2024/10/10/BM%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>参考文章</p>
<p><a href="https://blog.csdn.net/zniahfag/article/details/51338264?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=BM&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-51338264.142^v100^pc_search_result_base6&amp;spm=1018.2226.3001.4187">1</a></p>
<p><a href="https://blog.csdn.net/EQUINOX1/article/details/133256159?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=BM&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-6-133256159.142^v100^pc_search_result_base6&amp;spm=1018.2226.3001.4187">2</a></p>
<span id="more"></span>
<p>首先让我们来看一组字符：（规范名称，待匹配的字符串称文本串，用于匹配的子串称为模式串）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文本串</th>
<th>I</th>
<th>t</th>
<th></th>
<th>w</th>
<th>o</th>
<th>u</th>
<th>l</th>
<th>d</th>
<th></th>
<th>b</th>
<th>e</th>
<th></th>
<th>.</th>
<th>.</th>
<th>.</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td>w</td>
<td>o</td>
<td><strong>r</strong></td>
<td>d</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>w</td>
<td>o</td>
<td>r</td>
<td>d</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>我们发现，当’r’与’u’不匹配时，KMP算法会将’w’移到原先’r’的位置上，’w’与’u’对齐，但通过我们观察，”word”字符中没有’u’，所以”woul”与”word”不会再匹配，应该将模式串后移4位（匹配位置还没有到would的d上），这里可以作为我们算法优化的突破点。</p>
<p>进行深入分析，我们发现：KMP算法并未充分利用文本串的已知信息（即文本串与模式串不匹配的位置的信息），如果充分利用此信息，我们可以将模式串移动更多，使算法效率更高，于是便有了我们今天介绍的算法——BM算法，事实上，现在大部分情况下的字符匹配都是用的BM算法而非KMP算法。</p>
<p>BM算法实质上是令模式串移动的距离尽可能地大，而为了实现这个目标，BM算法包含了两个算法：</p>
<ul>
<li>坏字符算法</li>
<li>好后缀算法</li>
</ul>
<p>首先介绍坏字符算法：</p>
<p>如下表</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文本串</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>c</th>
<th>a</th>
<th>b</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>s</th>
<th>c</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式串</strong></td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>我们根据这个表来模拟匹配并讲解过程：</p>
<p>首先将模式串从后向前与文本串匹配，模式串第一次匹配的字符a与c显然不匹配，并且模式串中不含c字符，于是直接将其右移4（模式串长度）位，文本串中的aba均未参与匹配，很显然的效率提升。</p>
<p>这种直接后移整个匹配串的情况比较少见，很有可能模式串与文本串不匹配的字符在模式串中存在，于是有<strong>第二种情况</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>文本串</th>
<th>a</th>
<th>a</th>
<th>b</th>
<th>b</th>
<th>c</th>
<th>c</th>
<th>a</th>
<th>a</th>
<th>c</th>
<th>c</th>
<th>b</th>
<th>a</th>
<th>c</th>
<th>d</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模式串</strong></td>
<td>b</td>
<td>c</td>
<td><strong>c</strong></td>
<td>a</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td>b</td>
<td>c</td>
<td><strong>c</strong></td>
<td>a</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>模式串</strong></td>
<td></td>
<td></td>
<td></td>
<td>b</td>
<td>c</td>
<td><strong>c</strong></td>
<td>a</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>第一次匹配时，模式串的a与文本串的c不匹配，于是从模式串当前匹配位置（a）向前找最近的c字符（向前查找由其从后往前的匹配顺序决定），将查找到的最近的c字符与文本串的c字符对齐，进行下次匹配，又发现第二个模式串a与文本串的c不匹配，再次查找最近的c并对齐，匹配成功。</p>
<p>思路就是这样，现在我们其中的细节问题——如何判断字符是否在模式串中，如何获得距模式串当前匹配位置最近的某字符。</p>
<p>我们通过构建数组来解决这些问题，以模式串P=”at_that”为例讲解数组构建过程：</p>
<p>将这个数组命名为delta1[]，其长度为7，该数组记录模式串中每个字符相对于最右端<strong>最近</strong>的距离，如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>P:</th>
<th>*</th>
<th>a</th>
<th>t</th>
<th>_</th>
<th>t</th>
<th>h</th>
<th>a</th>
<th>t</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>delta1</strong></td>
<td>7</td>
<td>1</td>
<td>0</td>
<td>4</td>
<td>0</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>其代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASIZE 256</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_delta1</span><span class="params">(<span class="type">char</span> *P, <span class="type">int</span> m, <span class="type">int</span> delta1[])</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ASIZE; ++i)</span><br><span class="line">        delta1[i] = m;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i)</span><br><span class="line">     	delta1[P[i]] = m - i - <span class="number">1</span>;</span><br><span class="line">&#125;	<span class="comment">//从参考网站copy的</span></span><br><span class="line"><span class="comment">/*解释</span></span><br><span class="line"><span class="comment">字符的范围是0~255(字符值和int值的转换)，所以我们开一个大小位256的delta1数组用</span></span><br><span class="line"><span class="comment">于存储，m就是P的长度，第一个for循环将所有字符的距离都设为最大距离，第二个for循环</span></span><br><span class="line"><span class="comment">针对P的，将P中字符从前向后遍历，更新P中字符的delta1值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>那么这个数组如何使用呢？使用方法比较简单，假设P[i]匹配失败，且此时文本串对应位置字符为s，则查找delta1[s]，右移delta[s]+i-strlen(P)位，当然此时可能会出现小于0的情况。</p>
<p>举个例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式串</th>
<th>t</th>
<th>c</th>
<th>c</th>
<th>c</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>a</th>
</tr>
</thead>
<tbody>
<tr>
<td>文本串</td>
<td>t</td>
<td>c</td>
<td>d</td>
<td>c</td>
<td>b</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>delta1</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>右移2+2-5=-1位，出错。所以需要好后缀算法来解决这个问题，这里有个细节，就是储存每一位字符距右端的距离也可以解决这个问题，但是经过实践，加入好后缀算法更快。</p>
<p>先对好后缀做个说明：</p>
<p>假设模式串为：P=”xxxx<strong>abcd</strong>ffff<strong>abcd</strong>“假设匹配过程中移动到其右数第一个f时不匹配（abcd都匹配），那我们就将xxxx后的abcd移到原先abcd的位置，再继续比较，这里与P最后与文本串相匹配的abcd子串记为好后缀。</p>
<p>将记载数组好后缀信息的数组记为suffix[]，记载移动位数的数组gs[]，通过suffix的辅助来构建gs表，先做四点说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 9;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 6;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 13;</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th></th>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>gs[i] = 6;</p>
<p><strong>代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">suffixes</span><span class="params">(<span class="type">char</span> *pattern, <span class="type">int</span> pattern_len, <span class="type">int</span> suffix[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    [m<span class="number">-1</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (i = pattern_len<span class="number">-2</span>; i&gt;=<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>&amp;&amp;pattern[j] == p[m<span class="number">-1</span> - (i - j)])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        suffix[i] = i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preBmGs</span><span class="params">(<span class="type">char</span> *pattern, <span class="type">int</span> pattern_len, <span class="type">int</span> bmGs[])</span> &#123;</span><br><span class="line">     <span class="type">int</span> i, j, suffix[XSIZE];</span><br><span class="line">     suffixes(pattern, pattern_len, suffix);</span><br><span class="line">     <span class="comment">//都初始化为找不子串匹配到好后缀的</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pattern_len; ++i)</span><br><span class="line">        bmGs[i] = pattern_len; </span><br><span class="line">     j = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//最大前缀</span></span><br><span class="line">     <span class="keyword">for</span> (i = pattern_len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (suff[i] == i + <span class="number">1</span>)</span><br><span class="line">           <span class="keyword">for</span> (; j &lt; pattern_len - <span class="number">1</span> - i; ++j)</span><br><span class="line">             <span class="keyword">if</span> (bmGs[j] == pattern_len)</span><br><span class="line">                bmGs[j] = pattern_len - <span class="number">1</span> - i;</span><br><span class="line">    <span class="comment">//模式串中有子串匹配上好后缀</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= pattern_len - <span class="number">2</span>; ++i)</span><br><span class="line">       bmGs[pattern_len - <span class="number">1</span> - suff[i]] = pattern_len - <span class="number">1</span> - i;</span><br><span class="line">&#125;				<span class="comment">//复制的</span></span><br></pre></td></tr></table></figure>
<p>这里本人时间原因，就不解释了。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/06/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构与算法-最大子列</title>
    <url>/2024/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97/</url>
    <content><![CDATA[<p>原题：有一数列 A~1~,A~2~,A~3~…A~n~,其中可能有负数，假设其子列A~1~,……A~j~(i&lt;=j)，使得$\sum_{i=i}^{j}x_i$取到最大值，请设计函数求该最大值。</p>
<p>分析：首先我们很自然地想到使用穷举法来实现，从此出发，先将这种简单的思路实现。</p>
<span id="more"></span>
<p><strong>代码一：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tsum=msum=A[<span class="number">0</span>];<span class="comment">//tsum记录代码运行中得到的下标从i到j的子列求和值，msum记录最大值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tsum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k-i;k&lt;=j;k++)</span><br><span class="line">				tsum+=A[i];</span><br><span class="line">			<span class="keyword">if</span>(tsum&gt;msum)</span><br><span class="line">				msum = tsum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们分析这段代码，其时间复杂度为O(n^3^)，好像并不慢，但如果数据很多，似乎就有些慢了，所以我们在这里将其优化：</p>
<p><strong>代码二</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tsum=msum=A[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		tsum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			tsum+=A[i];</span><br><span class="line">			<span class="keyword">if</span>(tsum&gt;msum)</span><br><span class="line">				msum = tsum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过观察，我们发现代码二优化了代码一中从A~1~到A~j~的相加过程，即当i不变，j++时，tsum不需要从i一直加到j，只需要在原结果上加上A~j~，其时间复杂度为O(n^2^)大大提高了运算效率。</p>
<p>但是，算法能否再次优化使得效率<strong>再次提高</strong>呢？答案是肯定的，我们先观察代码再做分析。</p>
<p><strong>代码三：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">const</span> <span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> tsum=msum=A[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		tsum+=A[j];</span><br><span class="line">		<span class="keyword">if</span>(tsum&gt;msum)</span><br><span class="line">			msum = tsum;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tsum &lt; <span class="number">0</span>)</span><br><span class="line">			tsum = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> msum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析这段代码，我们得到这段代码的时间复杂度时O(n)，运算效率很高，对比前面两段代码，这段代码将i优化掉了，实际上，我们将i的初始值交给了<u>else if(tsum &lt; 0)</u>这段语句，这条语句第一次生效前，i可以理解为0，tsum为从数列下标0到j的元素求和，如果tsum小于0，则说明我们接下来要求的子列和的结果为一个负数剩下的子列求和相加，为了求最大值，我们要将负数去掉，也就是更新i的值，使得我们能得到尽可能大的tsum值，而<u>if(tsum&gt;msum)</u>确保了我们不会因为更新i而错过最大值。</p>
<h4><span id="总结"><strong>总结：</strong></span></h4><p>我们从最简单粗暴的思路出发，不断将算法优化，最终得到了比较完美的算法。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序1</title>
    <url>/2024/10/10/%E6%8E%92%E5%BA%8F1/</url>
    <content><![CDATA[<p>注：这篇文章偏笔记性质，所以解释较少。同时，本文分时间复杂度，最好情况时间复杂度，最坏情况时间复杂度，空间复杂度及应用几个方面分析算法好坏。</p>
<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#1-插入排序">1 插入排序</a><ul>
<li><a href="#11-直接插入排序">1.1 直接插入排序</a></li>
<li><a href="#12-折半插入排序">1.2 折半插入排序</a></li>
<li><a href="#13-shell排序">1.3 Shell排序</a></li>
</ul>
</li>
<li><a href="#2-选择排序">2 选择排序</a><ul>
<li><a href="#21-直接选择排序">2.1 直接选择排序</a></li>
<li><a href="#22-树形选择排序">2.2 树形选择排序</a></li>
</ul>
</li>
<li><a href="#3交换排序">3交换排序</a><ul>
<li><a href="#31冒泡排序">3.1冒泡排序</a></li>
<li><a href="#32快速排序">3.2快速排序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="1-插入排序">1 插入排序</span></h2><h3><span id="11-直接插入排序">1.1 直接插入排序</span></h3><p>直接插入排序是一种最简单的排序方法（思路简单），整个排序过程为先将第一个元素视为有序数列，然后从第二个元素开始插入，直到将最后一个元素插入前面的有序列中。其最好情况时间复杂度为O(n)，即数组已经顺序排好，最坏情况时间复杂度为O(n^2^)，逆序，平均为O(n^2^)，其优点是可以用来排打乱了少数数据，大部分数据仍然有序的数据组。其基本过程如下图：<img src="../imgs/%E6%8E%92%E5%BA%8F1/image-20241008200428256-17285765494311.png" alt></p>
<p><strong>代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DirectInsertionSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        j = i;</span><br><span class="line">        temp = A[i];</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; temp&lt;A[j<span class="number">-1</span>])&#123;</span><br><span class="line">            A[j] = A[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        A[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="12-折半插入排序">1.2 折半插入排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinaryInsertionSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,k,r;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        temp = A[i];</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        r = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            m = (k+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;A[m])</span><br><span class="line">                r = m<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                k = m+<span class="number">1</span>;</span><br><span class="line">       	&#125;     </span><br><span class="line">        <span class="keyword">for</span>(r=i;r&gt;k;r--)</span><br><span class="line">        	A[r] = A[r<span class="number">-1</span>];        </span><br><span class="line">        A[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="13-shell排序">1.3 Shell排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n,<span class="type">int</span> s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(k=s;k&gt;<span class="number">0</span>;k&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=k;i&lt;n;i++)&#123;</span><br><span class="line">            temp = A[i];</span><br><span class="line">            j = i-k;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;A[j])&#123;</span><br><span class="line">                A[j+k] = A[j];</span><br><span class="line">                j-=k;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j+k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-选择排序">2 选择排序</span></h2><h3><span id="21-直接选择排序">2.1 直接选择排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DirectSelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[i])</span><br><span class="line">                k = j;</span><br><span class="line">        <span class="keyword">if</span>(i!=k)&#123;</span><br><span class="line">            temp = A[k];</span><br><span class="line">            A[k] = A[i];</span><br><span class="line">            A[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="22-树形选择排序">2.2 树形选择排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//nothing now</span></span><br></pre></td></tr></table></figure>
<h2><span id="3交换排序">3交换排序</span></h2><h3><span id="31冒泡排序">3.1冒泡排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=n<span class="number">-1</span>,flag=(<span class="type">bool</span>)<span class="number">1</span>;i&gt;<span class="number">0</span>&amp;&amp;flag;i--)&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;					<span class="comment">//设置未交换标志</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(A[j+<span class="number">1</span>]&lt;A[j])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;			<span class="comment">//有交换发生，置标志</span></span><br><span class="line">                temp = A[j+<span class="number">1</span>];			<span class="comment">//交换</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="32快速排序">3.2快速排序</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;=high) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    i = low;</span><br><span class="line">    j = high;</span><br><span class="line">    temp = A[i];	<span class="comment">/*将第一个元素设为中心值*/</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="comment">/*从后向前将进行比较，知道当前记录的数值小于中心值*/</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; temp&lt;A[j]) j--;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            A[i++] = A[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; temp&gt;=A[i]) i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            A[j--] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    A[i] = temp;</span><br><span class="line">    QuickSort(A,low,--j);</span><br><span class="line">    QuickSort(A,++i,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治思想</title>
    <url>/2024/10/09/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<p>分治思想即将复杂问题分解成一个个规模较小的子问题，最后得到可以直接求解的子问题，从而自底向上求解，两个重点：子问题规模更小，可以得到能直接求解的子问题。</p>
<p><strong>题目：</strong>给定一个数n，将其分解成若干个正整数之和，以6为例，6=6，6=5+1，6=4+2，6=4+1+1，6=3+3，6=3+2+1，6=3+1+1+1，6=2+2+2，6=2+2+1+1，6=2+1+1+1+1，6=1+1+1+1+1+1，共11种，请设计函数，求数n分解方法有多少种；</p>
<span id="more"></span>
<p><strong>思路：</strong>根据题目，自然地联想到用递归解决，递归的核心是将问题分解成规模更小的子问题而求解，先假设函数为Q(n)，现在我们思考Q(n)与Q(n-1)之间的关系，但经过探究，我们可以发现，这种关系难以寻找，于是我们加入变量m，函数Q(n,m)表示n分解成若干个不大于m的数之和方法种数，对函数Q(n,m)，其可以分解为Q(n,m-1)与n分解成不若干个包含m的数之和方法种数之和，注意到m与n都为定值，所以n分解成不若干个包含m的数之和方法种数之和等于将（n-m）分解成若干个不大于m的数之和方法种数，即Q(n-m,m)，<strong>于是得到Q(n,m)=Q(n,m-1)+Q(n-m,m)</strong>，此即为递推式，之后我们讨论终止条件与限定条件，如下，不赘述。（思考：若n分解成的加数不允许有重复，那么怎么写递推式？Q(n,m)=Q(n,m-1)+Q(n-m,m-1)）</p>
<script type="math/tex; mode=display">
Q(n,m)=
\begin{equation}
    \left\{
        \begin{array}{lr}
        1 & m = 1 &or& n=1\\\\
        Q(n,n) & n<m\\\\
        1+Q(n,n-1) & n=m\\\\
        Q(n,m-1)+Q(n-m,m) & n>m>1\\
        \end{array}
    \right. 
\end{equation}</script><p><img src="../imgs/%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-10%20235758.png" alt></p>
<p><strong>题目变式1：</strong>若将题目加入限制条件：将n分解为k个数之和，递推式又该怎么写？令函数为Q(n,k)，做如下操作：将n分解成的k个数都减去1，则有两种情况：1、n分解成的k个数都大于1，这种情况的分解方法数等于Q(n-k,k)；2、n分解成的k个数至少一个等于1，把等于1的数单独拿出来（相当于这个已经固定了），这种情况的种数为Q(n-1,k-1)。于是我们得到：<strong>Q(n,k)=Q(n-k,k)+Q(n-1,k-1)</strong>，再设定终止情况就OK了。</p>
<p><strong>题目变式2：</strong>如果n只能分解成k个奇数或者k个偶数，递推式又该如何写？这里我们假设奇数的函数为f(n,k)，偶数为g(n,k)，我们故技重施，对奇数有f(n,k)=g(n-k,k)+f(n-1,k-1)，对偶数有g(n,k)=f(n-k,k)（符合条件的最小的偶数为2，大于1）。</p>
<p><strong>题目变式3：</strong>如果将n分解成k个不同的数，又该怎么写？答案是<strong>Q(n,k)=Q(n-k,k)+Q(n-k,k-1)</strong></p>
<p><strong>解释：</strong>如果有且仅有一个1，那么剩下的数必然全大于等于1，所以将剩下的所有组成数都减去1，结果不变的同时还可以减小问题规模，这是表达式为Q(n-1-(k-1),k-1)=Q(n-k,k-1),如果没有1，将所有数都减去1，得到Q(n-k,k)，于是我们得到了这个式子。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈实现表达式运算</title>
    <url>/2024/10/10/%E6%A0%88%E5%AE%9E%E7%8E%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#1栈的实现">1.栈的实现</a><ul>
<li><a href="#11基本函数">1.1基本函数</a></li>
<li><a href="#12代码实现">1.2代码实现</a></li>
</ul>
</li>
<li><a href="#2中缀以及后缀表达式">2.中缀以及后缀表达式</a><ul>
<li><a href="#21中缀表达式">2.1中缀表达式</a></li>
<li><a href="#22后缀表达式">2.2后缀表达式</a></li>
</ul>
</li>
<li><a href="#3用栈实现表达式求值">3.用栈实现表达式求值</a><ul>
<li><a href="#31后缀表达式求值">3.1后缀表达式求值</a></li>
<li><a href="#32中缀表达式求值">3.2中缀表达式求值</a></li>
</ul>
</li>
<li><a href="#4中后缀表达式转换">4.中后缀表达式转换</a></li>
<li><a href="#5补充错误后缀表达式的判断及处理">5.补充——错误后缀表达式的判断及处理</a></li>
</ul>
<!-- tocstop -->
<p>说明：这篇博客以代码为主</p>
<span id="more"></span>
<h2><span id="1栈的实现">1.栈的实现</span></h2><h3><span id="11基本函数">1.1基本函数</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//存储栈的元素值（1个） </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span><span class="comment">//存储下一个元素（朝栈底方向）节点的地址 </span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LinkStack *<span class="title function_">InitStack</span><span class="params">()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(LinkStack *s)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.判断栈是否为空</span></span><br><span class="line"><span class="comment">若为空，返回1；</span></span><br><span class="line"><span class="comment">否则，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(LinkStack *s)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Push</span><span class="params">(LinkStack *s,ElemType e)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.出栈 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6.取栈顶元素 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.输出</span></span><br><span class="line"><span class="comment">从栈顶 至 栈底 全部输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkStack *s)</span></span><br></pre></td></tr></table></figure>
<h3><span id="12代码实现">1.2代码实现</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;<span class="comment">//存储栈的元素值（1个） </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span><span class="comment">//存储下一个元素（朝栈底方向）节点的地址 </span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">空：s-&gt;next==NULL </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.初始化 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LinkStack *<span class="title function_">InitStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack *s;</span><br><span class="line">	s=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.销毁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyStack</span><span class="params">(LinkStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType m;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s,ElemType *e)</span>;</span><br><span class="line">	<span class="keyword">while</span>(s-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//出栈</span></span><br><span class="line">		Pop(s,&amp;m); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">free</span>(s); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.判断栈是否为空</span></span><br><span class="line"><span class="comment">若为空，返回1；</span></span><br><span class="line"><span class="comment">否则，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">StackEmpty</span><span class="params">(LinkStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.进栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">Push</span><span class="params">(LinkStack *s,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack *t;</span><br><span class="line">	<span class="comment">//1.构造一个节点t，存储元素值e </span></span><br><span class="line">	t=(LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">	t-&gt;data=e;</span><br><span class="line">	<span class="comment">//2.把t节点添加到头节点的后面 </span></span><br><span class="line">	t-&gt;next=s-&gt;next;</span><br><span class="line">	s-&gt;next=t;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.出栈 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack *t; </span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//1.让t指向栈顶元素节点</span></span><br><span class="line">		t=s-&gt;next;</span><br><span class="line">		<span class="comment">//2.把栈顶元素值存储到*e中</span></span><br><span class="line">		*e=t-&gt;data;</span><br><span class="line">		<span class="comment">//3.删除</span></span><br><span class="line">		s-&gt;next=t-&gt;next;</span><br><span class="line">		<span class="comment">//4.释放存储空间</span></span><br><span class="line">		<span class="built_in">free</span>(t); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空，不能出栈！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6.取栈顶元素 </span></span><br><span class="line"><span class="comment">若栈不空，进行相关操作，并返回1；</span></span><br><span class="line"><span class="comment">否则，提示，返回0 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetTop</span><span class="params">(LinkStack *s,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(s-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//不空</span></span><br><span class="line">	&#123;</span><br><span class="line">		*e=s-&gt;next-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;栈空，不能取栈顶元素！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.输出</span></span><br><span class="line"><span class="comment">从栈顶 至 栈底</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkStack *s)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">while</span>(s-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s-&gt;next-&gt;data);</span><br><span class="line">		s = s-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LinkStack s;</span><br><span class="line">	s = *InitStack();</span><br><span class="line">    Push(&amp;s,<span class="number">1</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">2</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">3</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">4</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">5</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">6</span>);</span><br><span class="line">	Push(&amp;s,<span class="number">7</span>);</span><br><span class="line">	</span><br><span class="line">	ElemType *e;</span><br><span class="line">	e = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">	    </span><br><span class="line">	GetTop(&amp;s,e);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*e);</span><br><span class="line"> 	Pop(&amp;s,e);</span><br><span class="line"> </span><br><span class="line"> 	GetTop(&amp;s,e);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*e);	</span><br><span class="line"> 	</span><br><span class="line"> 	display(&amp;s);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> 	</span><br><span class="line"> 	GetTop(&amp;s,e);</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*e); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2><span id="2中缀以及后缀表达式">2.中缀以及后缀表达式</span></h2><h3><span id="21中缀表达式">2.1中缀表达式</span></h3><p><strong>例：2*(3+4)-8/2</strong></p>
<p>说明：日常所见绝大多数运算都是运算顺序与符号的出现顺序不一定相同</p>
<h3><span id="22后缀表达式">2.2后缀表达式</span></h3><p><strong>例：2 3 + 4 *82/-</strong></p>
<p>说明：没有括号，运算顺序与符号出现的前后顺序一致</p>
<h2><span id="3用栈实现表达式求值">3.用栈实现表达式求值</span></h2><h3><span id="31后缀表达式求值">3.1后缀表达式求值</span></h3><p><strong>运算方式：</strong>构造一个数栈，扫描表达式，若是数字则入栈，若是运算符则取出两个数字运算，并将结果放入数栈中，最后数栈中仅剩的一个元素即为表达式的计算结果。</p>
<p><strong>示例</strong>：</p>
<p>初始</p>
<p>​        表达式：234+*82/-</p>
<p>​        操作数栈：{ }</p>
<p>第一步</p>
<p>​        表达式：34+*82/-</p>
<p>​        操作数栈：{2 }</p>
<p>第二步</p>
<p>​        表达式：4+*82/-</p>
<p>​        操作数栈：{2,3 }</p>
<p>第三步</p>
<p>​        表达式：+*82/-</p>
<p>​        操作数栈：{2,3,4 }</p>
<p>第四步</p>
<p>​        表达式：*82/-</p>
<p>​        操作数栈：{2,7 }</p>
<p>第五步</p>
<p>​        表达式：82/-</p>
<p>​        操作数栈：{14 }</p>
<p>第六步</p>
<p>​        表达式：2/-</p>
<p>​        操作数栈：{14,8 }</p>
<p>第七步</p>
<p>​        表达式：/-</p>
<p>​        操作数栈：{14,8,2 }</p>
<p>第八步</p>
<p>​        表达式：-</p>
<p>​        操作数栈：{14,4 }</p>
<p>第九步</p>
<p>​        表达式：</p>
<p>​        操作数栈：{10 }</p>
<p>计算结束</p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EvaluatePostfix</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size=<span class="number">80</span>;   <span class="type">char</span> buf[size];   <span class="type">int</span> i=<span class="number">0</span>,k;</span><br><span class="line">    Stack *Spnd = new Stack(size);</span><br><span class="line">    <span class="built_in">printf</span>(“Input Postfix\n”);  <span class="built_in">scanf</span>(“%s”, buf);</span><br><span class="line">    <span class="keyword">while</span> (buf[i]!=‘\<span class="number">0</span>’)</span><br><span class="line">    &#123;   <span class="keyword">switch</span>(buf[i])</span><br><span class="line">        &#123;   <span class="keyword">case</span> ‘+’: </span><br><span class="line">  k= Spnd.Pop()+ Spnd.Pop(); Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ‘-’: </span><br><span class="line">  k= Spnd.Pop(); k=Spnd.Pop()-k; Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ‘*’: </span><br><span class="line">  k=Spnd.Pop()*Spnd.Pop(); Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ‘/’: </span><br><span class="line">  k=Spnd.Pop(); k=Spnd.Pop()/k; Spnd.Push(k); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">  Spnd.Push((<span class="type">int</span>)(buf[i]<span class="number">-48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(“The value is %d\n”, Spnd.Pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="32中缀表达式求值">3.2中缀表达式求值</span></h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>当前</th>
<th>运算符</th>
<th>栈顶</th>
<th>元素</th>
<th>T</th>
</tr>
</thead>
<tbody>
<tr>
<td>当前</td>
<td></td>
<td>空</td>
<td>（</td>
<td>+或-</td>
<td>*或/</td>
</tr>
<tr>
<td>获取</td>
<td>（</td>
<td>W进栈</td>
<td>W进栈</td>
<td>W进栈</td>
<td>W进栈</td>
</tr>
<tr>
<td>的运</td>
<td>）</td>
<td>Error</td>
<td>T出栈</td>
<td>T出栈并计算</td>
<td>T出栈并计算</td>
</tr>
<tr>
<td>算符</td>
<td>*或/</td>
<td>W进栈</td>
<td>W进栈</td>
<td>T出栈并计算</td>
<td>W进栈</td>
</tr>
<tr>
<td>W</td>
<td>+或-</td>
<td>W进栈</td>
<td>W进栈</td>
<td>T出栈并计算</td>
<td>T出栈并计算</td>
</tr>
</tbody>
</table>
</div>
<p><strong>运算方式：</strong>构造两个栈，数栈与运算符栈，扫描表达式，若是数则直接进数栈，若是运算符则判断其<strong>上一个运算符</strong>是否能运算（将扫描到的运算符W与栈顶元素T比较，见上表），若能运算，则运算符出栈，并且数栈弹出两个数来运算，结果再存进数栈，然后刚刚扫描到的元素再与当前栈顶元素比较，能运算则重复上述操作，否则运算符进栈，继续扫描表达式。</p>
<p>注意：右括号不会进运算符栈，一旦扫描到右括号，则运算符弹栈，直到弹出左括号。</p>
<p>关键：</p>
<ul>
<li>保持运算符栈的栈顶运算符在运算符栈中具有最高优先级</li>
<li>通过出栈来保证这一点</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INIT_SIZE 20	 <span class="comment">// 栈初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INCREMENT 10   <span class="comment">//栈满后，每次扩充的容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPRESS_MAX 1024 <span class="comment">//后缀表达式 长度不能超过1024</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"> </span><br><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">EleType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SeqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	EleType* top;<span class="comment">//栈顶指针</span></span><br><span class="line">	EleType* base;<span class="comment">//栈底指针</span></span><br><span class="line">	<span class="type">int</span> stackSize;<span class="comment">//栈容量</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">InitStack</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//开辟空间</span></span><br><span class="line">	<span class="built_in">stack</span>-&gt;base = <span class="built_in">stack</span>-&gt;top = (EleType*)<span class="built_in">malloc</span>(STACK_INIT_SIZE * <span class="keyword">sizeof</span>(EleType));</span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">stack</span>-&gt;base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;stackSize = STACK_INIT_SIZE;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//压栈</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">push</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>, EleType e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//压栈之前检测容量是否足够</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top - <span class="built_in">stack</span>-&gt;base == <span class="built_in">stack</span>-&gt;stackSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//超出容量 进行扩容，使用realloc函数，会拷贝原内存内容</span></span><br><span class="line">		<span class="built_in">stack</span>-&gt;base = (EleType*)<span class="built_in">realloc</span>(<span class="built_in">stack</span>-&gt;base, <span class="built_in">stack</span>-&gt;stackSize + STACK_INCREMENT);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">stack</span>-&gt;base)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;base + <span class="built_in">stack</span>-&gt;stackSize;</span><br><span class="line">		<span class="built_in">stack</span>-&gt;stackSize += STACK_INCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">stack</span>-&gt;top = e;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">pop</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>, EleType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span> || e == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//空栈</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="built_in">stack</span>-&gt;base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*<span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">	*e = *<span class="built_in">stack</span>-&gt;top;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取栈顶元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">GetTop</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>, EleType *e)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	*e = *(<span class="built_in">stack</span>-&gt;top - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">判断栈是否为空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmptyStack</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top == <span class="built_in">stack</span>-&gt;base) &#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">销毁栈</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">template&lt;class EleType&gt;</span><br><span class="line">Status <span class="title function_">DestroyStack</span><span class="params">(SeqStack&lt;EleType&gt;* <span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == <span class="built_in">stack</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//销毁栈 是释放栈在内存中占用的空间资源</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">stack</span>-&gt;base)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;base);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;top = <span class="built_in">stack</span>-&gt;base = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">stack</span>-&gt;stackSize = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span>* <span class="title function_">MidExpToAfterExp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* midExp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//后缀表达式</span></span><br><span class="line">	<span class="type">char</span>* afterExp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*EXPRESS_MAX);</span><br><span class="line">	<span class="built_in">memset</span>(afterExp, <span class="number">0</span>, EXPRESS_MAX);</span><br><span class="line">	<span class="type">int</span> j = <span class="number">0</span>;<span class="comment">//afterExp下标</span></span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;<span class="comment">//preExp下标</span></span><br><span class="line"> </span><br><span class="line">	SeqStack&lt;<span class="type">char</span>&gt; <span class="built_in">stack</span>;<span class="comment">// + - * / ( ）符号栈</span></span><br><span class="line">	InitStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="type">char</span> numBuf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//连续的数字不能超过10位，也就是中缀表达式中数字不能超过10位</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> numIndex = <span class="number">0</span>;<span class="comment">//numBuf 下标</span></span><br><span class="line">	<span class="keyword">while</span> (midExp[k])</span><br><span class="line">	&#123;</span><br><span class="line">		ch = midExp[k++];</span><br><span class="line">		<span class="comment">//忽略中缀表达式中的空格</span></span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//回车代表中缀输入完毕</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//1、若是数字就输出</span></span><br><span class="line">		<span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果输入连续的数字，不是连续的数字 循环完毕 会走 2、非数字</span></span><br><span class="line">			<span class="keyword">while</span> (((ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || <span class="string">&#x27;.&#x27;</span> == ch) &amp;&amp; numIndex &lt; <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				numBuf[numIndex++] = ch;</span><br><span class="line">				afterExp[j++] = ch;</span><br><span class="line">				ch = midExp[k++];</span><br><span class="line">			&#125;</span><br><span class="line">			numBuf[numIndex] = <span class="number">0</span>;</span><br><span class="line">			afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//回车代表中缀输入完毕</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//忽略中缀表达式中的空格</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == ch)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2、非数字</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			numIndex = <span class="number">0</span>;<span class="comment">//进入这个if 数字肯定不连续了，下标重置为0</span></span><br><span class="line">						 <span class="comment">//右括号一定弹栈</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&#x27;)&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> flag = <span class="number">1</span>;<span class="comment">//判断中缀表达式中括号是否匹配,如果成对出现</span></span><br><span class="line">				<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">					<span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch)</span><br><span class="line">					&#123;</span><br><span class="line">						flag = <span class="number">0</span>;<span class="comment">//走到这里说明是()括号成对出现</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					afterExp[j++] = ch;</span><br><span class="line">					afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (flag)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;中缀表达式输入错误\n&quot;</span>);</span><br><span class="line">					<span class="comment">//exit(0);</span></span><br><span class="line">					<span class="keyword">return</span>	<span class="literal">NULL</span>;</span><br><span class="line">				&#125;</span><br><span class="line"> </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// + - 符号是优先级最低的，一定是先依次弹栈再压栈。</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;+&#x27;</span> == ch || <span class="string">&#x27;-&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">char</span> top;</span><br><span class="line">				GetTop(&amp;<span class="built_in">stack</span>, &amp;top);</span><br><span class="line">				<span class="comment">//栈空或者栈顶为左括号 直接压栈</span></span><br><span class="line">				<span class="keyword">if</span> (IsEmptyStack(&amp;<span class="built_in">stack</span>) || <span class="string">&#x27;(&#x27;</span> == top)</span><br><span class="line">				&#123;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">char</span> cur = ch;</span><br><span class="line">					<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">						<span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//不是因为)右括号而弹栈，多弹的(左括号压回去</span></span><br><span class="line">							push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						afterExp[j++] = ch;</span><br><span class="line">						afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line"> </span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// * / 符号优先级只比 + -高，栈空或栈顶为(+-符号栈才直接压栈，其他情况先依次弹栈再压栈</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == ch || <span class="string">&#x27;/&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">char</span> top;</span><br><span class="line">				GetTop(&amp;<span class="built_in">stack</span>, &amp;top);</span><br><span class="line">				<span class="comment">//栈空或者栈顶为左括号同样直接压栈</span></span><br><span class="line">				<span class="keyword">if</span> (IsEmptyStack(&amp;<span class="built_in">stack</span>) || <span class="string">&#x27;(&#x27;</span> == top || <span class="string">&#x27;-&#x27;</span> == top || <span class="string">&#x27;+&#x27;</span> == top)</span><br><span class="line">				&#123;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;*&#x27;</span> == top || <span class="string">&#x27;/&#x27;</span> == top)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">char</span> cur = ch;</span><br><span class="line">					<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">					&#123;</span><br><span class="line">						pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">						<span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch || <span class="string">&#x27;-&#x27;</span> == ch || <span class="string">&#x27;+&#x27;</span> == ch)</span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//不是因为)右括号而弹栈 * / 优先级高于栈顶 + - 就不弹栈了，多弹的压回去</span></span><br><span class="line">							push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						afterExp[j++] = ch;</span><br><span class="line">						afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, cur);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;(&#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				push(&amp;<span class="built_in">stack</span>, ch);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;中缀表达式输入错误\n&quot;</span>);</span><br><span class="line">				<span class="comment">//exit(0);</span></span><br><span class="line">				<span class="keyword">return</span>	<span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//符号栈内容不为空 依次出栈并打印</span></span><br><span class="line">	<span class="keyword">while</span> (!IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		pop(&amp;<span class="built_in">stack</span>, &amp;ch);</span><br><span class="line">		afterExp[j++] = ch;</span><br><span class="line">		afterExp[j++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> afterExp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过栈对后缀表达式进行求值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">GetResultAfterExp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* afterExp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == afterExp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// a b 是表达式中的2个操作数</span></span><br><span class="line">	<span class="type">double</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;<span class="comment">// afterExp 下标</span></span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;<span class="comment">//后缀表达式中的字符</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">char</span> numBuf[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//连续的数字不能超过10位，也就是后缀表达式中数字不能超过10位</span></span><br><span class="line">	<span class="type">int</span> numIndex = <span class="number">0</span>;<span class="comment">//numBuf 下标</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	SeqStack&lt;<span class="type">double</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">	InitStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">	<span class="keyword">while</span> (afterExp[k])</span><br><span class="line">	&#123;</span><br><span class="line">		ch = afterExp[k++];</span><br><span class="line">		<span class="comment">//是数值</span></span><br><span class="line">		<span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (((ch &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;ch &lt;= <span class="string">&#x27;9&#x27;</span>) || ch == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; numIndex &lt; <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				numBuf[numIndex++] = ch;</span><br><span class="line">				ch = afterExp[k++];</span><br><span class="line">			&#125;</span><br><span class="line">			numBuf[numIndex] = <span class="number">0</span>;</span><br><span class="line">			<span class="type">double</span> num = atoi(numBuf);</span><br><span class="line">			push(&amp;<span class="built_in">stack</span>, num);</span><br><span class="line"> </span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//是符号或者空格</span></span><br><span class="line">		<span class="keyword">if</span> (ch&lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			numIndex = <span class="number">0</span>;<span class="comment">//进入这个if 数字肯定不连续了，下标重置为0</span></span><br><span class="line">			<span class="comment">// 是空格</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&#x27; &#x27;</span> == ch)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">double</span> c = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">switch</span> (ch)</span><br><span class="line">				&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b + a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>,c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b - a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b * a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">					pop(&amp;<span class="built_in">stack</span>, &amp;b);</span><br><span class="line">					c = b / a;</span><br><span class="line">					push(&amp;<span class="built_in">stack</span>, c);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="comment">//throw &quot;后缀表达式错误&quot;;</span></span><br><span class="line">					<span class="comment">//printf(&quot;后缀表达式错误\n&quot;);</span></span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		afterExp++;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算完毕 将计算结果从栈中弹出</span></span><br><span class="line">	<span class="keyword">if</span> (IsEmptyStack(&amp;<span class="built_in">stack</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//throw &quot;后缀表达式错误&quot;;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;后缀表达式错误\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pop(&amp;<span class="built_in">stack</span>, &amp;a);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;请输入中缀表达式(#表示退出)：&quot;</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//中缀表达式</span></span><br><span class="line">		<span class="type">char</span>* midExp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*EXPRESS_MAX);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">memset</span>(midExp, <span class="number">0</span>, EXPRESS_MAX);</span><br><span class="line">		fgets(midExp, <span class="number">1024</span>, <span class="built_in">stdin</span>);<span class="comment">//midExp 包含换行符</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&#x27;#&#x27;</span> == midExp[<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SeqStack&lt;<span class="type">char</span>&gt; charStack;</span><br><span class="line">		<span class="comment">//后缀表达式</span></span><br><span class="line">		<span class="type">char</span>* afterExp = MidExpToAfterExp(midExp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;对应的后缀表达式：%s\n&quot;</span>, afterExp);</span><br><span class="line"> </span><br><span class="line">		<span class="type">double</span> result = GetResultAfterExp(afterExp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;表达式计算结  果：%.2f\n&quot;</span>, result);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="4中后缀表达式转换">4.中后缀表达式转换</span></h2><p><strong>以一个过程模拟一下：</strong>分号表示扫描到表达式当前的位置</p>
<p>初始<br>中缀：2*(3+4)-8/2<br>后缀：<br>运算符栈：{ }</p>
<p>第一步<br>中缀：2;*(3+4)-8/2<br>后缀：2<br>运算符栈：{ }</p>
<p>第二步<br>中缀：2*;(3+4)-8/2<br>后缀：2<br>运算符栈：{* }</p>
<p>第三步<br>中缀：2*(;3+4)-8/2<br>后缀：2<br>运算符栈：{*,( }</p>
<p>第四步<br>中缀：2*(3;+4)-8/2<br>后缀：23<br>运算符栈：{*,( }</p>
<p>第五步<br>中缀：2*(3+;4)-8/2<br>后缀：23<br>运算符栈：{*,(,+}</p>
<p>第六步<br>中缀：2*(3+4;)-8/2<br>后缀：234<br>运算符栈：{*,(,+ }</p>
<p>第七步<br>中缀：2*(3+4);-8/2<br>后缀：234+<br>运算符栈：{* }</p>
<p>第八步<br>中缀：2*(3+4)-;8/2<br>后缀：234+*<br>运算符栈：{- }</p>
<p>第九步<br>中缀：2*(3+4)-8;/2<br>后缀：234+*8<br>运算符栈：{- }</p>
<p>第十步<br>中缀：2*(3+4)-8/;2<br>后缀：234+*8<br>运算符栈：{-,/ }</p>
<p>第十一步<br>中缀：2*(3+4)-8/2;<br>后缀：234+*82<br>运算符栈：{-,/ }</p>
<p>第十二步<br>中缀：2*(3+4)-8/2;<br>后缀：234+*82/<br>运算符栈：{- }</p>
<p>第十三步<br>中缀：2*(3+4)-8/2;<br>后缀：234+*82/-<br>运算符栈：{ }<br>结束</p>
<p><strong>实现过程的文字描述：</strong></p>
<p>中缀表达式转换为后缀表达式的过程<br>1 后缀表达式清空，运算符栈清空。<br>2 扫描表达式，每获取一个单词w，分五种情况处理：<br>(1) w为操作数：则w加入后缀表达式尾部<br>(2) 运算符栈空或w为“(”：w进运算符栈<br>(3) w为“)”：<br>   (3.1) 直到运算符栈顶为“(”，反复出栈且将出栈运算符加入后缀表达式尾部；     (3.2) 然后将“(”出栈<br>(4) w为“*”或“/”：<br>   (4.1) 若运算符栈顶为“*”或“/”，则出栈且将出栈运算符加入后缀表达式尾部;    (4.2) w进运算符栈<br>(5) w为“＋”“－”：<br>   (5.1) 直到运算符栈顶为“(”或空，反复出栈且将出栈运算符加入后缀表达式尾部;  (5.2) w进运算符栈<br>3 直到运算符栈空，反复出栈且将出栈运算符加入后缀表达式尾部</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2><span id="5补充错误后缀表达式的判断及处理">5.补充——错误后缀表达式的判断及处理</span></h2><p>判断表达式错误与否的主要方法：</p>
<ol>
<li>运算结束后<strong>运算符栈</strong>是否<strong>为空</strong>，<strong>数栈</strong>是否<strong>只有一个元素</strong></li>
<li>扫描到右括号时弹栈直到弹出左括号。</li>
</ol>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>银行排队-优先级队列</title>
    <url>/2024/10/15/%E9%93%B6%E8%A1%8C%E6%8E%92%E9%98%9F-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>数据结构与算法大作业1：模拟银行</p>
<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#介绍"><strong>介绍：</strong></a><ul>
<li><a href="#背景介绍"><strong>背景介绍：</strong></a></li>
<li><a href="#变量说明"><strong>变量说明：</strong></a></li>
<li><a href="#模拟过程说明"><strong>模拟过程说明：</strong></a></li>
</ul>
</li>
<li><a href="#程序说明"><strong>程序说明：</strong></a><ul>
<li><a href="#基础程序"><strong>基础程序：</strong></a></li>
<li><a href="#题目"><strong>题目</strong></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h2><span id="介绍"><strong>介绍：</strong></span></h2><h3><span id="背景介绍"><strong>背景介绍：</strong></span></h3><p>队列在计算机中的应用十分广泛，例如操作系统中的作业管理、进程调度、I/O请求处理等要用到队 列，排序算法中的基数排序，图的宽度优先遍历、缓冲区的循环使用等都用到队列，实时程序要处理一 些随机到达的离散事件也要用到队列。 下面介绍的事件驱动模拟是队列应用的典型例子之一。 </p>
<p>我们利用程序来模拟研究银行中客户到达（Arrival）和离开（Departure）的情况。我们把客户到达 和离开银行这两个时刻发生的事情称为“事件”（Event），则整个模拟程序将按事件发生的先后顺序进行 处理，这种模拟称为事件驱动模拟。 假设在一个不少于两个（n≥2）出纳窗口的银行中，每个出纳窗口在某一时刻只能接待一位客户，在客 户较多时需在每个窗口顺序排队。对于刚进人银行的客户，如果某个窗口正空闲，客户可立即上前办理 业务；否则，他会根据队伍人数的多少和队伍前进的快慢来决定选择窗口。程序模拟的结果要得出每位 客户的平均等待时间和每位出纳员的忙度，以此来衡量服务的效率。</p>
<h3><span id="变量说明"><strong>变量说明：</strong></span></h3><p>模拟程序要处理的数据有两类：一类是客户数据；另一类是出纳员数据。有关客户的情况体现在事件 中。</p>
<p>事件描述应包括的数据如下。 (1) time: 事件发生的时间(客户到达/离开的时刻，以分钟为单位，从模拟开始运行起计算)。 (2) etype: 事件类型(到达/离开)。 (3) customerID: 客户编号。 (4) tellerID: 客户选择服务的窗口编号。 (5) waittime: 客户必须等待的时间。 (6) servicetime: 客户需要的服务时间。 对于一个到达事件来说，必须有time、etype和customerID这3项数据，后3项数在到达事件中不需 要。对于离开事件来说，这6项数据都是必需的。 </p>
<p>服务效率与每个窗口的出纳员有关，出纳员数据如下。 (1) finishService: 窗口空闲时刻预告(即窗口当前的客户队伍什么时候可服务完毕) (2) totalCustomerCount: 该出纳员服务过的客户总数。 (3) totalCustomerWait: 该窗口客户总的等待时间。 (4) totalService: 该出纳员总的服务时间。 出纳员数据可用一个结构来描述，多个出纳员的数据组成一个结构数组。</p>
<h3><span id="模拟过程说明"><strong>模拟过程说明：</strong></span></h3><p>用随机数发生器产生一个时间作为下一个客户的到达时间，则可生成下一个客户的到达事件。如果产 生的时间超过了银行的下班时间，则不生成下一个客户到达事件。所有的客户到达事件和客户离开事件 按事件生成的先后顺序进入队列。这个队列的队列元素是事件，称为事件队列。 这个队列的入队操作与一般队列一样在队尾插入，但出队操作却不是从队头删除，而是从队列中选取 事件发生时间最早，即time值最小的队列元素删除，这种队列是优先级队列，在这里 time就是优先级。 如果两个队列元素的优先级相同则删除时按它们在队列中的先后顺序进行。 首先介绍事件是如何驱动模拟的。模拟从银行上班时开始，设置一些系统初始条件之后，就给出第一 个事件firstEvent，将这个事件加入事件优先队列中，该事件是事件队列初态中的唯一队列元素。其数据 成员是0、Arrival、1、0、0、0，分别对应time、etype、 customerID、tellerID、waittime、 servicetime，即表示客户1在0时刻到达。后面3个数据对于到达事件来说是不用的，这里暂且置为0。 对于每个客户到达事件，模拟程序将自动生成该客户的离开事件和下一个客户的到达事件。首先访问 出纳员数据finishService，就可知当前排在哪个窗口(tellerID)可以最先获得服务；用窗口空闲时刻预告  finishService 减去客户到达时刻time，就可得到客户的等待时间 wailtime；用随机数发生器可产生该客 户需要服务的时间servicetime；finishService加上servicetime 就是客户的离开时刻。如此就可生成该客 户的离开事件。 在生成离开事件之前，还要对选中窗口的出纳员数据做相应的更新。窗口空闲时刻预告finishService 应做如下修改：如果窗口空闲时刻预告 finishService为0，表示现在无客户，当前到达的事件立即可获得 服务，应把该窗口空闲时刻预告置为当前客户的到达时刻time，这时，离开事件中的客户等待时间 waittime为0；否则，窗口空闲时刻预告应为 finishService 与客户需要的服务时间 servicetime之和（即 该客户的离开时间）。该窗口接待客户的总数、客户总等待时间和总的服务时间都要对应该客户的信息 进行相应地增加。 模拟程序从事件队列中用删除操作取一个客户事件。如果是到达事件，则生成一个该客户离开事件和 一个下一客户到达事件(如果下一客户到达时间超过银行下班时间，则不生成下一客户到达事件)，并将这 两个事件入队。如果是离开事件，则根据离开事件的数据对该窗口空闲时刻预告做如下修改：如果该窗 口再没有其他等待服务的客户，则 finishService 置为0，一旦事件队列为空，则模拟结束。尽管客户到 达时间不能超过银行的下班时间，但客户的离开时间可能在银行下班时间之后，所以模拟结束时可能超 出原定的模拟时间长度。模拟结束时将输出模拟的结果数据。</p>
<h2><span id="程序说明"><strong>程序说明：</strong></span></h2><h3><span id="基础程序"><strong>基础程序：</strong></span></h3><p>程序一共有3个头文件与1个源文件，以下为代码展示</p>
<h4><span id="simh"><strong>sim.h</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下均为 sim.h 内容 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SIMULATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIMULATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;event.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> Event DataType;  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;apqueue.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 出纳窗口信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tellerStats</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> finishService;     <span class="comment">/* 空闲时间预告 */</span></span><br><span class="line">    <span class="type">int</span> totalCustomerCount; <span class="comment">/* 服务过的客户总数 */</span>    <span class="type">int</span> totalCustomerWait; <span class="comment">/* 客户总的等待时间 */</span></span><br><span class="line">    <span class="type">int</span> totalService;       <span class="comment">/* 总的服务时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tellerStats</span> <span class="title">TellerStats</span>;</span></span><br><span class="line"><span class="comment">/* 模拟结构数据 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simulation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> simulationLength;       <span class="comment">/* 模拟时间长度 */</span></span><br><span class="line">    <span class="type">int</span> numTellers;             <span class="comment">/* 出纳窗口数 */</span></span><br><span class="line">    <span class="type">int</span> nextCustomer;           <span class="comment">/* 下一个客户编码 */</span></span><br><span class="line">    <span class="type">int</span> arrivalLow, arrivalHigh; <span class="comment">/* 下一个客户到达的时间区间 */</span></span><br><span class="line">    <span class="type">int</span> serviceLow, serviceHigh; <span class="comment">/* 客户需要服务的时间区间 */</span></span><br><span class="line">    TellerStats tstat[<span class="number">11</span>];       <span class="comment">/* 出纳窗口信息 */</span></span><br><span class="line">    PQueue pq;                   <span class="comment">/* 优先级队列 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">simulation</span> <span class="title">Simulation</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSimulation</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 事件驱动模拟的初始化 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextArrivalTime</span><span class="params">(Simulation* s)</span>;     <span class="comment">/* 计算下一客户到达时间，随机生成 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_ServiceTime</span><span class="params">(Simulation*)</span>;       <span class="comment">/* 计算客户服务时间，随机生成 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAvailableTeller</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 计算下一个可供服务的出纳窗口号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RunSimulation</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 运行事件模拟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintSimulationResults</span><span class="params">(Simulation* s)</span>; <span class="comment">/* 输出模拟结果 */</span></span><br><span class="line"><span class="comment">/* 事件驱动模拟的初始化 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSimulation</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    Event* firstevent = (Event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Event));</span><br><span class="line">    <span class="comment">/* 初始化出纳窗口信息，注意这里限制最多10个窗口，并且编号是从1开始的 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        s-&gt;tstat[i].finishService = <span class="number">0</span>;</span><br><span class="line">        s-&gt;tstat[i].totalService = <span class="number">0</span>;</span><br><span class="line">        s-&gt;tstat[i].totalCustomerWait = <span class="number">0</span>;</span><br><span class="line">        s-&gt;tstat[i].totalCustomerCount = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    s-&gt;nextCustomer = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 输入事件模拟相关数据 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the simulation time in minutes: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;simulationLength);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the number of bank tellers: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;numTellers); <span class="comment">/* 注意这里不能超过10个 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the range of arrival times in minutes: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;s-&gt;arrivalLow, &amp;s-&gt;arrivalHigh);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the range of service times in minutes: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d&quot;</span>, &amp;s-&gt;serviceLow, &amp;s-&gt;serviceHigh); </span><br><span class="line">    <span class="comment">/* 生成第一个到达事件并加入事件优先级队列 */</span></span><br><span class="line">    InitEvent(firstevent, <span class="number">0</span>, arrival, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    InitPQueue(&amp;(s-&gt;pq));</span><br><span class="line">    PQInsert(&amp;(s-&gt;pq), *firstevent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 计算下一客户到达时间，按照所给区间随机生成 */</span><span class="type">int</span> <span class="title function_">NextArrivalTime</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;arrivalLow + rand() % (s-&gt;arrivalHigh - s-&gt;arrivalLow + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 计算客户的服务时间，按照所给区间随机生成 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_ServiceTime</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;serviceLow + rand() % (s-&gt;serviceHigh - s-&gt;serviceLow + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 计算下一个可供服务的出纳窗口号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">NextAvailableTeller</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> minfinishindex = <span class="number">1</span>; <span class="comment">/* 初始化最快空闲窗口为第一个窗口 */</span></span><br><span class="line">    <span class="type">int</span> minfinish = s-&gt;tstat[<span class="number">1</span>].finishService; <span class="comment">/* 初始化最快空闲时间预告为第一个窗口的</span></span><br><span class="line"><span class="comment">空闲时间预告 */</span></span><br><span class="line">    <span class="type">int</span> num[<span class="number">1000</span>], m, i;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 遍历所有窗口，找到最小空闲时间预告以及对应的窗口编号，如果存在多个最小窗口则随机选择其中</span></span><br><span class="line"><span class="comment">一个 */</span></span><br><span class="line">    m = <span class="number">1</span>;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;tstat[i].finishService &lt; minfinish) &#123;</span><br><span class="line">            minfinish = s-&gt;tstat[i].finishService;</span><br><span class="line">            num[<span class="number">0</span>] = i;</span><br><span class="line">            m = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[i].finishService == minfinish)</span><br><span class="line">                num[m++] = i;</span><br><span class="line">       &#125; </span><br><span class="line">    minfinishindex = num[rand() % m];</span><br><span class="line">    <span class="keyword">return</span> minfinishindex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行事件驱动模拟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RunSimulation</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    Event* e = (Event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Event));</span><br><span class="line">    Event* newevent = (Event*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Event));</span><br><span class="line">    <span class="type">int</span> nexttime, tellerID, servicetime, waittime;</span><br><span class="line">    <span class="comment">/* 遍历事件优先级队列，直到队列为空 */</span></span><br><span class="line">    <span class="keyword">while</span> (!PQEmpty(&amp;(s-&gt;pq)))</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">/* 获得下一个事件的优先级，此处指的是时间产生时间time */</span></span><br><span class="line">        *e = PQDelete(&amp;(s-&gt;pq));</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;etype == arrival)&#123;</span><br><span class="line">            <span class="comment">/* 处理到达事件 */</span></span><br><span class="line">            nexttime = e-&gt;time + NextArrivalTime(s);</span><br><span class="line">            <span class="keyword">if</span> (nexttime &gt; s-&gt;simulationLength)</span><br><span class="line">                <span class="comment">/* 如果到达事件在下班时刻之后，则不处理到达事件 */</span>                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">/* 生成下一客户到达事件并加入事件优先级队列 */</span></span><br><span class="line">                s-&gt;nextCustomer++;</span><br><span class="line">                InitEvent(newevent, nexttime, arrival, s-&gt;nextCustomer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                PQInsert(&amp;(s-&gt;pq), *newevent);</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Time: %2d\tarrival of customer %d\n&quot;</span>, e-&gt;time, e-</span><br><span class="line">&gt;customerID);</span><br><span class="line">            <span class="comment">/* 生成到达事件的离开事件 */</span></span><br><span class="line">            servicetime = Get_ServiceTime(s);</span><br><span class="line">            <span class="comment">/* 计算可供服务的出纳窗口 */</span></span><br><span class="line">            tellerID = NextAvailableTeller(s);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 如果选定的出纳窗口是空闲的，则更新完成时间预告为当前到达事件时间，以便后续更新完</span></span><br><span class="line"><span class="comment">成时间 */</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[tellerID].finishService == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">                 s-&gt;tstat[tellerID].finishService = e-&gt;time;</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">/* 计算等待时间 */</span></span><br><span class="line">            waittime = s-&gt;tstat[tellerID].finishService - e-&gt;time;</span><br><span class="line">            <span class="comment">/* 按照当前到达事件信息修改选定出纳窗口信息 */</span></span><br><span class="line">            s-&gt;tstat[tellerID].totalCustomerWait += waittime;</span><br><span class="line">            s-&gt;tstat[tellerID].totalCustomerCount++;</span><br><span class="line">            s-&gt;tstat[tellerID].totalService += servicetime;</span><br><span class="line">            s-&gt;tstat[tellerID].finishService += servicetime;</span><br><span class="line">            <span class="comment">/* 将生成的离开事件加入优先级队列 */</span></span><br><span class="line">            InitEvent(newevent, s-&gt;tstat[tellerID].finishService,</span><br><span class="line">                departure, e-&gt;customerID, tellerID, waittime, servicetime);</span><br><span class="line">            PQInsert(&amp;(s-&gt;pq), *newevent);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">/* 处理离开事件 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Time: %2d\tdeparture of customer %d\n&quot;</span>, e-&gt;time, e-</span><br><span class="line">&gt;customerID);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\tTeller %d\tWait %d\tService %d\n&quot;</span>, e-&gt;tellerID, e-</span><br><span class="line">&gt;waittime, e-&gt;servicetime);</span><br><span class="line">            tellerID =e-&gt;tellerID;</span><br><span class="line">            <span class="comment">/* 如果窗口在处理离开事件后空闲，则修改该出纳窗口的空闲时间预告 */</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;time == s-&gt;tstat[tellerID].finishService)</span><br><span class="line">                s-&gt;tstat[tellerID].finishService = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/* 修改总的服务时间，注意可能受离开事件影响导致实际总的服务时间大于预定的服务时间 */</span></span><br><span class="line">    s-&gt;simulationLength = (e-&gt;time &lt;= s-&gt;simulationLength)</span><br><span class="line">        ? s-&gt;simulationLength : e-&gt;time;</span><br><span class="line">&#125;<span class="number">1.4</span> 模拟执行 </span><br><span class="line">下面代码是事件驱动的主程序。</span><br><span class="line"><span class="number">2.</span> 实验要求 </span><br><span class="line">基于课本P46给出的代码（如上所述），实现以下功能。</span><br><span class="line"><span class="comment">/* 输出模拟结果 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintSimulationResults</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cumCustomers = <span class="number">0</span>, cumWait = <span class="number">0</span>, i;</span><br><span class="line">    <span class="type">int</span> avgCustWait, tellerWorkPercent;</span><br><span class="line">    <span class="type">float</span> tellerWork;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        cumCustomers += s-&gt;tstat[i].totalCustomerCount; </span><br><span class="line">        cumWait += s-&gt;tstat[i].totalCustomerWait;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n******** Simulation Summary ********\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Simulation of %d minutes\n&quot;</span>, s-&gt;simulationLength);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tNo. of Customers: %d\n&quot;</span>, cumCustomers);   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tAverage Customer Wait: &quot;</span>);</span><br><span class="line">    avgCustWait = (<span class="type">int</span>)((<span class="type">float</span>)cumWait / cumCustomers + <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d minutes\n&quot;</span>, avgCustWait);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\tTeller #%d\tWorking &quot;</span>, i);</span><br><span class="line">        <span class="comment">/* 显示每个出纳窗口的服务时间占比 */</span></span><br><span class="line">        tellerWork = (<span class="type">float</span>)(s-&gt;tstat[i].totalService) / s-&gt;simulationLength;</span><br><span class="line">        tellerWorkPercent = (<span class="type">int</span>)(tellerWork * <span class="number">100.0</span> + <span class="number">0.5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tellerWorkPercent);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* SIMULATION */</span></span></span><br></pre></td></tr></table></figure>
<h4><span id="apqueueh"><strong>apqueue.h</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下为apqueue.h内容，定义优先级队列 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PRIORITYQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIORITYQUEUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 队列最大长度 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxPQSize 50</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pQueue</span>&#123;</span></span><br><span class="line"> <span class="comment">/* 优先级队列数组和计数器 */</span></span><br><span class="line"> <span class="type">int</span> count;</span><br><span class="line"> DataType pqlist[MaxPQSize]; <span class="comment">//Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pQueue</span> <span class="title">PQueue</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPQueue</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="comment">/* 优先级队列修改操作 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PQInsert</span><span class="params">(PQueue* pq, DataType item)</span>;</span><br><span class="line">DataType <span class="title function_">PQDelete</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearPQ</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="comment">/* 优先级队列检测函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQEmpty</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">PQFull</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">PQLength</span><span class="params">(PQueue* pq)</span>;</span><br><span class="line"><span class="comment">/* 初始化优先级队列计数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPQueue</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> pq-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将元素插入优先级队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PQInsert</span><span class="params">(PQueue* pq, DataType item)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* 如果优先级队列的计数器达到最大限制，则终止程序 */</span></span><br><span class="line"> <span class="keyword">if</span> (pq-&gt;count == MaxPQSize)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Priority queue overflow!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将元素放在队列的后面并递增计数 */</span></span><br><span class="line"> pq-&gt;pqlist[pq-&gt;count] = item;</span><br><span class="line"> pq-&gt;count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 从优先级队列中删除一个元素并返回其值 */</span></span><br><span class="line">DataType <span class="title function_">PQDelete</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> DataType min;</span><br><span class="line"> <span class="type">int</span> i, minindex = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="comment">/* 在优先级队列中查找最小值及其索引 */</span></span><br><span class="line"> min = pq-&gt;pqlist[<span class="number">0</span>];   <span class="comment">/* 假设pqlist[0]是最小值 */</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line"> <span class="keyword">if</span> (CompareEvent(&amp;pq-&gt;pqlist[i], &amp;min))</span><br><span class="line"> &#123;</span><br><span class="line"> min = pq-&gt;pqlist[i];</span><br><span class="line"> minindex = i;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 将第二小元素移动到minindex并递减计数 */</span></span><br><span class="line"> pq-&gt;pqlist[minindex] = pq-&gt;pqlist[pq-&gt;count - <span class="number">1</span>]; </span><br><span class="line"> pq-&gt;count--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* qlist为空，终止程序 */</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Deleting from an empty priority queue!\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* 返回最小值 */</span></span><br><span class="line"> <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 返回优先级队列元素个数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQLength</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> pq-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试优先级队列是否为空 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQEmpty</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> pq-&gt;count == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 测试优先级队列是否已满 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PQFull</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> pq-&gt;count == MaxPQSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 通过将计数重置为0来清除优先级队列 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearPQ</span><span class="params">(PQueue* pq)</span></span><br><span class="line">&#123;</span><br><span class="line"> pq-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4><span id="eventh"><strong>event.h</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下均为 event.h 内容 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">eventType</span> &#123;</span> arrival, departure &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">eventType</span> <span class="title">EventType</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">isVip</span> &#123;</span> notVip, Vip &#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">isVip</span> <span class="title">IsVip</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> time;</span><br><span class="line">	EventType etype;</span><br><span class="line">	<span class="type">int</span> customerID;</span><br><span class="line">	<span class="type">int</span> tellerID;</span><br><span class="line">	<span class="type">int</span> waittime;</span><br><span class="line">	<span class="type">int</span> servicetime;</span><br><span class="line">	IsVip id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">Event</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 事件初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitEvent</span><span class="params">(Event* e, <span class="type">int</span> t, EventType et, <span class="type">int</span> cn, <span class="type">int</span> tn, <span class="type">int</span> wt, <span class="type">int</span> st, IsVip iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	e-&gt;time = t;</span><br><span class="line">	e-&gt;etype = et;</span><br><span class="line">	e-&gt;customerID = cn;</span><br><span class="line">	e-&gt;tellerID = tn;</span><br><span class="line">	e-&gt;waittime = wt;</span><br><span class="line">	e-&gt;servicetime = st;</span><br><span class="line">	e-&gt;id = iv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件时间为事件优先级队列的优先级，如果事件时间相等则优先执行离开事件 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CompareEvent</span><span class="params">(Event* e1, Event* e2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (e1-&gt;time &lt; e2-&gt;time ||</span><br><span class="line">		(e1-&gt;time == e2-&gt;time &amp;&amp; e1-&gt;etype == departure))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// e1出队</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (e1-&gt;time &gt; e2-&gt;time ||</span><br><span class="line">		(e1-&gt;time == e2-&gt;time &amp;&amp; e2-&gt;etype == departure))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// e2出队</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="eventc"><strong>event.c</strong></span></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下均为 event.c 内容 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sim.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 生命模拟结构的存储空间 */</span></span><br><span class="line">    Simulation* S = (Simulation*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Simulation));</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  <span class="comment">/* 设置随机数种子 */</span></span><br><span class="line">    InitSimulation(S);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 运行事件驱动模拟 */</span></span><br><span class="line">    RunSimulation(S);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出模拟结果 */</span></span><br><span class="line">    PrintSimulationResults(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="题目"><strong>题目</strong></span></h3><p>在原有代码基础上添加VIP窗口功能，VIP窗口的出纳员只服务VIP用户，当VIP用户到达后可以在本窗口 按照到达先后顺序等待。</p>
<p><strong>第一题约定</strong>  约定1号出纳员所在的1号窗口为VIP窗口，且银行中只有一个VIP窗口。 约定普通用户只能在普通窗口排队等候，其选择窗口的优先级为：空普通窗口&gt;非空普通窗口。 约定用户排队过程中选定窗口后就会一直在该队列中等待，不会更换排队队伍。 约定用户之间无法感知对方是处理何种业务，不知道其业务所需的具体时间和剩余时间。 约定模拟时间外不产生用户到达事件，但是银行将会处理完所有用户到达事件。</p>
<h4><span id="11"><strong>1.1</strong></span></h4><p><strong>题目：</strong> 约定VIP用户可以在普通窗口和VIP窗口排队等候，其选择窗口的优先级为：空VIP窗口&gt;空普通窗口&gt;非空 VIP窗口&gt;非空普通窗口。</p>
<p><strong>实现思路：</strong>原先代码已经实现了一个纯普通用户排队的代码，这题不涉及VIP用户的插队，所以只添加VIP与notVIP变量，再在原先基础上添加规定VIP用户窗口选择的函数就行，建议直接在NextAvailableTeller (Simulation* s) 上修改</p>
<h4><span id="12"><strong>1.2</strong></span></h4><p><strong>题目：</strong>约定VIP用户可以在VIP窗口排队等候，或者在普通窗口队列中插队（即排到普通窗口队列最前面）。 约定插队的VIP用户在普通窗口中按照到达顺序先后进行排队。 约定VIP用户选择窗口的优先级为：空VIP窗口&gt;空普通窗口&gt;插队到普通窗口队列。</p>
<p>第二问<strong>实现思路：</strong>参考NextAvailableTeller（）函数实现普通用户窗口选择的方法（通过比较窗口变量tstat的finishService变量并取最小值来实现），给tstat添加变量vipFinishService，它的值是新的VIP客户到这个窗口需要等待的时间（分析可知，它的值仅与当前正在服务的用户完成服务所需时间与排队中的VIP用户所需服务时间有关，与finishService变量不同的是当队列新加入普通用户（并且这个用户在排队中），finishService需要增加，而vipFinishService不需要），所以假设已经实现了这个变量，先把VIP用户窗口选择函数敲出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim.h</span></span><br><span class="line"><span class="comment">/* 计算下一个可供服务的出纳窗口号 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">VipNextAvailableTeller</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minfinishindex = <span class="number">1</span>;						<span class="comment">/* 初始化最快空闲窗口为第一个窗口(vip专用窗口为1) */</span></span><br><span class="line">    <span class="type">int</span> minfinish = s-&gt;tstat[<span class="number">1</span>].vipFinishService;	<span class="comment">/* 初始化最快空闲时间预告为第一个窗口的空闲时间预告 */</span></span><br><span class="line">    <span class="type">int</span> num[<span class="number">1000</span>], m, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历所有窗口，找到最小空闲时间预告以及对应的窗口编号，如果存在多个最小窗口则随机选择其中一个 */</span></span><br><span class="line">    m = <span class="number">1</span>;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;tstat[<span class="number">1</span>].vipFinishService == <span class="number">0</span>)<span class="comment">//检查VIP窗口是否为空，若空则直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">sim.h	<span class="comment">//如果VIP窗口不为空，则遍历寻找所有窗口中最快的</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s-&gt;numTellers; i++)</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;tstat[i].vipFinishService &lt; minfinish) &#123;</span><br><span class="line">            minfinish = s-&gt;tstat[i].vipFinishService;</span><br><span class="line">            num[<span class="number">0</span>] = i;</span><br><span class="line">            m = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[i].vipFinishService == minfinish)</span><br><span class="line">                num[m++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;tstat[<span class="number">1</span>].vipFinishService == minfinish)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    minfinishindex = num[rand() % m];</span><br><span class="line">    <span class="keyword">return</span> minfinishindex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再就是vipFinishService这个变量的更新，这点就参考finishService的操作，观察代码，finishService只在RunSimulation中改变，就从这里改（不用完全明白为什么，利用finishService简化思路）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim.h</span></span><br><span class="line"><span class="comment">/* 运行事件驱动模拟 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RunSimulation</span><span class="params">(Simulation* s)</span></span><br><span class="line">&#123;</span><br><span class="line">			......</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s-&gt;tstat[tellerID].finishService == <span class="number">0</span>)</span><br><span class="line">            &#123; </span><br><span class="line">                s-&gt;tstat[tellerID].finishService = e-&gt;time;</span><br><span class="line">                s-&gt;tstat[tellerID].vipFinishService = e-&gt;time;</span><br><span class="line">                <span class="keyword">if</span>(newevent-&gt;id==notVip)		<span class="comment">//防止特殊情况：有一个普通用户正在服务</span></span><br><span class="line">                    s-&gt;tstat[tellerID].vipFinishService += servicetime;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 计算等待时间 */</span></span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//e-&gt;time就是新客户的到达时间，新客户的到达事件是newevent，e是刚刚出队列的事件</span></span><br><span class="line">            <span class="keyword">if</span> (newevent-&gt;id == notVip)</span><br><span class="line">                waittime = s-&gt;tstat[tellerID].finishService - e-&gt;time;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                waittime = s-&gt;tstat[tellerID].vipFinishService - e-&gt;time;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 按照当前到达事件信息修改选定出纳窗口信息 */</span></span><br><span class="line">    </span><br><span class="line">            s-&gt;tstat[tellerID].finishService += servicetime;</span><br><span class="line">            <span class="keyword">if</span>(newevent-&gt;id==Vip)<span class="comment">//vip才加</span></span><br><span class="line">                s-&gt;tstat[tellerID].vipFinishService += servicetime;</span><br><span class="line">            <span class="comment">/* 将生成的离开事件加入优先级队列 */</span></span><br><span class="line">            <span class="keyword">if</span>(newevent-&gt;id==notVip)</span><br><span class="line">                InitEvent(newevent, s-&gt;tstat[tellerID].finishService,</span><br><span class="line">                    departure, e-&gt;customerID, tellerID, waittime, servicetime, newevent-&gt;id);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                InitEvent(newevent, s-&gt;tstat[tellerID].vipFinishService,</span><br><span class="line">                    departure, e-&gt;customerID, tellerID, waittime, servicetime, newevent-&gt;id);</span><br><span class="line">                PQInsertVip(&amp;(s-&gt;pq), tellerID, servicetime, nexttime);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PQInsert(&amp;(s-&gt;pq), *newevent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 处理离开事件 */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">            tellerID = e-&gt;tellerID;</span><br><span class="line">            <span class="comment">/* 如果窗口在处理离开事件后空闲，则修改该出纳窗口的空闲时间预告 */</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;time == s-&gt;tstat[tellerID].finishService)</span><br><span class="line">            &#123;</span><br><span class="line">                s-&gt;tstat[tellerID].finishService = <span class="number">0</span>;</span><br><span class="line">                s-&gt;tstat[tellerID].vipFinishService = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是VIP插队之后的数据更新，构造PQInsertVip()，用来插入并更新队列数据，它的自变量有：VIP到达时间，VIP插入的窗口，VIP所需的服务时间servicetime，然后遍历整个队列，如果队列的元素与刚到达的VIP的服务窗口相同，并且是还未开始服务的普通用户，那么这个用户就会被VIP插队，直接结果是该用户的waittime增加VIP所需的服务时间（servicetime），该用户原定的离开时间增加servicetime，事实上只需要这些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apqueue.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PQInsertVip</span><span class="params">(PQueue* pq, <span class="type">int</span> index, <span class="type">int</span> serviceTime, <span class="type">int</span> VipArriveTime)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//在优先级队列中更新vip插入后的客户情况</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].tellerID == index &amp;&amp; pq-&gt;pqlist[i].id==notVip &amp;&amp; pq-&gt;pqlist[i].time-pq-&gt;pqlist[i].servicetime&gt;VipArriveTime</span><br><span class="line">				&amp;&amp; pq-&gt;pqlist[i].etype==departure)</span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;pqlist[i].waittime += serviceTime;</span><br><span class="line">				pq-&gt;pqlist[i].time += serviceTime;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="2"><strong>2</strong></span></h4><p><strong>题目</strong>：约定只有出纳员服务完当前用户后，才会重新计算所有排队的用户中的VIP用户的等待时间，如果等待时 间已到达最长等待时间，将优先服务等待时间长的VIP用户。 约定等待时间满的VIP顾客，可以更换柜台服务。即所有柜台出纳员会按照等待时间由长到短的顺序服务 所有队列中的VIP用户。（对于VIP用户而言，打破最初不能更换队伍的约定） 无VIP窗口情况下，银行规定，VIP用户等待时间不得超过X分钟，VIP用户与普通用户之间设置排队策 略。 请同学们按照如下提示修改代码，使得VIP用户最多等待waitHigh时间。注意：出纳员只需要照顾本队列 中的VIP用户。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sim.h</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the longest waitting time the customer can tolerate in minutes: &quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;s-&gt;waitHigh);</span><br></pre></td></tr></table></figure>
<p><strong>实现思路：</strong>针对题意，我们可以这样理解：无VIP窗口，VIP1在waittime不超过最大等待时间的情况下正常排队（不插队），但如果正常插入时会超时，就插队，但是要注意，如果窗口前面有VIP2，这个VIP1只能插入到VIP2的后面，如果VIP1仍然等待超时，可能需要二者一起插队，这样太麻烦了，所以我化简了这个过程，这会导致运行结果有一点错误，但思路大大化简。分析题目，我们可以得到三个条件：</p>
<ul>
<li>1.我们当且仅当一个窗口的上一个用户被服务完后，再检查是否有超时VIP需要插队，这种情况下<strong>只有一个位置</strong>可以插队，插队优先级：全局中实际等待时间超时的VIP&gt;当前窗口中预计等待时间超时的VIP</li>
<li>2.所有VIP用户的最大等待时间都相同，所以当全部窗口中来得最早的、还在排队中的VIP用户未到达最大等待时间，那么所有的VIP用户此时都未到达最大等待时间，从而也就不需要更换窗口插队，如果有VIP用户需要换窗口插队，那么只能时全部窗口中来得最早的、还在排队中的VIP用户（其他用户此时的等待时间都比这个用户少） ，所以我们实现跨窗口插队时，只考虑全部窗口中来得最早的、还在排队中的VIP用户</li>
<li>3.用户的实际等待时间超时，全局遍历选窗口插队，预计等待时间waittime超时，在当前窗口插队，且优先级：前者大于后者</li>
</ul>
<p>有了这三点过程，我们进行过程模拟说明下：当某窗口s某用户接受完服务并离开的时刻，先遍历全局，检查是否有实际等待时间超时的VIP用户vip1，如果有，让其插队到s（s窗口可是该用户最快接受服务），（不需要遍历s窗口的VIP用户，因为即使遍历出来也要等待vip1服务完才能插队，也不需要循环遍历，找出所有等待超时的VIP用户，因为即使有，当前也没有服务窗口）如果没有（按结论2，全局都没有），则遍历整个窗口，检查是否有预计等待时间waittime超时的VIP用户，有则插到窗口最前面否则按正常顺序进行，（这是理想情况，但实际上前面说了，难以实现，简化之后的版本仅检查该窗口来得最早的VIP），没有则按正常顺序进行。</p>
<p><strong>错误分析：</strong></p>
<p>如下表队列</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>出纳员</th>
<th>普通用户</th>
<th>普通用户</th>
<th>VIP1</th>
<th>VIP2</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>若VIP1的waittime不超时，而VIP2超时，这个代码不能将VIP1、VIP2都向前移使二者都不超时，只能在VIP1正在接受服务时才处理VIP2.</p>
<p><strong>代码修改：</strong>（代码模板为教辅源代码，但是需要1_2中用的PQInsertVip函数实现数据插入之后的更新）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//apqueue.h</span></span><br><span class="line"><span class="comment">//查找当前窗口中是否有waittime超时的VIP用户，有则让它插队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Change</span><span class="params">(PQueue* pq, <span class="type">int</span> tellerID,<span class="type">int</span> high,<span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> max = <span class="number">999</span>;</span><br><span class="line">	<span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].etype == departure &amp;&amp; pq-&gt;pqlist[i].id == Vip &amp;&amp; pq-&gt;pqlist[i].tellerID==tellerID)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime &lt; max) &#123;</span><br><span class="line">					max = pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime;</span><br><span class="line">					index = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(index &amp;&amp; pq-&gt;pqlist[index].waittime&gt;high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> arriveTime = pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].waittime - pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		PQInsertVip(pq, tellerID, pq-&gt;pqlist[index].servicetime, arriveTime);</span><br><span class="line">		pq-&gt;pqlist[index].time = time + pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		pq-&gt;pqlist[index].waittime = time - arriveTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///由于VIP的最大等待时间都相同，所以查找现在所有窗口中是否有</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allChange</span><span class="params">(PQueue* pq, <span class="type">int</span> ID, <span class="type">int</span> high, <span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> max = <span class="number">9999</span>;</span><br><span class="line">	<span class="keyword">if</span> (pq-&gt;count &gt; <span class="number">0</span>)<span class="comment">//在所有等待中的VIP顾客中找到最早到的VIP，判断其等待时间是否超限</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].etype == departure &amp;&amp; pq-&gt;pqlist[i].id == Vip)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime &lt; max) &#123;</span><br><span class="line">					max = pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].waittime - pq-&gt;pqlist[i].servicetime;</span><br><span class="line">					index = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> arrivetime = pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].waittime - pq-&gt;pqlist[index].servicetime;</span><br><span class="line">	<span class="keyword">if</span> (index &amp;&amp; time-arrivetime &gt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		k = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="type">int</span> address = pq-&gt;pqlist[index].tellerID;</span><br><span class="line">		<span class="type">int</span> arriveTime = pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].waittime - pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; pq-&gt;count; i++)</span><br><span class="line">			<span class="keyword">if</span> (pq-&gt;pqlist[i].etype == departure &amp;&amp; pq-&gt;pqlist[i].tellerID == address</span><br><span class="line">				&amp;&amp; pq-&gt;pqlist[i].time - pq-&gt;pqlist[i].servicetime &gt; pq-&gt;pqlist[index].time - pq-&gt;pqlist[index].servicetime)</span><br><span class="line">			&#123;</span><br><span class="line">				pq-&gt;pqlist[i].time -= pq-&gt;pqlist[index].servicetime;</span><br><span class="line">				pq-&gt;pqlist[i].waittime -= pq-&gt;pqlist[index].servicetime;</span><br><span class="line">			&#125;</span><br><span class="line">		PQInsertVip(pq, ID, pq-&gt;pqlist[index].servicetime, arriveTime);</span><br><span class="line">		pq-&gt;pqlist[index].time = time + pq-&gt;pqlist[index].servicetime;</span><br><span class="line">		pq-&gt;pqlist[index].waittime = time - arriveTime;</span><br><span class="line">		pq-&gt;pqlist[index].tellerID = ID;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//return k;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sim.h      </span></span><br><span class="line"><span class="comment">//上一个事件出队列之后进行如下操作</span></span><br><span class="line">			<span class="type">int</span> flag = allChange(&amp;(s-&gt;pq), e-&gt;tellerID, s-&gt;waitHigh, e-&gt;time);<span class="comment">/*扫描全部未进行的VIP，</span></span><br><span class="line"><span class="comment">            //是否有超时的如果有就先插队，实现一个更新函数，更新排在其前面的和</span></span><br><span class="line"><span class="comment">            //插队的，在此调用,如果插队了，后面的函数就不用调用了*/</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)</span><br><span class="line">                Change(&amp;(s-&gt;pq),e-&gt;tellerID,s-&gt;waitHigh,e-&gt;time);<span class="comment">//在这个窗口中找到来得最早的vip，判断是否等待超时</span></span><br><span class="line">            <span class="comment">//如果超时，移到最前面</span></span><br></pre></td></tr></table></figure>
<h4><span id="3"><strong>3</strong></span></h4><p> 综合考虑各类角色等待时间：被VIP插队的用户越多，普通用户越不满；VIP等待的时间越长，VIP越不 满；有人排队但有窗口闲置时，银行不满。</p>
<p>请通过实验数据说明如何设置排队机制可能是最优的。 建议：参考题目设置，逐步放开随机化的元素进行分析，可站在用户的角度或者银行的角度说明。</p>
<p><strong>设计思路：</strong>银行不设置VIP窗口，VIP可以查到队列最前面，如果前面也有VIP则按时间顺序排，event增加两个变量waittime0：记录普通用户开始排队时的预计等待时间，flag：标志变量，有0，1两种取值，初值为0，如果VIP用户插队之后，遍历所有离开事件，对所有普通用户，若其当前的等待时间大于等于2倍的waittime0，将其身份设为VIP，flag置为0。</p>
<p>解释一下：从用户的角度，一直被插队会不满，所以需要设置一个限度，超过这个限度后该用户不可再被插队，有三种方案：用户等待时间到达一定时间后不能再被插队；用户被多少人插队之后不可再被插队；用户在预计等待时间超过初始预计等待时间的几倍后不可再被插队。这几种方案中，由于用户初始预计等待时间差别极大，所以最后一种更适合。</p>
]]></content>
      <tags>
        <tag>数据结构与算法 大作业</tag>
      </tags>
  </entry>
  <entry>
    <title>排序2.md</title>
    <url>/2024/10/26/%E6%8E%92%E5%BA%8F2/</url>
    <content><![CDATA[<p>首先，对《排序1》中基于比较的排序算法，其平均时间复杂度最低只能到O(nlogn)，下面给出证明：对n个数（n1,n2,…..），可能的排序结果有n！种，其中对于n1与n2，n1在n2前面的排法有n！/2种，在n2后面的有n！/2种，而经过一次比较后n1与n2的位置关系就确定了，于是可能的排序结果变为n！/2种，也就是减少了一半，也就是说，每经过一次比较，可能的排序结果数变为原来的1/2，最终的目的是排序结果只有一种（已经排好序了），假设比较k次，我们有：</p>
<script type="math/tex; mode=display">
\frac{n!}{2^k}<=1\\
k>=log_2(n!)>=log_2(\sqrt{n}^n)\\
k>=\frac{n}{2}log_2n</script><p>也就是说基于比较的排序，平均时间复杂度最低只能到O(nlogn)，但是，还有种不基于比较的排序，及基数排序。这里来介绍一下这种排序方法：</p>
<p>考虑以下一组数：</p>
<p>23，12，3，6，88，34</p>
<p>将这些数按照个位数分到各组（有10个组，对应个位0~9，不考虑大小，按原数组中的顺序进组）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>—</td>
<td>—</td>
<td>12</td>
<td>23，3</td>
<td>34</td>
<td>—</td>
<td>6</td>
<td>—</td>
<td>88</td>
<td>—</td>
</tr>
</tbody>
</table>
</div>
<p>再串起来：</p>
<p>12，23，3，34，6，88</p>
<p>由于其中最大的数只有两位，所以再按十位来分到各组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>3，6</td>
<td>12</td>
<td>23</td>
<td>34</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>—</td>
<td>88</td>
<td>—</td>
</tr>
</tbody>
</table>
</div>
<p>再串起来：3，6，12，23，34，88。很显然这是排好序的，其中的原理比较简单，而且它的时间复杂度为O(n)，比比较排序快很多。</p>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forSort</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key[<span class="number">3</span>];				<span class="comment">//假设排序的数据有3位</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">forSort</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">forSort</span> ForSort;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(ForSort* pData,<span class="type">int</span> Clow,<span class="type">int</span> Chigh,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">	&#123;</span><br><span class="line">		ForSort* pHead;</span><br><span class="line">		ForSort* pTail;	</span><br><span class="line">	&#125;TempLink;</span><br><span class="line">	<span class="type">int</span> r = Chigh-Clow+<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	TempLink *tlink;</span><br><span class="line">	ForSort *p;</span><br><span class="line">	tlink = (TempLink*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TempLink)*r);</span><br><span class="line">	<span class="keyword">for</span>(i=d<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">//初始化r个分配队列</span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line">			tlink[j].pHead = tlink[j].pTail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//分配数据</span></span><br><span class="line">		<span class="keyword">for</span>(p=pData;p!=<span class="literal">NULL</span>;p=p-&gt;next)</span><br><span class="line">		&#123;</span><br><span class="line">			j = p-&gt;key[i]-Clow;</span><br><span class="line">			<span class="keyword">if</span>(tlink[j].pHead = <span class="literal">NULL</span>)</span><br><span class="line">				tlink[j].pHead = tlink[j].pTail = p;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				tlink[j].pTail-&gt;next = p;</span><br><span class="line">				tlink[j].pTail = p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//收集数据</span></span><br><span class="line">		j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(tlink[j].pHead==<span class="literal">NULL</span>)j++;</span><br><span class="line">		pData = tlink[j].pHead;</span><br><span class="line">		p = tlink[j].pTail;</span><br><span class="line">		<span class="keyword">for</span>(k=j+<span class="number">1</span>;k&lt;r;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(tlink[k].pHead!=<span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				p-&gt;next = tlink[k].pHead;</span><br><span class="line">				p = tlink[k].pTail;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(p=pData;p!=<span class="literal">NULL</span>;p=p-&gt;next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;d;i++)</span><br><span class="line">			cout &lt;&lt; p-&gt;key[i];</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(tlink);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种实现方式，是学校作业里要求的，比较难写，纯粹是为了麻烦搞的，花了我很长时间，所以这里我把代码也贴上来，感兴趣可以看看，也算是一种比较好的实现思路（来源：头歌）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNUM_KEY 8                	<span class="comment">//关键字项数的最大值 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX 10                        <span class="comment">//关键字基数，此时是十进制整数的基数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SPACE 10000 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> KeysType;					<span class="comment">//定义关键字类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> InfoType;					<span class="comment">//定义其它数据项的类型</span></span><br><span class="line"><span class="type">int</span> tkey =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123; </span><br><span class="line">	KeysType keys[MAXNUM_KEY];          <span class="comment">//关键字 </span></span><br><span class="line">	InfoType otheritems;               	<span class="comment">//其他数据项 </span></span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;SLCell;						    	<span class="comment">//静态链表的结点类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123; </span><br><span class="line">	SLCell r[MAX_SPACE];		        <span class="comment">//静态链表的可利用空间，r[0]为头结点 </span></span><br><span class="line">	<span class="type">int</span> keynum;				         	<span class="comment">//记录的当前关键字个数 </span></span><br><span class="line">	<span class="type">int</span> recnum;					     	<span class="comment">//静态链表的当前长度 </span></span><br><span class="line">&#125;SLList;							    <span class="comment">//静态链表类型 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ArrType[RADIX];	          	<span class="comment">//指针数组类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">itoa1</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span>*c,<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = (<span class="type">int</span>)(<span class="built_in">ceil</span>(<span class="built_in">log10</span>(n)));</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">pow</span>(l,k<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(num*l==n)</span><br><span class="line">		num*=l;	</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">0</span>)num++;</span><br><span class="line">	<span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">		c[index++] = n/num+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		n = n%num;</span><br><span class="line">		num/=l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(SLList L)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SLList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//初始化静态链表L（把数组D中的数据存于L中）</span></span><br><span class="line">	<span class="type">char</span> c[MAXNUM_KEY],c1[MAXNUM_KEY];</span><br><span class="line">    <span class="type">int</span> i,j,n,max;						<span class="comment">//max为关键字的最大值 </span></span><br><span class="line">    max=<span class="number">-10000</span>;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n&gt;MAX_SPACE)</span><br><span class="line">    &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;您输入的个数超过上限，请重新输入，不超过&quot;</span>&lt;&lt;MAX_SPACE&lt;&lt;<span class="string">&quot;个。\n&quot;</span>;</span><br><span class="line">	    cin&gt;&gt;n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *D=<span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">	    cin&gt;&gt;D[i];</span><br><span class="line">	    <span class="keyword">if</span>(max&lt;D[i])</span><br><span class="line">			max=D[i];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    (*L).keynum=(<span class="type">int</span>)(<span class="built_in">ceil</span>(<span class="built_in">log10</span>(max)));</span><br><span class="line">    <span class="keyword">if</span>(max==<span class="built_in">pow</span>(<span class="number">10</span>,(*L).keynum))&#123;</span><br><span class="line">    	(*L).keynum++;</span><br><span class="line">	&#125;</span><br><span class="line">    (*L).recnum=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;(*L).keynum;j++) c[j] = <span class="string">&#x27;\0&#x27;</span>;	<span class="comment">//必不可少！</span></span><br><span class="line">        <span class="built_in">itoa1</span>(D[i<span class="number">-1</span>],c,<span class="number">10</span>);					<span class="comment">//将10进制整型转化为字符型,存入c //小bug：1，10实际位数比这个得数要小！</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">for</span>(j=<span class="built_in">strlen</span>(c);j&lt;(*L).keynum;j++)  <span class="comment">//若c的长度&lt;max的位数,在c前补&#x27;0&#x27; </span></span><br><span class="line">		&#123;</span><br><span class="line">		   <span class="built_in">strcpy</span>(c1,<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		   <span class="built_in">strcat</span>(c1,c);</span><br><span class="line">		   <span class="built_in">strcpy</span>(c,c1);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;(*L).keynum;j++)</span><br><span class="line">			(*L).r[i].keys[j]=c[(*L).keynum<span class="number">-1</span>-j];<span class="comment">//倒过来//这样改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ord</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//返回k的映射(个位整数)</span></span><br><span class="line">	<span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Distribute</span><span class="params">(SLCell *r,<span class="type">int</span> i,ArrType &amp;f,ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//静态链表L的r域中记录已按（keys[0], …, keys[i-1]）有序 </span></span><br><span class="line">	<span class="comment">//本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 </span></span><br><span class="line">	<span class="comment">//f[0..RADIX-1]和e[0..RADIX-1]分别指向各子表中第一个和最后一个记录</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//=======begin=======</span></span><br><span class="line">    <span class="type">int</span> j,k;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(f[j]==<span class="number">-1</span>)j++;</span><br><span class="line">	SLCell temp = r[f[j]];</span><br><span class="line">	j=f[j];</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;RADIX;k++)&#123;</span><br><span class="line">		f[k] = <span class="number">-1</span>;</span><br><span class="line">		e[k] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[<span class="built_in">ord</span>(temp.keys[i])]==<span class="number">-1</span>)&#123;</span><br><span class="line">			f[<span class="built_in">ord</span>(temp.keys[i])]=j;</span><br><span class="line">			e[<span class="built_in">ord</span>(temp.keys[i])]=j;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			r[e[<span class="built_in">ord</span>(temp.keys[i])]].next = j;</span><br><span class="line">			e[<span class="built_in">ord</span>(temp.keys[i])]=j;</span><br><span class="line">		&#125;</span><br><span class="line">		j = temp.next;</span><br><span class="line">		temp = r[temp.next];</span><br><span class="line">	&#125;    </span><br><span class="line">    <span class="comment">//========end========</span></span><br><span class="line">&#125;<span class="comment">//Distribute </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">succ</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//求后继函数</span></span><br><span class="line">    <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Collect</span> <span class="params">(SLCell *r,<span class="type">int</span> i,ArrType &amp;f,ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//本算法按keys[i]自小至大地将f[0..RADIX-1]所指各子表依次链接成一个链表 </span></span><br><span class="line">    <span class="comment">//e[0..RADIX-1]为各子表的尾指针</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//=======begin=======</span></span><br><span class="line">    <span class="type">int</span> j,k;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(f[j]==<span class="number">-1</span>&amp;&amp;j&lt;<span class="number">10</span>)j++;</span><br><span class="line">    <span class="keyword">for</span>(k=j;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(f[k]!=<span class="number">-1</span>)&#123;</span><br><span class="line">    		r[e[j]].next = f[k];</span><br><span class="line">    		j=k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r[e[j]].next=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//========end========</span></span><br><span class="line">&#125;<span class="comment">//Collect </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RadixSort</span><span class="params">(SLList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//L是采用静态链表表示的顺序表 </span></span><br><span class="line">    <span class="comment">//对L做基数排序，使得L成为按关键字自小到大的有序静态链表，L.r[0]为头结点</span></span><br><span class="line">    <span class="comment">//=======begin=======</span></span><br><span class="line">    <span class="comment">//先初始化    </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L.recnum;i++)&#123;</span><br><span class="line">		L.r[i].next = i+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L.r[L.recnum].next = <span class="number">-1</span>;<span class="comment">//把最后一个r[i].next设为-1</span></span><br><span class="line">	ArrType f,e;</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.keynum;i++)&#123;</span><br><span class="line">		<span class="built_in">Distribute</span>(L.r,i,f,e);</span><br><span class="line">		<span class="built_in">Collect</span>(L.r,i,f,e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将第一个交换，待实现</span></span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(f[j]==<span class="number">-1</span>)j++;</span><br><span class="line">	tkey = f[j];</span><br><span class="line">    <span class="comment">//========end========</span></span><br><span class="line">&#125; <span class="comment">// RadixSort</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(SLList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	<span class="comment">//按数组序号输出静态链表</span></span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.recnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">for</span>(j=L.keynum<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">			cout&lt;&lt;L.r[i].keys[j];</span><br><span class="line">	    cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(SLList L,<span class="type">int</span> adr[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//求得adr[1..L.length]，adr[i]为静态链表L的第i个最小记录的序号</span></span><br><span class="line">	adr[<span class="number">0</span>] = tkey;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,p=L.r[tkey].next,j;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">		adr[i++]=p;</span><br><span class="line">		p=L.r[p].next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Rearrange</span><span class="params">(SLList *L,<span class="type">int</span> adr[])</span><span class="comment">///怎么搞？？？</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="comment">//adr给出静态链表L的有序次序，即L.r[adr[j]]是第i小的记录。</span></span><br><span class="line">    <span class="comment">//本算法按adr重排L.r，使其有序。算法10.18(L的类型有变) </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//=======begin=======</span></span><br><span class="line">	<span class="type">char</span> sc[L-&gt;recnum+<span class="number">1</span>][L-&gt;keynum+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L-&gt;recnum;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;L-&gt;keynum;j++)</span><br><span class="line">			sc[i][j]=L-&gt;r[adr[i<span class="number">-1</span>]].keys[j];</span><br><span class="line">		sc[i][L-&gt;keynum] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=L-&gt;recnum;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;L-&gt;keynum;j++)</span><br><span class="line">			L-&gt;r[i].keys[j]=sc[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//========end========</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SLList l;</span><br><span class="line">	<span class="type">int</span> *adr;</span><br><span class="line">	<span class="built_in">InitList</span>(&amp;l);</span><br><span class="line">	<span class="built_in">RadixSort</span>(l);</span><br><span class="line">	adr=<span class="keyword">new</span> <span class="type">int</span>[l.recnum];</span><br><span class="line">	<span class="built_in">Sort</span>(l,adr);</span><br><span class="line">	<span class="built_in">Rearrange</span>(&amp;l,adr);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;排序后(重排记录):\n&quot;</span>;</span><br><span class="line">	<span class="built_in">print</span>(l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面介绍一种基于比较的排序——归并排序：</p>
<p>归并排序的主要思想是将大数组分为若干个小数组，进行几次排序，每次排序将两组相邻小数组按顺序合并，直到将所有小数组合并成一个大数组为止，这种方法比较适合并行，即使不并行，其时间复杂度也仅为O(nlogn)，挺快的。</p>
<p>下面就一个例子来讲其具体过程：</p>
<p>初始数组（分组后）:[28] [13] [72] [85] [39] [41] [6] [20]</p>
<p>第一次归并后:            [13 28] [72 85] [39 41] [6 20]</p>
<p>第二次归并后:            [13 28 72 85] [6 20 39 41]</p>
<p>第三次归并后:            [6 13 20 28 39 41 72 85] </p>
<p>下面给出代码（其中的TwoWayMerge函数比较有意思）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forSort</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> key[<span class="number">3</span>];				<span class="comment">//假设排序的数据有3位</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">forSort</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">forSort</span> ForSort;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ForSort A[],<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnePassMerge</span><span class="params">(ForSort Dst[],ForSort Src[],<span class="type">int</span> len,<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoWayMerge</span><span class="params">(ForSort Dst,ForSort Src,<span class="type">int</span> s,<span class="type">int</span> e1,<span class="type">int</span> e2)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(ForSort A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k;</span><br><span class="line">	ForSort* B = (ForSort*)<span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(ForSort));</span><br><span class="line">	</span><br><span class="line">	k=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">OnePassMerge</span>(B,A,k,n);</span><br><span class="line">		k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;=n)</span><br><span class="line">			<span class="built_in">memcpy</span>(A,B,n*<span class="built_in">sizeof</span>(ForSort));</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">OnePassMerge</span>(A,B,k,n);</span><br><span class="line">			k&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnePassMerge</span><span class="params">(ForSort Dst[],ForSort Src[],<span class="type">int</span> len,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>*len;i+=<span class="number">2</span>*len)</span><br><span class="line">		<span class="built_in">TwoWayMerge</span>(Dst,Src,i,i+len<span class="number">-1</span>,i+<span class="number">2</span>*len<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(i&lt;n-len)</span><br><span class="line">		<span class="built_in">TwoWayMerge</span>(Dst,Src,i,i+len<span class="number">-1</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;Dst[i],&amp;Src[i],(n-i)*<span class="built_in">sizeof</span>(ForSort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TwoWayMerge</span><span class="params">(ForSort Dst,ForSort Src,<span class="type">int</span> s,<span class="type">int</span> e1,<span class="type">int</span> e2)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s1,s2;</span><br><span class="line">	<span class="keyword">for</span>(s1=s,s2=e1+<span class="number">1</span>;s1&lt;=e1&amp;&amp;s2&lt;=e2;)&#123;</span><br><span class="line">		<span class="keyword">if</span>(Src[s1].key&lt;=Src[s2].key)</span><br><span class="line">			Dst[s++] = Src[s1++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			Dst[s++] = Src[s2++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s1&lt;=e1)</span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;Dst[s],&amp;Src[s1],(e1-s1+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ForSort));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">memcpy</span>(&amp;Dst[s],&amp;Src[s2],(e2-s2+<span class="number">1</span>)*<span class="built_in">sizeof</span>(ForSort));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>查找</title>
    <url>/2024/10/26/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#1-顺序查找">1 顺序查找</a></li>
<li><a href="#2-折半查找">2 折半查找</a></li>
<li><a href="#3-分块查找">3 分块查找</a></li>
<li><a href="#4-散列查找">4 散列查找</a><ul>
<li><a href="#41-散列函数">4.1 散列函数</a><ul>
<li><a href="#411-除留余数法">4.1.1 除留余数法</a></li>
<li><a href="#412-数字分析法">4.1.2 数字分析法</a></li>
<li><a href="#413-平方取中法">4.1.3 平方取中法</a></li>
<li><a href="#414-随机乘数法">4.1.4 随机乘数法</a></li>
<li><a href="#415-折叠法">4.1.5 折叠法</a></li>
<li><a href="#416-基数转换法">4.1.6 基数转换法</a></li>
</ul>
</li>
<li><a href="#42-处理冲突">4.2 处理冲突</a><ul>
<li><a href="#421开放地址法">4.2.1开放地址法</a></li>
<li><a href="#422-链表地址法">4.2.2 链表地址法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h1><span id="1-顺序查找">1 顺序查找</span></h1><p>顺序查找是一种最简单但效率低下的查找方法，时间复杂度为O(n)，但对数据要求少。（顺序存储、链式存储均可）</p>
<p>顺序查找时，将每个节点的数据与给定数据进行比较，直到找出相等数据或者找遍了每个节点。</p>
<h1><span id="2-折半查找">2 折半查找</span></h1><p>折半查找效率较高，时间复杂度为O(logn)，但对数据的要求也高——必须是顺序存储的有序表，这种方法不太适合在数据动态变化的链表中查找。</p>
<p>折半查找就不介绍了，原理是二分法。</p>
<h1><span id="3-分块查找">3 分块查找</span></h1><p>如果既要有较快的查找速度，又要满足元素动态变化的要求，可以采用分块查找算法。</p>
<p>分块查找将一个大的线性表划分成若干块(<strong>如何分块？</strong>)，块内不排序，块之间排序(假设非递减)。建立一个索引表，把每块中的最大关键码值作为索引表的关键码值，且非递减排序。</p>
<p>查找某结点时，先在索引表中顺序查找或者折半查找，找到该结点对应的块，然后在块内顺序查找。</p>
<p>如果索引表和块内数据都采用顺序查找，若要求平均查找速度最快，理想情况下需要将数据分成$\sqrt{n}$个块，每个块有$\sqrt{n}$个数据，平均时间复杂度为O($\sqrt{n}$)，比较快，而且只要求索引表有序，块内数据不必有序，实现也比较简单，但缺点是难以保证各块之间数据个数均匀，可能出现一个块包含几乎所有数据的情况 ，这时分块查找将退化为顺序查找。</p>
<p><img src="%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-26%20162308.png" alt></p>
<h1><span id="4-散列查找">4 散列查找</span></h1><p>散列查找的时间复杂度在理想情况下为O(1)，其关键是构建散列函数，讲数据与其位置形成一个映射，这样只需知道数据就能求得其位置，很快，但一般情况下会有冲突，即多个数据对应同一个位置（因为一般映射得出的位置大小一定如32位，128位等，但数据量可以是无限的，所以根据抽屉原理，必然会有冲突），所以我们需要真确的设置散列函数，以及考虑如何处理冲突。</p>
<p>这里介绍一些概念：</p>
<ul>
<li>散列函数经常是多对一的，导致冲突(碰撞)，具有相同散列值的关键码值称为同义词。</li>
<li>两个结点不能占据同一个位置，需要一种冲突解决策略。为了讨论冲突及其解决办法，引入负载因子α的概念。</li>
<li>α＝填入表中的结点数/散列表长度</li>
</ul>
<h2><span id="41-散列函数">4.1 散列函数</span></h2><p>设计散列函数需考虑：应该能够有效减少冲突；必须具有很高的执行效率。</p>
<p>以下是一些散列函数的设计方法。</p>
<h3><span id="411-除留余数法">4.1.1 除留余数法</span></h3><p>除留余数法：利用余数运算将整数型的关键码值映射到0～n-1的范围内。选择一个适当的正整数p，用p去除关键码值，所得余数作为该关键码的散列值。</p>
<p>除留余数法的关键是p的选取。一般取p为小于等于n的最大素数</p>
<ul>
<li>对于素数p, 0&lt;k&lt;p, 任意 0&lt;=i&lt;j&lt;p, k*i 与 k*j</li>
<li>不同余, 即不碰撞；例如p=11, k=10, i=3, j=9</li>
<li>对于非素数，k*i 与 k*j 可能同余；例如p=12</li>
</ul>
<h3><span id="412-数字分析法">4.1.2 数字分析法</span></h3><p>数字分析法：当关键码的位数很多时，可以通过对关键码的各位进行分析，丢掉分布不均匀的位，留下分布均匀的位作为散列值。</p>
<p>例： key hash(key) 取分布均匀的3位</p>
<ul>
<li>100<strong>3</strong>194<strong>26</strong> 326</li>
<li>000<strong>7</strong>183<strong>09</strong> 709</li>
<li>000<strong>6</strong>294<strong>43</strong> 643</li>
<li>100<strong>7</strong>586<strong>15</strong> 715</li>
<li>000<strong>9</strong>196<strong>97</strong> 997</li>
<li>000<strong>3</strong>103<strong>29</strong> 329</li>
</ul>
<p>上面的数据中前三位分布不均匀，所以从第四位开始取。</p>
<ul>
<li>只适合静态的关键码值集合。</li>
</ul>
<h3><span id="413-平方取中法">4.1.3 平方取中法</span></h3><p>平方取中法：计算关键码值的平方，从平方的中间位置取连续若干位，将这些位构成的数作为散列值。</p>
<p><img src="../imgs/%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-26%20172534-17299347611084.png" style="zoom: 67%;"></p>
<p>不取最前面或最后面的元素的原因是分布不均匀。</p>
<h3><span id="414-随机乘数法">4.1.4 随机乘数法</span></h3><p>随机乘数法：使用一个随机实数f(0≤f&lt;1)，f*key的小数部分与散列表长度n相乘，将乘积的整数部分作为key的散列值。</p>
<p><img src="../imgs/%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-26%20172829-17299349296617.png" style="zoom:67%;"></p>
<h3><span id="415-折叠法">4.1.5 折叠法</span></h3><p>折叠法：将关键码值分成若干段，其中至少有一段的长度等于散列表长度值的位数，把这些多段数相加，并舍弃可能产生的进位，所得整数作为散列值。<br>关键码值的位数比散列表长度值的位数多出很多时，可以采用折叠法。<br>例，关键码key=852422241，散列表长度为4000。</p>
<p><img src="../imgs/%E6%9F%A5%E6%89%BE/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-26%20172933-172993498680710.png" style="zoom:50%;"></p>
<h3><span id="416-基数转换法">4.1.6 基数转换法</span></h3><h2><span id="42-处理冲突">4.2 处理冲突</span></h2><h3><span id="421开放地址法">4.2.1开放地址法</span></h3><p>开放地址法：散列表的每个表项有一个表示该表项是否被占用的标志，当试图加入新的数据项到散列表中时，首先判断散列值指定的表项是否被占用，如果被占用，则依据一定的规则在表中寻找其它空闲的表项。</p>
<h4><span id="4211-线性探测法">4.2.1.1 线性探测法</span></h4><p>探测空闲表项的最简单的方法是线性探测法：当冲突发生时，顺序地探测下一个表项是否空闲。若Hash(key)=d，而第d表项已被占用，则依次探测d+1,d+2,…,n-1,0,1,…,d-1。</p>
<p>这会导致一个新问题：线性探测法解决冲突可能产生<strong>堆积</strong>。使用散列函数计算出散列值后，散列表的对应表项可能已经被<strong>非同义词</strong>的结点占用。</p>
<p>如何<strong>改善堆积</strong>？</p>
<h4><span id="4212-双散列函数探测法">4.2.1.2 双散列函数探测法</span></h4><p>可采用双散列函数探测法改善堆积现象：使用2个散列函数Hash1和Hash2，其中Hash1以关键码值为自变量，产生一个0～n-1之间的数。Hash1用来产生基本的散列值，当发生冲突时，利用Hash2计算探测序列。当Hash1(key)=d时发生冲突，则再计算k=Hash2(key) ，得到探测序列为(d+k)%n, (d+2*k)%n, (d+3*k)%n, …双散列函数可以使探测序列跳跃地分散到整个存储区域里，从而有助于减少“堆积”的产生.<br><strong>注意</strong>，不能随便删除散列表中的表项目，因为删除一个表项可能使得同义词序列断开。</p>
<h3><span id="422-链表地址法">4.2.2 链表地址法</span></h3><p>为散列表的每个表项建立一个单链表，用于链接同义词子表，每个表项需增加一个指针域。</p>
<h4><span id="4221-独立链表地址法">4.2.2.1 独立链表地址法</span></h4><p>在散列表的基本存储区域外开辟一个新的区域用于存储同义词子表。</p>
<p><strong>例</strong>，10个数据项，关键码分别为54,77,94,89,14,45,76,23,43,47，散列表长度为11，散列函数为除留余数法h(key)=key%11，散列结果如下：</p>
<p><img src="../imgs/%E6%9F%A5%E6%89%BE/image-20241026173819625-172993551168012.png" alt="image-20241026173819625" style="zoom: 50%;"></p>
<h4><span id="4222-公共链表地址法">4.2.2.2 公共链表地址法</span></h4><p>将同义词子表存储在散列表所在基本存储区域里。例如，在基本存储区域探测空闲表项，找到后将其链接到同义词子表中。</p>
<p><strong>例</strong>，10个数据项，关键码分别为54,77,94,89,14,45,76,23,43,47，散列表长度为11，散列函数为除留余数法h(key)=key%11，散列结果如下：</p>
<p><img src="../imgs/%E6%9F%A5%E6%89%BE/image-20241026174016130-172993562418514.png" alt="image-20241026174016130" style="zoom: 50%;"></p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/11/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2><span id="1二叉树">1二叉树</span></h2><h3><span id="11二叉树的性质">1.1二叉树的性质</span></h3><!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<ol>
<li>任何一棵含有n（n&gt;0）个结点的二叉树恰有n-1条边</li>
<li>深度为h的二叉树至多有2^h^-1个结点</li>
<li>设二叉树的结点个数为n，深度为h，则</li>
</ol>
<script type="math/tex; mode=display">
1</script><p>树与二叉树转换</p>
<p>由树转为二叉树：左子节点仍然是左子结点，右边的兄弟结点转为左边结点的右子结点</p>
<p>由树转换成的二叉树，其根节点没有右子结点（原因是原先的根结点没有兄弟结点）</p>
<p>遍历二叉树</p>
<p>前序非递归遍历：利用栈实现</p>
<p>基本思路：</p>
<p>根据遍历结果确定二叉树</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑-数字钟</title>
    <url>/2024/11/22/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-%E6%95%B0%E5%AD%97%E9%92%9F/</url>
    <content><![CDATA[<h3><span id="题目要求"><strong>题目要求</strong></span></h3><p>请使用SystemVerliog实现一个数字钟。<br>要求：<br>（1）能够显示时分秒；<br>（2）能够设置开始时间；<br>（3）使用你自己的7段数码管显示译码电路实现；<br>（4）可以使用动态显示方法实现；<br>（5）依据实现的其他附加功能，酌情加分：秒表、倒计时、闹钟、…<br>（6）需要在Basys3 FPGA开发板上实现，并通过验收</p>
<p>说明：实现功能：时分，分秒，秒表，倒计时，调时钟（只调时分，秒用reset置0），调闹钟</p>
<!-- toc -->
<ul>
<li><a href="#约束文件"><strong>约束文件</strong></a></li>
<li><a href="#补充说明"><strong>补充说明</strong></a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p><strong>SystemVerilog文件</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DigitalClock.sv</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Company: </span></span><br><span class="line"><span class="comment">// Engineer: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Create Date: 2024/11/16 11:06:09</span></span><br><span class="line"><span class="comment">// Design Name: </span></span><br><span class="line"><span class="comment">// Module Name: DigitalClock</span></span><br><span class="line"><span class="comment">// Project Name: </span></span><br><span class="line"><span class="comment">// Target Devices: </span></span><br><span class="line"><span class="comment">// Tool Versions: </span></span><br><span class="line"><span class="comment">// Description: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Dependencies: </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Revision:</span></span><br><span class="line"><span class="comment">// Revision 0.01 - File Created</span></span><br><span class="line"><span class="comment">// Additional Comments:</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> DigitalClock(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] SW_IN,   <span class="comment">//0是时分，1是分秒，2是秒表，3是倒计时,4调时钟只调时分，秒用reset，5秒表暂停+调倒计时，6倒计时、秒表归零，7闹钟，具体可以查看约束文件</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk,          <span class="comment">//连板子内置时钟 100MHz</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> up,down,left,right,  <span class="comment">//</span></span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> reset,               <span class="comment">//秒表归零，没怎么用</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] show,         <span class="comment">//控制显示哪个数码管   </span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>] dig           <span class="comment">//控制数码管显示什么数</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>] dig1=<span class="number">7&#x27;b0</span>,dig2=<span class="number">7&#x27;b0</span>,dig3=<span class="number">7&#x27;b0</span>,dig4=<span class="number">7&#x27;b0</span>;    <span class="comment">//四位显示</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>]nowtime=<span class="number">0</span>;                      <span class="comment">//时钟计时</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>]nowtime_per=<span class="number">0</span>;                  <span class="comment">//秒表计时</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]h1=<span class="number">0</span>,h2=<span class="number">0</span>;                       <span class="comment">//控制时钟 时，分，秒</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]m1=<span class="number">0</span>,m2=<span class="number">0</span>;                       <span class="comment">//</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]h10=<span class="number">0</span>,h20=<span class="number">0</span>;                     <span class="comment">//闹钟时分</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]m10=<span class="number">0</span>,m20=<span class="number">0</span>;                     <span class="comment">//</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]s1=<span class="number">0</span>,s2=<span class="number">0</span>;                       <span class="comment">//</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]sper1=<span class="number">0</span>,sper2=<span class="number">0</span>;                 <span class="comment">//秒表用，毫秒，秒</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]ss1=<span class="number">0</span>,ss2=<span class="number">0</span>;                     <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]times=<span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>]dig0=<span class="number">7&#x27;b1111111</span>;                 <span class="comment">//全熄灭，</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">17</span>:<span class="number">0</span>]t_len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">logic</span> up_t,down_t,right_t,left_t,reset_t;</span><br><span class="line">    <span class="keyword">logic</span> up_t2,down_t2,right_t2,left_t2,reset_t2;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>]index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">logic</span> judge=<span class="number">0</span>;             <span class="comment">//最多0.2s输入一次</span></span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>]key_in=<span class="number">0</span>,key_flag=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] k1,k2,k3;</span><br><span class="line">    <span class="keyword">logic</span> CNT_MAX = <span class="number">26&#x27;d1999_999</span>;   <span class="comment">//大约是20ms，防抖动</span></span><br><span class="line">    <span class="keyword">logic</span>     [<span class="number">26</span>:<span class="number">0</span>]  ms0;   <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">logic</span>     [<span class="number">26</span>:<span class="number">0</span>]  ms1;   <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">logic</span>     [<span class="number">26</span>:<span class="number">0</span>]  ms2;   <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">logic</span>     [<span class="number">26</span>:<span class="number">0</span>]  ms3;   <span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)            <span class="comment">//这个编得比较随意，因为它只有秒表运行时置零这一个功能</span></span><br><span class="line">        reset_t&lt;=~reset;</span><br><span class="line"> <span class="comment">///——————————————加减、位置移动 处理模块</span></span><br><span class="line"> <span class="comment">//这几个button都是按下为0</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            ms0 &lt;= <span class="number">21&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms0 == CNT_MAX &amp;&amp; left == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            ms0 &lt;= ms0;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ms0 &lt;= ms0 + <span class="number">1&#x27;b1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            ms1 &lt;= <span class="number">21&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms1 == CNT_MAX &amp;&amp; right == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            ms1 &lt;= ms1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ms1 &lt;= ms1 + <span class="number">1&#x27;b1</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(up == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            ms2 &lt;= <span class="number">21&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms2 == CNT_MAX &amp;&amp; up == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            ms2 &lt;= ms2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ms2 &lt;= ms2 + <span class="number">1&#x27;b1</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(down == <span class="number">1&#x27;b1</span>)</span><br><span class="line">            ms3 &lt;= <span class="number">21&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms3 == CNT_MAX &amp;&amp; down == <span class="number">1&#x27;b0</span>)</span><br><span class="line">            ms3 &lt;= ms3;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ms3 &lt;= ms3 + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)</span><br><span class="line">        <span class="keyword">if</span>(ms3 == CNT_MAX - <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                down_t2&lt;=down_t;</span><br><span class="line">                down_t &lt;= <span class="number">1&#x27;b1</span>;    </span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms2 == CNT_MAX - <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                up_t2&lt;=up_t;</span><br><span class="line">                up_t &lt;= <span class="number">1&#x27;b1</span>;    </span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms1 == CNT_MAX - <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                right_t2&lt;=right_t;</span><br><span class="line">                right_t &lt;= <span class="number">1&#x27;b1</span>;    </span><br><span class="line">            <span class="keyword">end</span>        </span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">if</span>(ms0 == CNT_MAX - <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                left_t2&lt;=left_t;</span><br><span class="line">                left_t &lt;= <span class="number">1&#x27;b1</span>;    </span><br><span class="line">            <span class="keyword">end</span>  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            left_t &lt;= <span class="number">0</span>;</span><br><span class="line">            right_t &lt;= <span class="number">0</span>;</span><br><span class="line">            up_t &lt;= <span class="number">0</span>;</span><br><span class="line">            down_t &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> <span class="comment">///--------------加减、位置移动 处理模块结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk)<span class="comment">//左右移button实现</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(right_t &amp;&amp; ~right_t2)<span class="keyword">begin</span>   <span class="comment">//仅在上升沿左右移</span></span><br><span class="line">            <span class="keyword">case</span>(index)</span><br><span class="line">            <span class="number">3</span>:index&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="number">2</span>:index&lt;=<span class="number">3</span>;</span><br><span class="line">            <span class="number">1</span>:index&lt;=<span class="number">2</span>;</span><br><span class="line">            <span class="number">0</span>:index&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>:index&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left_t &amp;&amp; ~left_t2)<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(index)</span><br><span class="line">            <span class="number">0</span>:index&lt;=<span class="number">3</span>;</span><br><span class="line">            <span class="number">1</span>:index&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="number">2</span>:index&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="number">3</span>:index&lt;=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span>:index&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line"> <span class="comment">//————————控制动态显示模块</span></span><br><span class="line"> <span class="comment">//实现方法：四个数记载当前四位数码管各应该显示什么 然后用一个减速过的时钟，</span></span><br><span class="line"> <span class="comment">//每一个上升沿，在相应的数码管位置上显示（只需将数字赋值给控制数码管的变量）</span></span><br><span class="line">    <span class="keyword">always_ff</span>@(<span class="keyword">posedge</span> clk)                 <span class="comment">//四位显示，只显示这四种</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        t_len&lt;=t_len+<span class="number">1</span>;         <span class="comment">//减速过的时钟</span></span><br><span class="line">        <span class="keyword">if</span>(t_len==<span class="number">100000</span>)</span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                t_len&lt;=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">case</span>(times)</span><br><span class="line">                <span class="number">0</span>:<span class="keyword">begin</span>  dig&lt;=dig0;show&lt;=<span class="number">4&#x27;b0111</span>; dig&lt;=dig1; times&lt;=<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">                <span class="number">1</span>:<span class="keyword">begin</span>  dig&lt;=dig0;show&lt;=<span class="number">4&#x27;b1011</span>; dig&lt;=dig2; times&lt;=<span class="number">2</span>; <span class="keyword">end</span></span><br><span class="line">                <span class="number">2</span>:<span class="keyword">begin</span>  dig&lt;=dig0;show&lt;=<span class="number">4&#x27;b1101</span>; dig&lt;=dig3; times&lt;=<span class="number">3</span>; <span class="keyword">end</span></span><br><span class="line">                <span class="number">3</span>:<span class="keyword">begin</span>  dig&lt;=dig0;show&lt;=<span class="number">4&#x27;b1110</span>; dig&lt;=dig4; times&lt;=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>: ;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t_len&lt;=t_len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//————————显示模块结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//————————控制模块1，针对不同的SW_IN输入，控制变量随时间的变化，同时设置限制条件，比如小时0—23，分钟0—59，变量控制</span></span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) </span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            nowtime&lt;=nowtime+<span class="number">5497</span>;</span><br><span class="line">            <span class="keyword">if</span>(nowtime[<span class="number">39</span>] &amp; ~SW_IN[<span class="number">4</span>]) <span class="comment">//正常时钟，只有在设置初始时间时时钟不动，控制h1 h2 m1 m2 s1 s2：时分秒</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                judge&lt;=~judge;</span><br><span class="line">                nowtime&lt;=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">case</span>(s2)</span><br><span class="line">                <span class="number">9</span>:<span class="keyword">begin</span></span><br><span class="line">                  s2&lt;=<span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">case</span>(s1)</span><br><span class="line">                  <span class="number">5</span>:<span class="keyword">begin</span></span><br><span class="line">                    s1&lt;=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">case</span>(m2)</span><br><span class="line">                    <span class="number">9</span>:<span class="keyword">begin</span></span><br><span class="line">                        m2&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">case</span>(m1)</span><br><span class="line">                        <span class="number">5</span>:<span class="keyword">begin</span></span><br><span class="line">                          m1&lt;=<span class="number">0</span>;</span><br><span class="line">                          <span class="keyword">case</span>(h2)</span><br><span class="line">                          <span class="number">9</span>:<span class="keyword">begin</span> h2&lt;=<span class="number">0</span>;h1&lt;=h1+<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">                          <span class="number">4</span>:<span class="keyword">case</span>(h1)</span><br><span class="line">                            <span class="number">2</span>:<span class="keyword">begin</span> h1&lt;=<span class="number">0</span>;h2&lt;=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">default</span>: h1&lt;=h1;</span><br><span class="line">                            <span class="keyword">endcase</span></span><br><span class="line">                          <span class="keyword">default</span>:h2&lt;=h2+<span class="number">1</span>;</span><br><span class="line">                          <span class="keyword">endcase</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>:m1&lt;=m1+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>:m2&lt;=m2+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                  <span class="keyword">end</span></span><br><span class="line">                  <span class="keyword">default</span>: s1&lt;=s1+<span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">endcase</span> </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>:s2&lt;=s2+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(SW_IN[<span class="number">2</span>])<span class="comment">//秒表，只需控制ss1 ss2 sper1 sper2：秒 毫秒</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                nowtime_per&lt;=nowtime_per+<span class="number">549756</span>;</span><br><span class="line">                <span class="keyword">if</span>(nowtime_per[<span class="number">39</span>] &amp; reset_t)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    nowtime_per&lt;=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">case</span>(sper2)</span><br><span class="line">                    <span class="number">9</span>:<span class="keyword">begin</span></span><br><span class="line">                        sper2&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">case</span>(sper1)</span><br><span class="line">                        <span class="number">9</span>:<span class="keyword">begin</span></span><br><span class="line">                            sper1&lt;=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">case</span>(ss2)</span><br><span class="line">                            <span class="number">9</span>:<span class="keyword">begin</span></span><br><span class="line">                                ss2&lt;=<span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">case</span>(ss1)</span><br><span class="line">                                    <span class="number">5</span>:ss1&lt;=<span class="number">0</span>;</span><br><span class="line">                                    <span class="keyword">default</span>:ss1&lt;=ss1+<span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">endcase</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">default</span>:ss2&lt;=ss2+<span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">endcase</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>: sper1&lt;=sper1+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span> </span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>:sper2&lt;=sper2+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">if</span>(~reset_t)<span class="keyword">begin</span></span><br><span class="line">                    ss1&lt;=<span class="number">0</span>;</span><br><span class="line">                    ss2&lt;=<span class="number">0</span>;</span><br><span class="line">                    sper1&lt;=<span class="number">0</span>;</span><br><span class="line">                    sper2&lt;=<span class="number">0</span>;               </span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">3</span>])<span class="comment">//倒计时因为其与秒表相互独立，所以共用变量</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span>(nowtime==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">case</span>(sper2)</span><br><span class="line">                    <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(sper1)</span><br><span class="line">                        <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                            <span class="keyword">case</span>(ss2)</span><br><span class="line">                            <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                                <span class="keyword">case</span>(ss1)</span><br><span class="line">                                <span class="number">0</span>:ss1&lt;=ss1;</span><br><span class="line">                                <span class="keyword">default</span>:<span class="keyword">begin</span> sper2&lt;=<span class="number">9</span>;sper1&lt;=<span class="number">5</span>;ss2&lt;=<span class="number">9</span>;ss1&lt;=ss1-<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">                                <span class="keyword">endcase</span></span><br><span class="line">                            <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">default</span>:<span class="keyword">begin</span> sper2&lt;=<span class="number">9</span>;sper1&lt;=<span class="number">5</span>;ss2&lt;=ss2-<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">                            <span class="keyword">endcase</span></span><br><span class="line">                        <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">default</span>:<span class="keyword">begin</span> sper2&lt;=<span class="number">9</span>;sper1&lt;=sper1-<span class="number">1</span>; <span class="keyword">end</span></span><br><span class="line">                        <span class="keyword">endcase</span> </span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">default</span>:sper2&lt;=sper2-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">4</span>])<span class="comment">//调时钟，可以通过上下左右四个button调时分，秒通过reset置零</span></span><br><span class="line">            <span class="keyword">begin</span>  </span><br><span class="line">                <span class="keyword">case</span>(index)</span><br><span class="line">                <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h1)</span><br><span class="line">                        <span class="number">2</span>:h1&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h1&lt;=h1+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h1)</span><br><span class="line">                        <span class="number">0</span>:h1&lt;=<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h1&lt;=h1-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">1</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h2)</span><br><span class="line">                        <span class="number">9</span>:h2&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h2&lt;=h2+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h2)</span><br><span class="line">                        <span class="number">0</span>:h2&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h2&lt;=h2-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m1)</span><br><span class="line">                        <span class="number">5</span>:m1&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m1&lt;=m1+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m1)</span><br><span class="line">                        <span class="number">0</span>:m1&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m1&lt;=m1-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">3</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m2)</span><br><span class="line">                        <span class="number">9</span>:m2&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m2&lt;=m2+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m2)</span><br><span class="line">                        <span class="number">0</span>:m2&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m2&lt;=m2-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>:;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">if</span>(~reset_t)</span><br><span class="line">                <span class="keyword">begin</span> s1&lt;=<span class="number">0</span>;s2&lt;=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">5</span>])<span class="comment">//调倒计时，可以通过上下左右四个button调分秒，倒计时直到0为止</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">case</span>(index)</span><br><span class="line">                <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(ss1)</span><br><span class="line">                        <span class="number">5</span>:ss1&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:ss1&lt;=ss1+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(ss1)</span><br><span class="line">                        <span class="number">0</span>:ss1&lt;=<span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">default</span>:ss1&lt;=ss1-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">1</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(ss2)</span><br><span class="line">                        <span class="number">9</span>:ss2&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:ss2&lt;=ss2+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(ss2)</span><br><span class="line">                        <span class="number">0</span>:ss2&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:ss2&lt;=ss2-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(sper1)</span><br><span class="line">                        <span class="number">5</span>:sper1&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:sper1&lt;=sper1+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(sper1)</span><br><span class="line">                        <span class="number">0</span>:sper1&lt;=<span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">default</span>:sper1&lt;=sper1-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">3</span>:<span class="keyword">begin</span></span><br><span class="line">                     <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(sper2)</span><br><span class="line">                        <span class="number">9</span>:sper2&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:sper2&lt;=sper2+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                     <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(sper2)</span><br><span class="line">                        <span class="number">0</span>:sper2&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:sper2&lt;=sper2-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>:;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">6</span>])<span class="comment">//调闹钟，可以通过上下左右四个button调时分，到此时此分时数码管闪烁</span></span><br><span class="line">            <span class="keyword">begin</span> </span><br><span class="line">                <span class="keyword">case</span>(index)</span><br><span class="line">                <span class="number">0</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h10)</span><br><span class="line">                        <span class="number">2</span>:h10&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h10&lt;=h10+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h10)</span><br><span class="line">                        <span class="number">0</span>:h10&lt;=<span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h10&lt;=h10-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">1</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h20)</span><br><span class="line">                        <span class="number">9</span>:h20&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h20&lt;=h20+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(h20)</span><br><span class="line">                        <span class="number">0</span>:h20&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:h20&lt;=h20-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">2</span>:<span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m10)</span><br><span class="line">                        <span class="number">5</span>:m10&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m10&lt;=m10+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m10)</span><br><span class="line">                        <span class="number">0</span>:m10&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m10&lt;=m10-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="number">3</span>:<span class="keyword">begin</span></span><br><span class="line">                     <span class="keyword">if</span>(up_t &amp;&amp; ~up_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m20)</span><br><span class="line">                        <span class="number">9</span>:m20&lt;=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m20&lt;=m20+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    <span class="keyword">if</span>(down_t &amp;&amp; ~down_t2)</span><br><span class="line">                    <span class="keyword">begin</span></span><br><span class="line">                        <span class="keyword">case</span>(m20)</span><br><span class="line">                        <span class="number">0</span>:m20&lt;=<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">default</span>:m20&lt;=m20-<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">endcase</span></span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">default</span>:;</span><br><span class="line">                <span class="keyword">endcase</span></span><br><span class="line">                <span class="keyword">if</span>(~reset_t)</span><br><span class="line">                <span class="keyword">begin</span> s1&lt;=<span class="number">0</span>;s2&lt;=<span class="number">0</span>; <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">7</span>])<span class="comment">//秒表、倒计时归零</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                ss1&lt;=<span class="number">0</span>;</span><br><span class="line">                ss2&lt;=<span class="number">0</span>;</span><br><span class="line">                sper1&lt;=<span class="number">0</span>;</span><br><span class="line">                sper2&lt;=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(~SW_IN);</span><br><span class="line">            <span class="keyword">else</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line"><span class="comment">//--------控制模块1结束    </span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="comment">//--------控制模块2，显示控制模块    </span></span><br><span class="line">    <span class="keyword">always_comb</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(SW_IN[<span class="number">0</span>]|SW_IN[<span class="number">4</span>])<span class="comment">//显示时分</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(h1)</span><br><span class="line">                <span class="number">0</span>:dig1=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig1=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig1=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig1=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig1=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig1=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig1=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig1=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig1=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig1=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig1=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(h2)</span><br><span class="line">                <span class="number">0</span>:dig2=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig2=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig2=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig2=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig2=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig2=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig2=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig2=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig2=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig2=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig2=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(m1)</span><br><span class="line">                <span class="number">0</span>:dig3=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig3=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig3=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig3=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig3=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig3=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig3=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig3=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig3=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig3=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig3=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(m2)</span><br><span class="line">                <span class="number">0</span>:dig4=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig4=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig4=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig4=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig4=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig4=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig4=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig4=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig4=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig4=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig4=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">if</span>(judge &amp;&amp; (h1==h10) &amp;&amp; (h2==h20) &amp;&amp; (m1==m10) &amp;&amp; (m2==m20))</span><br><span class="line">                <span class="keyword">begin</span> dig1=<span class="number">7&#x27;b1111111</span>;dig2=<span class="number">7&#x27;b1111111</span>;dig3=<span class="number">7&#x27;b1111111</span>;dig4=<span class="number">7&#x27;b1111111</span>; <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">1</span>])   <span class="comment">//显示分秒</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(m1)</span><br><span class="line">                <span class="number">0</span>:dig1=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig1=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig1=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig1=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig1=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig1=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig1=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig1=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig1=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig1=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig1=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(m2)</span><br><span class="line">                <span class="number">0</span>:dig2=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig2=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig2=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig2=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig2=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig2=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig2=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig2=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig2=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig2=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig2=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(s1)</span><br><span class="line">                <span class="number">0</span>:dig3=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig3=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig3=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig3=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig3=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig3=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig3=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig3=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig3=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig3=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig3=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(s2)</span><br><span class="line">                <span class="number">0</span>:dig4=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig4=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig4=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig4=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig4=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig4=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig4=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig4=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig4=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig4=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig4=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">2</span>]|SW_IN[<span class="number">3</span>]|SW_IN[<span class="number">5</span>]|~SW_IN)<span class="comment">// 显示秒表/倒计时</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(ss1)</span><br><span class="line">                <span class="number">0</span>:dig1=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig1=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig1=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig1=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig1=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig1=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig1=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig1=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig1=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig1=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig1=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(ss2)</span><br><span class="line">                <span class="number">0</span>:dig2=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig2=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig2=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig2=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig2=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig2=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig2=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig2=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig2=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig2=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig2=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(sper1)</span><br><span class="line">                <span class="number">0</span>:dig3=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig3=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig3=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig3=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig3=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig3=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig3=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig3=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig3=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig3=<span class="number">7&#x27;b0000100</span>;                </span><br><span class="line">                <span class="keyword">default</span>:dig3=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(sper2)</span><br><span class="line">                <span class="number">0</span>:dig4=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig4=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig4=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig4=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig4=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig4=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig4=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig4=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig4=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig4=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig4=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>(SW_IN[<span class="number">6</span>])    <span class="comment">//显示闹钟</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">case</span>(h10)</span><br><span class="line">                <span class="number">0</span>:dig1=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig1=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig1=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig1=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig1=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig1=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig1=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig1=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig1=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig1=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig1=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(h20)</span><br><span class="line">                <span class="number">0</span>:dig2=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig2=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig2=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig2=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig2=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig2=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig2=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig2=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig2=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig2=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig2=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(m10)</span><br><span class="line">                <span class="number">0</span>:dig3=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig3=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig3=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig3=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig3=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig3=<span class="number">7&#x27;b0100100</span>;</span><br><span class="line">                <span class="number">6</span>:dig3=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig3=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig3=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig3=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig3=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">            <span class="keyword">case</span>(m20)</span><br><span class="line">                <span class="number">0</span>:dig4=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">                <span class="number">1</span>:dig4=<span class="number">7&#x27;b1001111</span>; </span><br><span class="line">                <span class="number">2</span>:dig4=<span class="number">7&#x27;b0010010</span>;</span><br><span class="line">                <span class="number">3</span>:dig4=<span class="number">7&#x27;b0000110</span>;</span><br><span class="line">                <span class="number">4</span>:dig4=<span class="number">7&#x27;b1001100</span>; </span><br><span class="line">                <span class="number">5</span>:dig4=<span class="number">7&#x27;b0100100</span>;                </span><br><span class="line">                <span class="number">6</span>:dig4=<span class="number">7&#x27;b0100000</span>;</span><br><span class="line">                <span class="number">7</span>:dig4=<span class="number">7&#x27;b0001111</span>; </span><br><span class="line">                <span class="number">8</span>:dig4=<span class="number">7&#x27;b0000000</span>;                </span><br><span class="line">                <span class="number">9</span>:dig4=<span class="number">7&#x27;b0000100</span>;</span><br><span class="line">                <span class="keyword">default</span>:dig4=<span class="number">7&#x27;b1111111</span>;</span><br><span class="line">            <span class="keyword">endcase</span>            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(SW_IN[<span class="number">7</span>])   <span class="comment">//归零显示</span></span><br><span class="line">        <span class="keyword">begin</span> </span><br><span class="line">            dig1=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">            dig2=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">            dig3=<span class="number">7&#x27;b0000001</span>;</span><br><span class="line">            dig4=<span class="number">7&#x27;b0000001</span>; </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">//--------控制模块2-显示控制模块结束    </span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="约束文件"><strong>约束文件</strong></span></h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DigitalClock.xdc</span></span><br><span class="line">set_property PACKAGE_PIN W5 [get_ports clk]</span><br><span class="line">set_property PACKAGE_PIN T18 [get_ports up]</span><br><span class="line">set_property PACKAGE_PIN U17 [get_ports down]</span><br><span class="line">set_property PACKAGE_PIN W19 [get_ports left]</span><br><span class="line">set_property PACKAGE_PIN T17 [get_ports right]</span><br><span class="line">set_property PACKAGE_PIN U18 [get_ports reset]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports clk]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports up]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports down]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports left]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports right]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports reset]  </span><br><span class="line">set_property PACKAGE_PIN V17 [get_ports &#123;SW_IN[<span class="number">0</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN V16 [get_ports &#123;SW_IN[<span class="number">1</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W16 [get_ports &#123;SW_IN[<span class="number">2</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W17 [get_ports &#123;SW_IN[<span class="number">3</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W15 [get_ports &#123;SW_IN[<span class="number">4</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN V15 [get_ports &#123;SW_IN[<span class="number">5</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W14 [get_ports &#123;SW_IN[<span class="number">6</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W13 [get_ports &#123;SW_IN[<span class="number">7</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W4 [get_ports &#123;show[<span class="number">3</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN V4 [get_ports &#123;show[<span class="number">2</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN U4 [get_ports &#123;show[<span class="number">1</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN U2 [get_ports &#123;show[<span class="number">0</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W7 [get_ports &#123;dig[<span class="number">6</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN W6 [get_ports &#123;dig[<span class="number">5</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN U8 [get_ports &#123;dig[<span class="number">4</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN V8 [get_ports &#123;dig[<span class="number">3</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN U5 [get_ports &#123;dig[<span class="number">2</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN V5 [get_ports &#123;dig[<span class="number">1</span>]&#125;] </span><br><span class="line">set_property PACKAGE_PIN U7 [get_ports &#123;dig[<span class="number">0</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">0</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">1</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">2</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">3</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">4</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">5</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">6</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;SW_IN[<span class="number">7</span>]&#125;]</span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;show[<span class="number">2</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;show[<span class="number">1</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;show[<span class="number">0</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">6</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">5</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">4</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">3</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">1</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">2</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;dig[<span class="number">0</span>]&#125;] </span><br><span class="line">set_property IOSTANDARD LVCMOS33 [get_ports &#123;show[<span class="number">3</span>]&#125;]</span><br></pre></td></tr></table></figure>
<h3><span id="补充说明"><strong>补充说明</strong></span></h3><p>数字钟在SW_IN=0时是缓冲状态，本来应该保存上一次的显示，但跑起来总是显示出问题，所以退而求其次，SW_IN=0时显示倒计时或秒表界面（因为秒表的暂停时SW_IN=0，所以这个界面必须保存）</p>
]]></content>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑笔记1</title>
    <url>/2024/11/04/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑笔记4</title>
    <url>/2024/11/04/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h3><span id="关于systemverilog硬件描述语言的笔记">关于SystemVerilog硬件描述语言的笔记</span></h3><!-- toc -->
<ul>
<li><a href="#testbenches测试"><strong>Testbenches测试</strong></a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<p><strong>示例：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> example(<span class="keyword">input</span> <span class="keyword">logic</span> a,b,c,</span><br><span class="line">               <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">    <span class="keyword">assign</span> y = ~a &amp; ~b &amp; ~c | a &amp; ~b &amp; ~c | a &amp; ~b &amp; c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li><p>module/endmodule：构建模块所必需的</p>
</li>
<li><p>example：模块的名字</p>
</li>
<li><p>操作符：</p>
<p>~：NOT</p>
<p>&amp;：AND</p>
<p>|：OR</p>
</li>
</ul>
<p><strong>SystemVerilog语法注意事项</strong></p>
<ul>
<li>区分大小写</li>
<li>变量名字不能以数字开头</li>
<li>空格被忽略</li>
<li>注释</li>
</ul>
<p>​        // 单行注释</p>
<p>​        /<em>    </em>/ 多行注释</p>
<h4><span id="结构化建模实例"><strong>结构化建模(实例)：</strong></span></h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> and3(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c,</span><br><span class="line">			<span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">  <span class="keyword">assign</span> y = a &amp; b &amp; c;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> inv(<span class="keyword">input</span> <span class="keyword">logic</span> a,</span><br><span class="line">		   <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">  <span class="keyword">assign</span> y = ~a;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> nand3(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c</span><br><span class="line">			 <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">  <span class="keyword">logic</span> n1; <span class="comment">// 内部信号</span></span><br><span class="line">  and3 andgate(<span class="variable">.a</span>(a), <span class="variable">.b</span>(b), <span class="variable">.c</span>(c), <span class="variable">.y</span>(n1)); <span class="comment">// and3的实例，andgate不必在意</span></span><br><span class="line">  inv inverter(<span class="variable">.a</span>(n1), <span class="variable">.y</span>(y)); <span class="comment">// inv的实例</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>小细节：</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4位宽度总线的变量</span></span><br><span class="line"><span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a,b,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] y;</span><br><span class="line">  <span class="keyword">assign</span> y = a|b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归约操作</span></span><br><span class="line"><span class="keyword">module</span> <span class="keyword">and</span>(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a,</span><br><span class="line">		   <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">  <span class="keyword">assign</span> y = &amp;a;</span><br><span class="line"><span class="comment">// &amp;a 这种写法，要远比下述写法简单</span></span><br><span class="line"><span class="comment">// assign y = a[7] &amp; a[6] &amp; a[5] &amp; a[4] &amp;</span></span><br><span class="line"><span class="comment">// a[3] &amp; a[2] &amp; a[1] &amp; a[0];</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3元操作符</span></span><br><span class="line"><span class="keyword">module</span> mux2(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] d0,d1,</span><br><span class="line">			<span class="keyword">input</span> <span class="keyword">logic</span> s,</span><br><span class="line">            <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] y);</span><br><span class="line">    <span class="keyword">assign</span> y = s?d1:d0;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//这段代码实现了一个二输入的复用器，s为1则输出d1，为0则输出d0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成内部变量，方便操作</span></span><br><span class="line"><span class="keyword">module</span> fulladder(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, cin,</span><br><span class="line">				 <span class="keyword">output</span> <span class="keyword">logic</span> s, cout);</span><br><span class="line">    <span class="keyword">logic</span> p, g; <span class="comment">// 内部结点</span></span><br><span class="line">	<span class="keyword">assign</span> p = a ^ b;</span><br><span class="line">	<span class="keyword">assign</span> g = a &amp; b;</span><br><span class="line">	<span class="keyword">assign</span> s = p ^ cin;</span><br><span class="line">	<span class="keyword">assign</span> cout = g | (p &amp; cin);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><strong>运算符的优先级</strong></p>
<p>最高</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>~</th>
<th>NOT</th>
</tr>
</thead>
<tbody>
<tr>
<td>*, /, %</td>
<td>mult, div, mod</td>
</tr>
<tr>
<td>+, -</td>
<td>add, sub</td>
</tr>
<tr>
<td>&lt;&lt;, &gt;&gt;</td>
<td>shift</td>
</tr>
<tr>
<td>&lt;&lt;&lt;, &gt;&gt;&gt;</td>
<td>arithmetic shift</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>comparison</td>
</tr>
<tr>
<td>==, !=</td>
<td>equal, not equal</td>
</tr>
<tr>
<td>&amp;, ~&amp;</td>
<td>AND, NAND</td>
</tr>
<tr>
<td>^, ~^</td>
<td>XOR, XNOR</td>
</tr>
<tr>
<td>\</td>
<td>, ~\</td>
<td></td>
<td>OR, NOR</td>
</tr>
<tr>
<td>? :</td>
<td>ternary operator</td>
</tr>
</tbody>
</table>
</div>
<p>最低</p>
<p><strong>数字赋值格式</strong></p>
<p>格式: N’Bvalue </p>
<ul>
<li>N = bit数, B = 基 </li>
<li>N‘B 是可省略的，但是强烈建议 (默认是10进制)</li>
</ul>
<p>例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>比特数</th>
<th>基</th>
<th>10进制等价值</th>
<th>存储</th>
</tr>
</thead>
<tbody>
<tr>
<td>3’b101</td>
<td>3</td>
<td>二进制</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td>‘b11</td>
<td>未赋值</td>
<td>无符号二进制</td>
<td>3</td>
<td>000…..11</td>
</tr>
</tbody>
</table>
</div>
<p>拼接赋值：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> y = &#123;a[<span class="number">2</span>:<span class="number">1</span>], &#123;<span class="number">3</span>&#123;b[<span class="number">0</span>]&#125;&#125;, a[<span class="number">0</span>], <span class="number">6&#x27;b100_010</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果y是一个12位的信号，那么上面的语句将产生: </span></span><br><span class="line"></span><br><span class="line">y = a[<span class="number">2</span>] a[<span class="number">1</span>] b[<span class="number">0</span>] b[<span class="number">0</span>] b[<span class="number">0</span>] a[<span class="number">0</span>] <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下划线 _ 仅用于表明格式以便增强可读性 // SystemVerilog会忽略这些下划线. </span></span><br></pre></td></tr></table></figure>
<p>延迟：在某一语句前或后加一句#10（表示延迟前面的操作10ns，中间没有输入），在测试的时候很好用</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> pluse;</span><br><span class="line"><span class="keyword">initial</span>					<span class="comment">//表示模拟时间从0开始	</span></span><br><span class="line"><span class="keyword">begin</span>    				<span class="comment">//类似于C++的 &#123;...&#125; 可以在case语句中使用</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4><span id="always_ff-always_comb"><strong>always_ff / always_comb</strong></span></h4><ul>
<li>SystemVerilog使用特有风格来描述锁存 器、触发器和FSM</li>
<li>注意！其他代码风格可能是可以正确模 拟，但可能会产生错误的硬件</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sensitivity list)</span><br><span class="line">	statement;</span><br><span class="line"><span class="comment">//如果sensitivity list中的事件发生，则执行statement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//always_ff 写触发器  在其内部仅能使用&lt;=来赋值</span></span><br><span class="line"><span class="comment">//D触发器</span></span><br><span class="line"><span class="keyword">module</span> flop(<span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">			<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] d,</span><br><span class="line">			<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] q);</span><br><span class="line">	<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">		q &lt;= d; <span class="comment">// 读作 “q 获得 d”</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带复位功能的D触发器</span></span><br><span class="line"><span class="keyword">module</span> flopr(<span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">			<span class="keyword">input</span> <span class="keyword">logic</span> reset,</span><br><span class="line">			<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] d,</span><br><span class="line">			<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] q);</span><br><span class="line"><span class="comment">//同步复位</span></span><br><span class="line">	<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">		<span class="keyword">if</span> (reset) q &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> q &lt;= d;</span><br><span class="line"><span class="comment">//异步复位</span></span><br><span class="line">	<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line">		<span class="keyword">if</span> (reset) q &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">		<span class="keyword">else</span> q &lt;= d;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//always_comb 用于写组合逻辑</span></span><br><span class="line"><span class="comment">// 使用always语句的组合逻辑电路</span></span><br><span class="line"><span class="keyword">module</span> gates(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a, b,</span><br><span class="line">			 <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] y1, y2, y3, y4, y5);</span><br><span class="line">	<span class="keyword">always_comb</span></span><br><span class="line">		<span class="keyword">begin</span> <span class="comment">//由于有多于1条语句，因此需要 begin/end</span></span><br><span class="line">			y1 = a &amp; b; <span class="comment">// AND</span></span><br><span class="line">			y2 = a | b; <span class="comment">// OR</span></span><br><span class="line">			y3 = a ^ b; <span class="comment">// XOR</span></span><br><span class="line">			y4 = ~(a &amp; b); <span class="comment">// NAND</span></span><br><span class="line">			y5 = ~(a | b); <span class="comment">// NOR</span></span><br><span class="line">		<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>case/casez &amp; if/else</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//说明：这两个语句都只能在always语句内部使用</span></span><br><span class="line"><span class="comment">//数字显示装置</span></span><br><span class="line"><span class="keyword">module</span> sevenseg(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] data,</span><br><span class="line">				<span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>] segments);</span><br><span class="line">	<span class="keyword">always_comb</span></span><br><span class="line">		<span class="keyword">case</span> (data)</span><br><span class="line">		<span class="comment">// abc_defg</span></span><br><span class="line">            <span class="number">0</span>: segments = <span class="number">7</span>’b111_1110;<span class="comment">//如果想写多条语句，就用begin……end</span></span><br><span class="line">			<span class="number">1</span>: segments = <span class="number">7</span>’b011_0000;</span><br><span class="line">			<span class="number">2</span>: segments = <span class="number">7</span>’b110_1101;</span><br><span class="line">			<span class="number">3</span>: segments = <span class="number">7</span>’b111_1001;</span><br><span class="line">			<span class="number">4</span>: segments = <span class="number">7</span>’b011_0011;</span><br><span class="line">			<span class="number">5</span>: segments = <span class="number">7</span>’b101_1011;</span><br><span class="line">			<span class="number">6</span>: segments = <span class="number">7</span>’b101_1111;</span><br><span class="line">			<span class="number">7</span>: segments = <span class="number">7</span>’b111_0000;</span><br><span class="line">			<span class="number">8</span>: segments = <span class="number">7</span>’b111_1111;</span><br><span class="line">			<span class="number">9</span>: segments = <span class="number">7</span>’b111_0011;</span><br><span class="line">			<span class="keyword">default</span>: segments = <span class="number">7</span>’b000_0000; <span class="comment">// 必须的</span></span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级电路</span></span><br><span class="line"><span class="keyword">module</span> priority_casez(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line">					  <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] y);</span><br><span class="line">	<span class="keyword">always_comb</span></span><br><span class="line">		<span class="keyword">casez</span>(a)</span><br><span class="line">			<span class="number">4</span>’b1???: y = <span class="number">4</span>’b1000; <span class="comment">// ?=不关心,比较有用</span></span><br><span class="line">			<span class="number">4</span>’b01??: y = <span class="number">4</span>’b0100;</span><br><span class="line">			<span class="number">4</span>’b001?: y = <span class="number">4</span>’b0010;</span><br><span class="line">			<span class="number">4</span>’b0001: y = <span class="number">4</span>’b0001;</span><br><span class="line">			<span class="keyword">default</span>: y = <span class="number">4</span>’b0000;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//带输入的有限状态机（FSM）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">• 三段式写法:</span></span><br><span class="line"><span class="comment">  – 次态逻辑</span></span><br><span class="line"><span class="comment">  – 状态寄存器</span></span><br><span class="line"><span class="comment">  – 输出逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fsmWithInputs(<span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line">					 <span class="keyword">input</span> <span class="keyword">logic</span> reset,</span><br><span class="line"> 					 <span class="keyword">input</span> <span class="keyword">logic</span> a,</span><br><span class="line">					 <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">	statetype state, nextstate;</span><br><span class="line">	<span class="comment">//状态寄存器</span></span><br><span class="line">	<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line">		<span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line">		<span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line">	<span class="comment">//次态逻辑</span></span><br><span class="line">	<span class="keyword">always_comb</span></span><br><span class="line">		<span class="keyword">case</span> (state)</span><br><span class="line">			S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">				<span class="keyword">else</span> nextstate = S0;</span><br><span class="line">			S1: nextstate = S2;</span><br><span class="line">			S2: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">				<span class="keyword">else</span> nextstate = S0;</span><br><span class="line">			<span class="keyword">default</span>: nextstate = S0;</span><br><span class="line">		<span class="keyword">endcase</span></span><br><span class="line">	<span class="comment">//输出逻辑</span></span><br><span class="line">	<span class="keyword">assign</span> q = (state == S2);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h4><span id="参数化模块"><strong>参数化模块</strong></span></h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mux2</span><br><span class="line">	#(<span class="keyword">parameter</span> width = <span class="number">8</span>) <span class="comment">// 模块名及参数缺省值</span></span><br><span class="line">	(<span class="keyword">input</span> <span class="keyword">logic</span> [width-<span class="number">1</span>:<span class="number">0</span>] d0, d1,</span><br><span class="line">	<span class="keyword">input</span> <span class="keyword">logic</span> s,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">logic</span> [width-<span class="number">1</span>:<span class="number">0</span>] y);</span><br><span class="line">		<span class="keyword">assign</span> y = s ? d1 : d0;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用示例</span></span><br><span class="line">mux2 <span class="variable">#(.width(12)) lowmux(.d0(d0), .d1(d1), .s(s), .y(out))</span>;</span><br><span class="line"><span class="comment">// mux2 #(12) lowmux(d0, d1, s, out);</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3><span id="testbenches测试"><strong>Testbenches测试</strong></span></h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="comment">//sv代码</span></span><br><span class="line"><span class="keyword">module</span> sillyfunction(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c,</span><br><span class="line">					 <span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">	<span class="keyword">assign</span> y = ~b &amp; ~c | a &amp; ~b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tb代码</span></span><br><span class="line"><span class="keyword">module</span> testbench1; <span class="comment">// testbench是一个封闭的世界</span></span><br><span class="line">	<span class="keyword">logic</span> a, b, c;</span><br><span class="line">	<span class="keyword">logic</span> y;</span><br><span class="line">	<span class="comment">// 实例化device under test</span></span><br><span class="line">	sillyfunction dut(<span class="variable">.a</span>(a), <span class="variable">.b</span>(b), <span class="variable">.c</span>(c), <span class="variable">.y</span>(y));</span><br><span class="line">	<span class="comment">// 给出输入</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span> <span class="comment">// 模拟器在0时刻开始执行initial语句</span></span><br><span class="line">		a = <span class="number">0</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;<span class="comment">//不加则会在一瞬间执行完所有语句</span></span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		a = <span class="number">1</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">/* 说明：在tb文件中调用原”函数“，可以使用穷举输入，也可以使用特定输入 */</span></span><br><span class="line"><span class="comment">//上面的代码需用人眼观察输出波形，数据量多了不方便，可以用下面的代码，自动检测</span></span><br><span class="line"><span class="keyword">module</span> testbench2;</span><br><span class="line">	<span class="keyword">logic</span> a, b, c;</span><br><span class="line">	<span class="keyword">logic</span> y;</span><br><span class="line">	sillyfunction dut((<span class="variable">.a</span>(a), <span class="variable">.b</span>(b), <span class="variable">.c</span>(c), <span class="variable">.y</span>(y)); <span class="comment">// 实例化dut</span></span><br><span class="line">	<span class="keyword">initial</span> <span class="keyword">begin</span> <span class="comment">// 给出输入，检查结果</span></span><br><span class="line">		a = <span class="number">0</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">1</span>) <span class="built_in">$display</span>(<span class="string">&quot;000 failed.&quot;</span>);</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">0</span>) <span class="built_in">$display</span>(<span class="string">&quot;001 failed.&quot;</span>);</span><br><span class="line">		b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">0</span>) <span class="built_in">$display</span>(<span class="string">&quot;010 failed.&quot;</span>);</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">0</span>) <span class="built_in">$display</span>(<span class="string">&quot;011 failed.&quot;</span>);</span><br><span class="line">		a = <span class="number">1</span>; b = <span class="number">0</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">1</span>) <span class="built_in">$display</span>(<span class="string">&quot;100 failed.&quot;</span>);</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">1</span>) <span class="built_in">$display</span>(<span class="string">&quot;101 failed.&quot;</span>);</span><br><span class="line">		b = <span class="number">1</span>; c = <span class="number">0</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">0</span>) <span class="built_in">$display</span>(<span class="string">&quot;110 failed.&quot;</span>);</span><br><span class="line">		c = <span class="number">1</span>; #<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span> (y !== <span class="number">0</span>) <span class="built_in">$display</span>(<span class="string">&quot;111 failed.&quot;</span>);</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑笔记2</title>
    <url>/2024/11/04/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑笔记5</title>
    <url>/2024/11/04/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>数字逻辑笔记3</title>
    <url>/2024/11/04/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>数字逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构大作业—药店卖药</title>
    <url>/2024/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E8%8D%AF%E5%BA%97%E5%8D%96%E8%8D%AF/</url>
    <content><![CDATA[<p>[TOC]</p>
<!-- toc -->
<ul>
<li><a href="#前言">前言：</a></li>
<li><a href="#实验背景">实验背景：</a></li>
<li><a href="#提示">提示：</a></li>
<li><a href="#模拟流程">模拟流程:</a></li>
<li><a href="#代码思路">代码思路：</a></li>
<li><a href="#优化">优化：</a></li>
<li><a href="#变量及函数说明">变量及函数说明：</a></li>
<li><a href="#代码">代码:</a></li>
<li><a href="#实验结果">实验结果：</a></li>
<li><a href="#总结与分析">总结与分析：</a></li>
<li><a href="#补充">补充！！！</a></li>
</ul>
<!-- tocstop -->
<span id="more"></span>
<h3><span id="前言">前言：</span></h3><p>昨晚刚考完数据结构，空闲时间比较多，因为我参考了很多CSDN上学长的代码和思路（主要是思路），所以写了这篇博客，分享我的大作业的思路和具体代码，或许可以供学弟学妹们参考。药店卖药应该是三个大作业中最有意思的，思路不太好找，而且其中各种变量和中间变量的处理也挺难搞，即使参考了CSDN上学长的代码和思路，我还是花了4天多才搞出来（第1天因为曲解了题意，认为10天后未被卖出的药品必须丢掉，敲的代码直接报废了）。</p>
<p>本文的思路是通过贪心+退火＋爬山算法来解决药店卖药问题，实际的运行结果优秀，大概率是最优解。</p>
<h3><span id="实验背景">实验背景：</span></h3><p>你是⼀家药店的老板，这个月从供货商手里收到了一批共 50 个药品，其中每个药品有独立的进价和保质期：</p>
<p>•<strong>进价</strong>：[20, 30] 元；</p>
<p>•<strong>保质期</strong>：剩余 [1, 15] 天；</p>
<p>•<strong>定价</strong>：在进价基础上加 {-1.5,-1, -0.5, 0, 2 ,4 ,6} 元；</p>
<p>•<strong>基本规则</strong>：每天可以陈列 <strong>10</strong> <strong>个及以下数量</strong>的药品，每天会有三个顾客<strong>依次</strong>买药<strong>，</strong>购买者都会先买陈列中最便宜的药，若价钱相同则选保质期最长的药；</p>
<p>•<strong>药物存储</strong>：未被陈列的药品需要存储在仓库，这会带来存储开销（保质期＜5天，1 元/天；其余 0.5 元/天）；</p>
<p>•<strong>目标</strong>：销售 10 天，实现利润最大化。</p>
<h3><span id="提示">提示：</span></h3><p>•<strong>利润</strong> = 售出商品售价总和 - 售出商品进价总和 - ⽀付仓库的管理费用 - 10天内过期/丢弃商品的进价</p>
<p>•不可使用暴力枚举；</p>
<p>•排序 + 搜索算法等；</p>
<p>•模拟退火、贪心算法、爬山算法等；</p>
<h3><span id="模拟流程">模拟流程:</span></h3><h4><span id="task1">task1：</span></h4><p>•能模拟商家和顾客行为，得到正确收益；</p>
<p>•<strong>输入</strong>：给定10个测试用例，每个测试用例包含三个文件：</p>
<p>{</p>
<p>​        药品文件：50行，包含进价和保质期，药品 id 从 0-49；                                                                                                   策略文件：10 行，每行 10 组数据，每组数据包含 id （-1则空）和定价列表的索引；                                                    丢弃文件：N行，包含天数和药品 id；                                                 </p>
<p>}</p>
<p><strong>注意：丢弃文件需自己计算，将当天未卖出去的药品且下一天就过期（当天未过期）的药品丢掉，丢掉药品的编号和丢弃日期写入丢弃文件，第10天过期且未卖出去的药品也丢弃（第11天丢弃）。</strong></p>
<p>•<strong>输出</strong>：所获利润；</p>
<p>•最好能写在命令行参数中：</p>
<p><em>./drugstore.exe -m ../data/data1/medicine.txt -s ../data/data1/strategy.txt -d delete.txt</em></p>
<h4><span id="task2">task2：</span></h4><p>•自行设计卖药策略，实现<strong>你所认为</strong>的最大收益；</p>
<p>•<strong>输入</strong>：给定10个测试用例（4分/个），每个测试用例包含一个文件：</p>
<p>{药品文件：50行，包含进价和保质期，药品 id 从 0-49；</p>
<p>•<strong>输出：</strong></p>
<p>策略文件、药品丢弃文件（格式同模拟流程所述）及最大收益；</p>
<p>•最好能写在命令行参数中：<strong>（实际可以不需要用命令行参数，因为文件路径之前已经给出了）</strong></p>
<p><em>./drugstore.exe -m ../data/data1/medicine.txt -ws ../data/data1/strategy.txt -wd delete.txt</em></p>
<h3><span id="代码思路">代码思路：</span></h3><p>首先题目的核心是求利润，所以设置贪心策略时，最好能方便利润计算，这里我参考了[学长的思路]<a href="https://blog.csdn.net/DT_Kang/article/details/122316269?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%8D%AF%E5%BA%97%E5%8D%96%E8%8D%AF%E5%A4%A7%E4%BD%9C%E4%B8%9A&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-122316269.142^v100^pc_search_result_base6&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/DT_Kang/article/details/122316269?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%8D%AF%E5%BA%97%E5%8D%96%E8%8D%AF%E5%A4%A7%E4%BD%9C%E4%B8%9A&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-122316269.142^v100^pc_search_result_base6&amp;spm=1018.2226.3001.4187</a> ，使用了10×3的数组（策略数组）来记录每天销售的药品这样先确定当天要卖出的药品，再从剩下的药品中选定上架的药品，为了让利润更高，选择的药品有要求是定价之后（加价6元）比要卖出的药品的定价高，再就是管理费为1元的优先。所以可以将未卖出的药品按过期时间升序排列，依次遍历，如果定价比要卖出的药品高，就选入。为了求得当前策略数组的最高利润，还需要处理要卖出药品的加价，这个可以通过遍历来实现。通过这些处理，可以得到当前策略数组下利润的最大值。</p>
<p>最后就是策略数组的生成和处理：通过贪心生成初始策略数组，通过模拟退火和爬山调整。其中难点就是贪心生成初始策略数组，首先是丢弃药品原则：<strong>丢掉的药品尽可能少、丢弃最便宜的药品</strong>，围绕这两条原则来设计贪心策略：为了丢弃药品尽可能少，把药品按过期时间升序排列，依次选取当天未过期的药品，（证明：丢弃药品的原因只能是<strong>药品未卖出去且药品过期不得不丢</strong>，如果在此排列下有药品丢弃，那么该药品当天过期且未卖出去，在该药品之前的所有药品都与其交换也会因为过期而丢弃，所以丢弃药品种数不会更少），每天选三种，为了实现丢弃最便宜的药品，把同一天过期的药品降序排列，这样按选取药品的顺序会选择贵的药品。这就是贪心策略的设计，再就是退火和爬山，原理就是随机交换卖出的药品和未卖出且未丢弃的药品，或者卖出的药品，如果合法，计算利润，退火中如果该利润比原利润高，就接受这个新策略，否则按一定概率接受这个解（跳出局部最优解，寻找全局最优），爬山中只有该利润比原利润高时接受新策略。</p>
<p><strong>补充一点：如果一种药品最终会被丢弃，为实现最高利润，第0天就将其丢弃。</strong></p>
<p>证明：因为只有贪心策略涉及到了丢弃药品，所以当前策略为贪心策略（前提条件），如果一种药品最终会被丢弃，那么在该药品过期的日期前卖出的药品价格都<strong>比该药品高</strong>，而且该药品不会卖出，只能在过期前放在药架上或者仓库里，放在药架上，为了策略中要卖出的药品正常卖出，要卖出的药品加价变少，降低利润，放在药架上只会产生管理费，降低利润，所以最好刚开始就丢弃。</p>
<p>思路到这里就比较完善了，最后就是计算利润的函数，这个函数需要根据10×3的策略数组自动生成10×10×2的销售策略，并计算出利润，具体过程在上文已提及。</p>
<h3><span id="优化">优化：</span></h3><p><strong>速度优化：</strong>通过前几次运行的结果，最高利润时上架药品的加价策略只有+4和＋6两种，所以为了给程序加速，在遍历要卖出药品加价的循环中，我做了如下修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d1 = <span class="number">0</span>; d1 &lt; <span class="number">7</span> ; d1++)<span class="comment">//d1,d2,d3决定当天要卖出的三种药品加价</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> d2 = <span class="number">0</span>; d2 &lt; <span class="number">7</span> ; d2++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> d3 = <span class="number">0</span>; d3 &lt; <span class="number">7</span> ; d3++) </span><br><span class="line"></span><br><span class="line"><span class="comment">//中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d1 = <span class="number">5</span>; d1 &lt; <span class="number">7</span> ; d1++)<span class="comment">//d1,d2,d3决定当天要卖出的三种药品加价</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> d2 = <span class="number">5</span>; d2 &lt; <span class="number">7</span> ; d2++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> d3 = <span class="number">5</span>; d3 &lt; <span class="number">7</span> ; d3++) </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里出现了问题：第六组数据运行结果在加价只能为6的情况下最高利润为41，在加价为4或6的情况下最高利润</span></span><br><span class="line"><span class="comment">为39.5，查看策略文件，发现加价都是6，（这两组数据的退火次数相同），我将退货次数增加为原先的10倍，依然   是39.5，可能是次数不够，但运行时间已经很长了，所以我进行了下面的二次改进。       </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//后</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> d1 = <span class="number">6</span>; d1 &gt; <span class="number">0</span> &amp;&amp; no &lt; <span class="number">8</span>; d1--)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">no记录了当天放到药架上的药品数，当某种要卖出的药品加价从6降为4时，利润-2，</span></span><br><span class="line"><span class="comment">只有减少的仓库管理费多于2时，利润才会更高，所以至少需要三种药品新上架，</span></span><br><span class="line"><span class="comment">也就是之前药架上的药品数最多为7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> d2 = <span class="number">6</span>; d2 &gt; <span class="number">0</span> &amp;&amp; no &lt; <span class="number">8</span>; d2--)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> d3 = <span class="number">6</span>; d3 &gt; <span class="number">0</span> &amp;&amp; no &lt; <span class="number">8</span>; d3--)</span><br></pre></td></tr></table></figure>
<p><strong>结果优化：</strong>退火过程中，我设置了两个中间策略数组midHaveSold, midHaveSold1（记录10天里每天卖哪三种药品），而记录最优策略的数组haveSold只会在解更优时更新，否则不变，这样可以避免haveSold退火最后跳入局部最优解的情况（我没有实际测试，不确定是否有用）。</p>
<h3><span id="变量及函数说明">变量及函数说明：</span></h3><div class="table-container">
<table>
<thead>
<tr>
<th>变量名称</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>change[]</td>
<td>记录定价</td>
</tr>
<tr>
<td>teProfit</td>
<td>教辅利润</td>
</tr>
<tr>
<td>myProfit</td>
<td>记录最高利润</td>
</tr>
<tr>
<td>midProfit,midProfit1</td>
<td>退火过程中间利润</td>
</tr>
<tr>
<td>midProfit2</td>
<td>遍历加价过程利润</td>
</tr>
<tr>
<td>strategy[10][10][2]</td>
<td>记录教辅策略</td>
</tr>
<tr>
<td>mystrategy[10][10][2]</td>
<td>记录最佳策略</td>
</tr>
<tr>
<td>midstrategy[10][10][2],midstrategy1[10][10][2]</td>
<td>退火过程中间策略</td>
</tr>
<tr>
<td>midstrategy2[10][10][2]</td>
<td>遍历加价过程中间策略</td>
</tr>
<tr>
<td>haveSold[10][3]</td>
<td>最佳卖出药品策略</td>
</tr>
<tr>
<td>midHaveSold[10][3],midHaveSold1[10][3]</td>
<td>退火过程卖出药品策略</td>
</tr>
<tr>
<td>indexs1[30],misindexs1[50]</td>
<td>退火过程中卖出与未卖出的药品</td>
</tr>
<tr>
<td>D[10]</td>
<td>选定教辅策略中每天卖出的三种药品</td>
</tr>
</tbody>
</table>
</div>
<p>药品信息的记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">drug</span> &#123;</span><br><span class="line">	<span class="type">int</span> day;			<span class="comment">//保质期</span></span><br><span class="line">	<span class="type">double</span> value;			<span class="comment">//进价</span></span><br><span class="line">	<span class="type">double</span> deltava;			<span class="comment">//原本记录药品加价用，但因为销售策略数组记录加价，基本没用到</span></span><br><span class="line">	<span class="type">int</span> in;					<span class="comment">//是否在仓库</span></span><br><span class="line">	<span class="type">int</span> away;				<span class="comment">//是否扔掉</span></span><br><span class="line">	<span class="type">int</span> sold;				<span class="comment">//是否卖出</span></span><br><span class="line">	<span class="type">int</span> id;					<span class="comment">//药品编号，卖药过程会有排序，改变药品位置</span></span><br><span class="line">&#125; drugs[<span class="number">50</span>];</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>bool read(int argc, char** argv);</td>
<td>读文件</td>
</tr>
<tr>
<td>void print(char** argv);</td>
<td>写文件</td>
</tr>
<tr>
<td>void getProfit();</td>
<td>求教辅利润</td>
</tr>
<tr>
<td>void greedy();</td>
<td>贪心生成初始解</td>
</tr>
<tr>
<td>double frand() { return 1.0 * rand() / RAND_MAX; }</td>
<td>生成随机数</td>
</tr>
<tr>
<td>void SA();</td>
<td>退火</td>
</tr>
<tr>
<td>void adjust();</td>
<td>调整退火解</td>
</tr>
<tr>
<td>void calculate();</td>
<td>根据10×3的策略数组补全销售策略并计算利润</td>
</tr>
<tr>
<td>void Init();</td>
<td>初始化药品信息</td>
</tr>
</tbody>
</table>
</div>
<h3><span id="代码">代码:</span></h3><p>[read(),print()函数参考][<a href="https://github.com/Lane0218/Drugstore">https://github.com/Lane0218/Drugstore</a>]</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> change[] = &#123; <span class="number">-1.5</span>,<span class="number">-1</span>,<span class="number">-0.5</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">double</span> teProfit = <span class="number">0</span>, myProfit = <span class="number">-1111</span>, midProfit = <span class="number">-1111</span>, midProfit1,midProfit2;</span><br><span class="line"><span class="comment">//第0天晚上把所有不会卖出去的药品都丢掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>;<span class="comment">//读文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span>** argv)</span></span>;	<span class="comment">//写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getProfit</span><span class="params">()</span></span>;			<span class="comment">//计算教辅收益</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greedy</span><span class="params">()</span></span>;				<span class="comment">//贪心生成初始解</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">frand</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1.0</span> * <span class="built_in">rand</span>() / RAND_MAX; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span></span>;					<span class="comment">//退火</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">()</span></span>;				<span class="comment">//调整退火解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>;			<span class="comment">//计算利润</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> strategy[<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>], mystrategy[<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>], midstrategy[<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>], midstrategy1[<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>],midstrategy2[<span class="number">10</span>][<span class="number">10</span>][<span class="number">2</span>];<span class="comment">//贪心过程中间策略</span></span><br><span class="line"><span class="type">int</span> haveSold[<span class="number">10</span>][<span class="number">3</span>], midHaveSold[<span class="number">10</span>][<span class="number">3</span>], midHaveSold1[<span class="number">10</span>][<span class="number">3</span>];<span class="comment">//记录排序后的编号,而不是初始编号</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> dele[<span class="number">50</span>][<span class="number">2</span>];		<span class="comment">//删除0</span></span><br><span class="line"><span class="type">int</span> indexs1[<span class="number">30</span>], misindex1[<span class="number">50</span>];		<span class="comment">//中间过程</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">drug</span> &#123;</span><br><span class="line">	<span class="type">int</span> day;				<span class="comment">//保质期</span></span><br><span class="line">	<span class="type">double</span> value;			<span class="comment">//进价</span></span><br><span class="line">	<span class="type">double</span> deltava;			<span class="comment">//原本记录药品加价用，但因为销售策略数组记录加价，基本没用到</span></span><br><span class="line">	<span class="type">int</span> in;					<span class="comment">//是否在仓库</span></span><br><span class="line">	<span class="type">int</span> away;				<span class="comment">//是否扔掉</span></span><br><span class="line">	<span class="type">int</span> sold;				<span class="comment">//是否卖出</span></span><br><span class="line">	<span class="type">int</span> id;					<span class="comment">//药品编号，卖药过程会有排序，改变药品位置</span></span><br><span class="line">&#125; drugs[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dNode</span> &#123;</span><br><span class="line">	drug* d;</span><br><span class="line">	<span class="type">double</span> value;</span><br><span class="line">&#125;D[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> re = <span class="built_in">read</span>(argc, argv);</span><br><span class="line">	<span class="keyword">if</span> (!re)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="built_in">getProfit</span>();</span><br><span class="line">	<span class="built_in">greedy</span>();</span><br><span class="line">	<span class="built_in">SA</span>();</span><br><span class="line">	<span class="built_in">print</span>(argv);</span><br><span class="line"><span class="comment">//	cout &lt;&lt; endl &lt;&lt; myProfit;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">read</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">7</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Lack file&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="number">4</span>) &#123;</span><br><span class="line">		string jud = argv[i];</span><br><span class="line">		<span class="keyword">if</span> (jud == <span class="string">&quot;-m&quot;</span>) &#123;</span><br><span class="line">			FILE* fp = <span class="built_in">fopen</span>(argv[++i], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (!fp)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">50</span>; n++) &#123;</span><br><span class="line">				<span class="built_in">fscanf</span>(fp, <span class="string">&quot;%lf\t%d\n&quot;</span>, &amp;drugs[n].value, &amp;drugs[n].day);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fclose</span>(fp);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (jud == <span class="string">&quot;-s&quot;</span>) &#123;</span><br><span class="line">			FILE* fp1 = <span class="built_in">fopen</span>(argv[++i], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (!fp1)</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">					<span class="built_in">fscanf</span>(fp1, <span class="string">&quot;%d,%d\t&quot;</span>, &amp;strategy[k][j][<span class="number">0</span>], &amp;strategy[k][j][<span class="number">1</span>]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">fclose</span>(fp1);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//		else if (jud == &quot;-d&quot;) &#123;</span></span><br><span class="line">		<span class="comment">//			FILE* fp2 = fopen(argv[++i], &quot;r&quot;);</span></span><br><span class="line">		<span class="comment">//			if (!fp2)</span></span><br><span class="line">		<span class="comment">//				return 0;</span></span><br><span class="line">		<span class="comment">//			/*int n;</span></span><br><span class="line">		<span class="comment">//			fscanf(fp2, &quot;%d&quot;, &amp;n);</span></span><br><span class="line">		<span class="comment">//			for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">		<span class="comment">//				fscanf(fp2, &quot;%d%d&quot;, &amp;dele[i][0], &amp;dele[i][1]);</span></span><br><span class="line">		<span class="comment">//			&#125;*/</span></span><br><span class="line">		<span class="comment">//			int n = 0;</span></span><br><span class="line">		<span class="comment">//			while (fscanf(fp2, &quot;%d%d&quot;, &amp;dele[n][0], &amp;dele[n++][1])!=EOF) &#123;</span></span><br><span class="line">		<span class="comment">//				;</span></span><br><span class="line">		<span class="comment">//			&#125;</span></span><br><span class="line">		<span class="comment">//			fclose(fp2);</span></span><br><span class="line">		<span class="comment">//			i++;</span></span><br><span class="line">		<span class="comment">//		&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	string filePath = <span class="built_in">string</span>(argv[<span class="number">4</span>]);</span><br><span class="line">	string fileName1 = filePath.<span class="built_in">substr</span>(<span class="number">0</span>, filePath.<span class="built_in">length</span>() - <span class="number">12</span>) + <span class="string">&quot;mystrategy.txt&quot;</span>;</span><br><span class="line">	string fileName2 = filePath.<span class="built_in">substr</span>(<span class="number">0</span>, filePath.<span class="built_in">length</span>() - <span class="number">12</span>) + <span class="string">&quot;mydelete.txt&quot;</span>;</span><br><span class="line">	string fileName3 = filePath.<span class="built_in">substr</span>(<span class="number">0</span>, filePath.<span class="built_in">length</span>() - <span class="number">12</span>) + <span class="string">&quot;result.txt&quot;</span>;</span><br><span class="line">	string fileName4 = filePath.<span class="built_in">substr</span>(<span class="number">0</span>, filePath.<span class="built_in">length</span>() - <span class="number">12</span>) + <span class="string">&quot;delete.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">	FILE* file1 = <span class="built_in">fopen</span>(fileName1.<span class="built_in">c_str</span>(), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mystrategy[i][j][<span class="number">0</span>]!=<span class="number">-1</span>)</span><br><span class="line">				<span class="built_in">fprintf</span>(file1, <span class="string">&quot;%d,%d\t&quot;</span>, drugs[mystrategy[i][j][<span class="number">0</span>]].id, mystrategy[i][j][<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">fprintf</span>(file1, <span class="string">&quot;-1,6\t&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(file1, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(file1);</span><br><span class="line"></span><br><span class="line">	FILE* file2 = <span class="built_in">fopen</span>(fileName2.<span class="built_in">c_str</span>(), <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drugs[i].away == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(file2, <span class="string">&quot;0\t%d\n&quot;</span>, drugs[i].id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(file2);</span><br><span class="line"></span><br><span class="line">	FILE* file3 = <span class="built_in">fopen</span>(fileName3.<span class="built_in">c_str</span>(), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(file3, <span class="string">&quot;教辅:%g\n我的:%g\n&quot;</span>, teProfit, myProfit);</span><br><span class="line">	<span class="built_in">fclose</span>(file3);</span><br><span class="line"></span><br><span class="line">	FILE* file4 = <span class="built_in">fopen</span>(fileName4.<span class="built_in">c_str</span>(), <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (dele[k][<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(file4, <span class="string">&quot;%d\t%d\n&quot;</span>, dele[k][<span class="number">0</span>], dele[k][<span class="number">1</span>]);</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fclose</span>(file4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		drugs[i].sold = <span class="number">0</span>;</span><br><span class="line">		drugs[i].away = <span class="number">0</span>;</span><br><span class="line">		drugs[i].in = <span class="number">1</span>;</span><br><span class="line">		drugs[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getProfit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">			dele[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> indexx = <span class="number">0</span>;					<span class="comment">//记录扔掉药品的数量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">			drugs[j].in = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;	<span class="comment">//输入策略</span></span><br><span class="line">			<span class="keyword">if</span> (strategy[i][j][<span class="number">0</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">				D[j].value = drugs[strategy[i][j][<span class="number">0</span>]].value + change[strategy[i][j][<span class="number">1</span>]];</span><br><span class="line">				D[j].d = &amp;drugs[strategy[i][j][<span class="number">0</span>]];</span><br><span class="line">				drugs[strategy[i][j][<span class="number">0</span>]].in = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				D[j].value = <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找三个，算值并处理，最小且保质期最长</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (D[j].value &gt; D[k].value) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(D[j], D[k]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (D[j].value == D[k].value &amp;&amp; D[j].value != <span class="number">100</span> &amp;&amp; D[j].d-&gt;day &lt; D[k].d-&gt;day) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(D[j], D[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (D[j].value != <span class="number">100</span>) &#123;</span><br><span class="line">				teProfit += (D[j].value - D[j].d-&gt;value);</span><br><span class="line">				D[j].d-&gt;sold = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理丢弃</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (drugs[j].sold == <span class="number">0</span> &amp;&amp; drugs[j].day == i &amp;&amp; drugs[j].away == <span class="number">0</span>) &#123;<span class="comment">//day==i</span></span><br><span class="line">				drugs[j].away = <span class="number">1</span>;</span><br><span class="line">				teProfit -= drugs[j].value;</span><br><span class="line">				dele[indexx][<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">				dele[indexx++][<span class="number">1</span>] = drugs[j].id;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//仓库管理费：sold=0并且in=1并且away=0</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (drugs[j].away == <span class="number">0</span> &amp;&amp; drugs[j].in == <span class="number">1</span> &amp;&amp; drugs[j].sold == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (drugs[j].day - i &lt;= <span class="number">5</span>)</span><br><span class="line">					teProfit -= <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					teProfit -= <span class="number">0.5</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drugs[j].sold == <span class="number">0</span> &amp;&amp; drugs[j].day == <span class="number">10</span> &amp;&amp; drugs[j].away == <span class="number">0</span>) &#123;<span class="comment">//day==i</span></span><br><span class="line">			drugs[j].away = <span class="number">1</span>;</span><br><span class="line">			teProfit -= drugs[j].value;</span><br><span class="line">			dele[indexx][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">			dele[indexx++][<span class="number">1</span>] = drugs[j].id;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greedy</span><span class="params">()</span> </span>&#123;<span class="comment">//为方便查找，记录排序后的位置，初始位置有id记录,只需要得出一个10×3的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;<span class="comment">//不扔</span></span><br><span class="line">		drugs[i].deltava = <span class="number">6</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Init</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">49</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (drugs[j].day &lt; drugs[i].day) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(drugs[i], drugs[j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (drugs[j].day == drugs[i].day &amp;&amp; drugs[j].value &lt; drugs[i].value) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(drugs[i], drugs[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			haveSold[i][j] = <span class="number">-1</span>;</span><br><span class="line">			midHaveSold[i][j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> index[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">		<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;<span class="comment">//确定每天卖哪三种</span></span><br><span class="line">			<span class="keyword">if</span> (drugs[j].day - i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; drugs[j].sold == <span class="number">0</span> &amp;&amp; num&lt;<span class="number">3</span>) &#123;</span><br><span class="line">				index[<span class="number">0</span>] = index[<span class="number">1</span>];</span><br><span class="line">				index[<span class="number">1</span>] = index[<span class="number">2</span>];</span><br><span class="line">				index[<span class="number">2</span>] = j;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把这三种标记出来,记在index[]中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (index[j] != <span class="number">-1</span>) &#123;</span><br><span class="line">				drugs[index[j]].sold = <span class="number">1</span>;</span><br><span class="line">				haveSold[i][j] = index[j];		<span class="comment">//贪心初始化haveSold与midHaveSold</span></span><br><span class="line">				midHaveSold[i][j] = index[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//标记需要丢的药,存疑，第10天晚上过期的丢不丢？暂定为丢</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drugs[i].day &lt;= <span class="number">10</span> &amp;&amp; drugs[i].sold == <span class="number">0</span>) &#123;</span><br><span class="line">			drugs[i].away = <span class="number">1</span>;					<span class="comment">//drugs[i]将会被丢弃</span></span><br><span class="line">			<span class="type">int</span> indexx, indexy;</span><br><span class="line">			<span class="type">double</span> minvalue = <span class="number">31</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; drugs[i].day; j++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (drugs[midHaveSold[j][k]].value &lt; minvalue) &#123;</span><br><span class="line">						indexx = j;</span><br><span class="line">						indexy = k;</span><br><span class="line">						minvalue = drugs[midHaveSold[j][k]].value;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//保证丢的药品最便宜</span></span><br><span class="line">			<span class="keyword">if</span> (drugs[i].away &amp;&amp; minvalue &lt; drugs[i].value) &#123;</span><br><span class="line">				drugs[midHaveSold[indexx][indexy]].away = <span class="number">1</span>;</span><br><span class="line">				midHaveSold[indexx][indexy] = i;</span><br><span class="line">				haveSold[indexx][indexy] = i;</span><br><span class="line">				drugs[i].away = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;<span class="comment">/* 根据midHaveSold生成策略midstrategy,并计算利润midProfit */</span></span><br><span class="line">	midProfit = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		drugs[i].deltava = <span class="number">6</span>;</span><br><span class="line">		drugs[i].sold = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (drugs[i].away == <span class="number">1</span>)</span><br><span class="line">			midProfit -= drugs[i].value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">			midstrategy2[i][j][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">			midstrategy2[i][j][<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//判断是否合法</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (midHaveSold[i][j] != <span class="number">-1</span>)</span><br><span class="line">				drugs[midHaveSold[i][j]].sold = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (drugs[j].away == <span class="number">0</span> &amp;&amp; drugs[j].sold == <span class="number">0</span>) &#123;</span><br><span class="line">			misindex1[j] = j;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			misindex1[j] = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//卖出的药品</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">			indexs1[i * <span class="number">3</span> + j] = midHaveSold[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//生成每天的strategy，一天天处理，每天都采用利润最大的加价策略</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;<span class="comment">//缺陷，不能处理每天能摆放到药架上的药品数量少于3种的情况</span></span><br><span class="line">		midstrategy2[i][<span class="number">0</span>][<span class="number">0</span>] = midHaveSold[i][<span class="number">0</span>];</span><br><span class="line">		midstrategy2[i][<span class="number">1</span>][<span class="number">0</span>] = midHaveSold[i][<span class="number">1</span>];</span><br><span class="line">		midstrategy2[i][<span class="number">2</span>][<span class="number">0</span>] = midHaveSold[i][<span class="number">2</span>];</span><br><span class="line">		midProfit2 = <span class="number">0</span>;		<span class="comment">//遍历加价时当天利润值</span></span><br><span class="line">		<span class="type">double</span> maxP = <span class="number">-100</span>;	<span class="comment">//记录当天利润最大值</span></span><br><span class="line">		<span class="type">int</span> n = <span class="number">0</span>;	<span class="comment">//辅助构建mid数组</span></span><br><span class="line">		<span class="type">int</span> mid[<span class="number">50</span>];<span class="comment">//记录当天所有没卖出而且没丢掉的药品</span></span><br><span class="line">		<span class="type">int</span> no = <span class="number">0</span>;	<span class="comment">//记录当天摆在药架上的药品的数量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">3</span> * (i + <span class="number">1</span>); j &lt; <span class="number">30</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (indexs1[j] != <span class="number">-1</span>)mid[n++] = indexs1[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (drugs[j].away == <span class="number">0</span> &amp;&amp; drugs[j].sold == <span class="number">0</span>) &#123;</span><br><span class="line">				mid[n++] = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按过期时间排序,升序，以供选择</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (drugs[mid[j]].day &gt; drugs[mid[k]].day) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(mid[j], mid[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> d1 = <span class="number">6</span>; d1 &gt; <span class="number">0</span> &amp;&amp; no &lt; <span class="number">8</span>; d1--) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			no记录了当天放到药架上的药品数，当某种要卖出的药品加价从6降为4时，利润-2，</span></span><br><span class="line"><span class="comment">			只有减少的仓库管理费多于2时，利润才会更高，所以至少需要三种药品新上架，</span></span><br><span class="line"><span class="comment">			也就是之前药架上的药品数最多为7</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> d2 = <span class="number">6</span>; d2 &gt; <span class="number">0</span> &amp;&amp; no &lt; <span class="number">8</span>; d2--) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> d3 = <span class="number">6</span>; d3 &gt; <span class="number">0</span> &amp;&amp; no &lt; <span class="number">8</span>; d3--) &#123;</span><br><span class="line">					<span class="type">double</span> maxD = ((drugs[midHaveSold[i][<span class="number">0</span>]].value + change[d1]) &gt; (drugs[midHaveSold[i][<span class="number">1</span>]].value + change[d2])) ? (drugs[midHaveSold[i][<span class="number">0</span>]].value + change[d1]) : (drugs[midHaveSold[i][<span class="number">1</span>]].value + change[d2]);</span><br><span class="line">					maxD = (maxD &gt; (drugs[midHaveSold[i][<span class="number">2</span>]].value + change[d3])) ? maxD : (drugs[midHaveSold[i][<span class="number">2</span>]].value + change[d3]);</span><br><span class="line">					midstrategy2[i][<span class="number">0</span>][<span class="number">1</span>] = d1;</span><br><span class="line">					midstrategy2[i][<span class="number">1</span>][<span class="number">1</span>] = d2;</span><br><span class="line">					midstrategy2[i][<span class="number">2</span>][<span class="number">1</span>] = d3;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">50</span>; k++) &#123;</span><br><span class="line">						drugs[k].in = <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					midProfit2 = (change[d1] + change[d2] + change[d3]);</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (midHaveSold[i][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">							drugs[midHaveSold[i][j]].in = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					no = <span class="number">3</span>;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (mid[j] != <span class="number">-1</span> &amp;&amp; no&lt;<span class="number">10</span> &amp;&amp; (drugs[mid[j]].value + <span class="number">6</span>)&gt;maxD) &#123;<span class="comment">//缺陷</span></span><br><span class="line">							midstrategy2[i][no][<span class="number">0</span>] = mid[j];</span><br><span class="line">							midstrategy2[i][no][<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">							no++;</span><br><span class="line">							drugs[mid[j]].in = <span class="number">0</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> j = no; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">						midstrategy2[i][j][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">						midstrategy2[i][j][<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (drugs[mid[j]].in == <span class="number">1</span> &amp;&amp; drugs[mid[j]].day - i &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">							midProfit2 -= <span class="number">1</span>;<span class="comment">//仓库管理费</span></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (drugs[mid[j]].in == <span class="number">1</span> &amp;&amp; drugs[mid[j]].day - i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">							midProfit2 -= <span class="number">0.5</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (midProfit2 &gt;= maxP) &#123;</span><br><span class="line">						maxP = midProfit2;<span class="comment">//更新中间销售策略数组</span></span><br><span class="line">						<span class="keyword">for</span> (<span class="type">int</span> nn = <span class="number">0</span>; nn &lt; <span class="number">10</span>; nn++) &#123;</span><br><span class="line">							midstrategy[i][nn][<span class="number">0</span>] = midstrategy2[i][nn][<span class="number">0</span>];</span><br><span class="line">							midstrategy[i][nn][<span class="number">1</span>] = midstrategy2[i][nn][<span class="number">1</span>];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		midProfit += maxP;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">rand</span>() % <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">int</span> opt = <span class="built_in">rand</span>() % <span class="number">4</span>;</span><br><span class="line">			<span class="keyword">if</span> (opt == <span class="number">0</span>) &#123;<span class="comment">//卖出的药品与未卖出且未丢弃的药品交换</span></span><br><span class="line">				<span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">10</span>, y = <span class="built_in">rand</span>() % <span class="number">3</span>, z = <span class="built_in">rand</span>() % <span class="number">50</span>;</span><br><span class="line">				<span class="keyword">if</span> (drugs[misindex1[z]].away == <span class="number">0</span> &amp;&amp; drugs[midHaveSold[x][y]].day &gt;= <span class="number">10</span> &amp;&amp; drugs[misindex1[z]].day &gt; x) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(midHaveSold[x][y], misindex1[z]);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//卖出的药品相互交换</span></span><br><span class="line">				<span class="type">int</span> x = <span class="built_in">rand</span>() % <span class="number">10</span>, y = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">				<span class="type">int</span> u = <span class="built_in">rand</span>() % <span class="number">10</span>, v = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">if</span> (drugs[midHaveSold[x][y]].day &gt; u &amp;&amp; drugs[midHaveSold[u][v]].day &gt; x) &#123;<span class="comment">//没过期</span></span><br><span class="line">					<span class="built_in">swap</span>(midHaveSold[x][y], midHaveSold[u][v]);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> T = <span class="number">100000</span>;</span><br><span class="line">	<span class="built_in">calculate</span>();</span><br><span class="line">	myProfit = midProfit;</span><br><span class="line">	midProfit1 = midProfit;</span><br><span class="line">	cout &lt;&lt; teProfit &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; myProfit &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">memcpy</span>(midHaveSold1, haveSold, <span class="built_in">sizeof</span>(haveSold));</span><br><span class="line">	<span class="keyword">while</span> (T &gt; <span class="number">0.000001</span>) &#123;</span><br><span class="line">		<span class="built_in">adjust</span>();</span><br><span class="line">		<span class="built_in">calculate</span>();</span><br><span class="line">		<span class="type">double</span> delta = midProfit1 - midProfit;</span><br><span class="line">		<span class="keyword">if</span> (delta &lt; <span class="number">0</span> || <span class="built_in">exp</span>(delta / T) &lt; <span class="built_in">frand</span>()) &#123;</span><br><span class="line">			midProfit1 = midProfit;</span><br><span class="line">			<span class="built_in">memcpy</span>(midHaveSold1, midHaveSold, <span class="built_in">sizeof</span>(midHaveSold));</span><br><span class="line">			<span class="keyword">if</span> (myProfit - midProfit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(mystrategy, midstrategy, <span class="built_in">sizeof</span>(midstrategy));</span><br><span class="line">				myProfit = midProfit;</span><br><span class="line">				<span class="built_in">memcpy</span>(haveSold, midHaveSold, <span class="built_in">sizeof</span>(midHaveSold));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;<span class="comment">//退回midHaveSold的修改</span></span><br><span class="line">			<span class="built_in">memcpy</span>(midHaveSold, midHaveSold1, <span class="built_in">sizeof</span>(midHaveSold1));</span><br><span class="line">		&#125;</span><br><span class="line">		T *= <span class="number">0.9999</span>;<span class="comment">//除第7组数据外0.9999够了，第7组0.99999</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">double</span> i = <span class="number">1</span>; i &lt;= <span class="number">5000</span>; i++) &#123;</span><br><span class="line">		<span class="comment">/*爬山，实际上不爬山利润也不会改变，可能是退火次数足够,是利润达到了最优解*/</span></span><br><span class="line">		<span class="built_in">adjust</span>();</span><br><span class="line">		<span class="built_in">calculate</span>();</span><br><span class="line">		<span class="keyword">if</span> (midProfit &gt; myProfit) &#123;</span><br><span class="line">			<span class="built_in">memcpy</span>(mystrategy, midstrategy, <span class="built_in">sizeof</span>(midstrategy));</span><br><span class="line">			myProfit = midProfit;</span><br><span class="line">			<span class="built_in">memcpy</span>(haveSold, midHaveSold, <span class="built_in">sizeof</span>(midHaveSold));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">////打印策略</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line">	<span class="comment">//	for (int j = 0; j &lt; 10; j++) &#123;</span></span><br><span class="line">	<span class="comment">//		cout &lt;&lt; drugs[mystrategy[i][j][0]].id &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">	<span class="comment">//	&#125;</span></span><br><span class="line">	<span class="comment">//	cout &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	cout &lt;&lt; myProfit &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* by answerzang */</span></span><br></pre></td></tr></table></figure>
<h3><span id="实验结果">实验结果：</span></h3><div class="table-container">
<table>
<thead>
<tr>
<th>数据</th>
<th>task1教辅解</th>
<th>task2教辅解</th>
<th>贪心解</th>
<th>本实验最优解</th>
</tr>
</thead>
<tbody>
<tr>
<td>data1</td>
<td>-181.5</td>
<td>33.5</td>
<td>27.5</td>
<td>45.5</td>
</tr>
<tr>
<td>data2</td>
<td>-254.868</td>
<td>35.5</td>
<td>28.5</td>
<td>44.5</td>
</tr>
<tr>
<td>data3</td>
<td>-254.003</td>
<td>34.5</td>
<td>32</td>
<td>45.5</td>
</tr>
<tr>
<td>data4</td>
<td>-349.851</td>
<td>36.5</td>
<td>33</td>
<td>42.5</td>
</tr>
<tr>
<td>data5</td>
<td>-352.729</td>
<td>32</td>
<td>22</td>
<td>41.5</td>
</tr>
<tr>
<td>data6</td>
<td>-426.686</td>
<td>28</td>
<td>23.5</td>
<td>41</td>
</tr>
<tr>
<td>data7</td>
<td>-441.313</td>
<td>25.5</td>
<td>21.5</td>
<td>36.5</td>
</tr>
<tr>
<td>data8</td>
<td>-442.978</td>
<td>10.5</td>
<td>10.5</td>
<td>32</td>
</tr>
<tr>
<td>data9</td>
<td>-506.275</td>
<td>-2.4</td>
<td>-8.9312</td>
<td>7.0688</td>
</tr>
<tr>
<td>data10</td>
<td>-557.288</td>
<td>-12.26</td>
<td>-23.2548</td>
<td>-11.7548</td>
</tr>
</tbody>
</table>
</div>
<p>本文的贪心函数并不优秀，<strong>原因如下：</strong></p>
<p>原先贪心策略中药品排列方式是按天数升序排列，天数相同就按价格升序，然后一天一天选入贪心策略的三种药品，但第十组数据有问题，因为第3天把过期时间为4的最便宜的两种药品选中并卖出了（选最便宜的是为了摆更多药品），第4天过期的药品还剩下4种，就只能卖3，丢1，丢掉的一个并不是当天过期的最便宜的药品，所以改成了按价格降序排药品，这样丢弃的就会是当天最便宜的药品（但之前卖出的药品中可能会有更便宜的），因为这样的策略先选了贵的药品，所以相较于之前先选便宜的，能摆在架子上的药品少了，而且前几天都基本不丢药，新贪心策略的利润就不如之前的贪心策略，但是退火调整后，利润会比之前的策略高，之后我在代码中加了一个不严谨的补丁（处理丢弃药品时判断之前卖出去的药品里是否有比其更便宜的），对贪心的结果也不会有太大影响。</p>
<h3><span id="总结与分析">总结与分析：</span></h3><p>个人感觉有两点比较难处理，或者说比较重要，一是贪心策略的设置，二是其中用到的各种数组的处理以及初始化，以及考虑一些极端情况（虽然测试数据里并没有极端的例子），贪心策略不能只考虑贪心解，还要考虑后面的退火和爬山。这个大作业的结构有些复杂，思路比较难找，而且即使确定了思路，代码的编写也比较困难，总之这次大作业还是挺难的，但好在我写代码的那几天自习比较多，思路也比较连贯，堆时间解决这次大作业。</p>
<p>我对实验的结果比较满意，身边同学的代码以及学长的代码都没有跑出更优的解（大概率是全局最优解），虽然退火的随机性比较高，但我跑了很多次，结果不变（甚至我把爬山去掉后结果仍不变），可能的解释是退火的次数在足够多，找到了全局最优解。</p>
<p>最后一点分析是我的丢药策略是丢便宜的，有时可能丢更贵的药品效果更好，此时丢掉更贵的药能使更多药品被放在药架上，而且减少的管理费要比贵的药品与便宜的药品的价格差高，这种情况可能性比较小，而且测试数据中，最多丢1种药品，人工检查后发现丢便宜的药与丢贵的药对管理费的影响不大，当然这只是对测试集而言，改进的方法，我认为可以在退火时加入丢弃药品与预定卖出药品的随机交换，但是我未实践。</p>
<p>[我的数据集][<a href="https://github.com/answerzang/drugstore/tree/master">https://github.com/answerzang/drugstore/tree/master</a>]</p>
<h3><span id="补充">补充！！！</span></h3><p>后来想了想，不差这点时间了，遂把程序修改了，具体就是：1.药品排列顺序日期同则按价格升，这样可以得到更优的贪心解，2.为了确保丢掉药品的价格最低，在丢药（贪心时遍历药品，保质期小于等于10且sold变量为0的丢掉）时，遍历所有在其过期的日期前卖出的药品，找价格最低的，并记录位置，遍历完比较，把二者价低的丢掉。</p>
<p>新的实验结果如下（程序在上面更新了），贪心解均比之前那组高，在我意料之外的是第10组数据的最优解比之前高了0.5，理论上应该相同，可能是因为之前退火次数不够，</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据</th>
<th>task1教辅解</th>
<th>task2教辅解</th>
<th>贪心解</th>
<th>本实验最优解</th>
</tr>
</thead>
<tbody>
<tr>
<td>data1</td>
<td>-181.5</td>
<td>33.5</td>
<td>33.5</td>
<td>45.5</td>
</tr>
<tr>
<td>data2</td>
<td>-254.868</td>
<td>35.5</td>
<td>35.5</td>
<td>44.5</td>
</tr>
<tr>
<td>data3</td>
<td>-254.003</td>
<td>34.5</td>
<td>36</td>
<td>45.5</td>
</tr>
<tr>
<td>data4</td>
<td>-349.851</td>
<td>36.5</td>
<td>36.5</td>
<td>42.5</td>
</tr>
<tr>
<td>data5</td>
<td>-352.729</td>
<td>32</td>
<td>33</td>
<td>41.5</td>
</tr>
<tr>
<td>data6</td>
<td>-426.686</td>
<td>28</td>
<td>28</td>
<td>41</td>
</tr>
<tr>
<td>data7</td>
<td>-441.313</td>
<td>25.5</td>
<td>29</td>
<td>36.5</td>
</tr>
<tr>
<td>data8</td>
<td>-442.978</td>
<td>10.5</td>
<td>13.5</td>
<td>32</td>
</tr>
<tr>
<td>data9</td>
<td>-506.275</td>
<td>-2.4</td>
<td>0.0688</td>
<td>7.0688</td>
</tr>
<tr>
<td>data10</td>
<td>-557.288</td>
<td>-12.26</td>
<td>-16.2548</td>
<td>-11.2548</td>
</tr>
</tbody>
</table>
</div>
<p>还有就是跑得慢了。</p>
]]></content>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL安装配置</title>
    <url>/2025/02/17/WSL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>电脑版本：win11专业版，有hyper-V</p>
<p>以管理员方式打开power shell 并运行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure>
<p>两条命令执行完之后都会有询问是否重启电脑的提示（重启才能使修改生效），电脑重启后打开Hyper-V、虚拟机平台和适用于Linux的Windows子系统（WSL）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br><span class="line"># 将 WSL 默认版本设置为 WSL 2</span><br><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>
<p>运行这两条代码，更新WSL并将其设置成2</p>
<p>第一条代码跑起来可能非常慢，还有很大可能下载失败，可以去网上搜，下载<strong>wsl_update_x64.msi</strong>，下载电脑哪里都行，点击运行它，就可以把你的wsl更新到最新版</p>
<p>再安装Ubuntu</p>
<p>下面两条命令都行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-WebRequest -Uri https://aka.ms/wslubuntu2004 -OutFile Ubuntu.appx -UseBasicParsing</span><br><span class="line"></span><br><span class="line">curl.exe -L -o ubuntu-2004.appx https://aka.ms/wslubuntu2004</span><br></pre></td></tr></table></figure>
<p>安装之后，电梯Ubnutu图标，注册账号（不要跳），设置密码（不会显示），接着就进入了</p>
<p>wsl常用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl -l -v 			#查看电脑中系统和状态</span><br><span class="line">wsl --shutdown 		#关闭系统</span><br><span class="line">wsl.exe --update 	#</span><br><span class="line">exit 				#退出</span><br><span class="line"></span><br><span class="line">wsl -t -d Ubuntu 		#或 wsl --shutdown</span><br><span class="line">wsl --unregister Ubuntu #删除系统，Ubuntu是系统名</span><br><span class="line">wsl --set-default Ubuntu1 # 或wsl -s Ubuntu1设置默认系统</span><br><span class="line"></span><br><span class="line">#将系统从C盘移到D盘</span><br><span class="line">wsl --export Ubuntu D:\WSL1\ubuntu.tar</span><br><span class="line">wsl --import &lt;导入Linux名称&gt; &lt;导入盘的路径&gt; &lt;导入tar包路径&gt; 版本(代表wsl2)</span><br><span class="line">#例wsl --import Ubuntu1 D:\WSL1 D:\WSL1\ubuntu.tar --version 2</span><br><span class="line"></span><br><span class="line">wsl -u username 					#使用特定账户进入ubuntu</span><br><span class="line">wsl --set-default-user username 	#设置ubuntu特定账户</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>wsl修改ubuntu默认账户：</p>
<ol>
<li><p>打开终端并创建新账户：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -u root</span><br><span class="line">sudo adduser username			<span class="comment">#添加新用户</span></span><br><span class="line">sudo usermod -aG sudo username	<span class="comment">#赋sudo权限</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑<code>/etc/wsl.conf</code>文件：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/wsl.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加以下内容：</p>
<p>ini复制</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[user]</span></span><br><span class="line"><span class="attr">default</span>=username</span><br></pre></td></tr></table></figure>
<p>将<code>username</code>替换为你的目标用户名。</p>
</li>
</ol>
<p>​    4.重启wsl</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line">wsl</span><br></pre></td></tr></table></figure>
<h3><span id="linux常用指令">Linux常用指令</span></h3><h3><span id="1-文件和目录操作"><strong>1. 文件和目录操作</strong></span></h3><ul>
<li><p><strong>创建文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> filename.c</span><br></pre></td></tr></table></figure>
<p>创建一个名为 <code>filename.c</code> 的新文件。</p>
</li>
<li><p><strong>创建目录</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> directory_name</span><br></pre></td></tr></table></figure>
<p>创建一个名为 <code>directory_name</code> 的新目录。</p>
</li>
<li><p><strong>查看文件列表</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure>
<p>列出当前目录下的所有文件和目录，包括详细信息。</p>
</li>
<li><p><strong>删除文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> filename.c</span><br></pre></td></tr></table></figure>
<p>删除名为 <code>filename.c</code> 的文件。</p>
</li>
<li><p><strong>删除目录</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -r directory_name</span><br></pre></td></tr></table></figure>
<p>删除名为 <code>directory_name</code> 的目录及其所有内容。</p>
</li>
<li><p><strong>复制文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> filename.c destination.c</span><br></pre></td></tr></table></figure>
<p>将 <code>filename.c</code> 复制为 <code>destination.c</code>。</p>
</li>
<li><p><strong>移动文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> filename.c directory_name/</span><br></pre></td></tr></table></figure>
<p>将 <code>filename.c</code> 移动到 <code>directory_name</code> 目录中。</p>
</li>
</ul>
<h3><span id="2-文本编辑和查看"><strong>2. 文本编辑和查看</strong></span></h3><ul>
<li><p><strong>查看文件内容</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> filename.c</span><br></pre></td></tr></table></figure>
<p>显示 <code>filename.c</code> 的内容。</p>
</li>
<li><p><strong>分页查看文件内容</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">less filename.c</span><br></pre></td></tr></table></figure>
<p>分页查看 <code>filename.c</code> 的内容，按 <code>q</code> 退出。</p>
</li>
<li><p><strong>编辑文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano filename.c</span><br></pre></td></tr></table></figure>
<p>使用 <code>nano</code> 文本编辑器打开 <code>filename.c</code>。</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim filename.c</span><br></pre></td></tr></table></figure>
<p>使用 <code>vim</code> 文本编辑器打开 <code>filename.c</code>。</p>
</li>
</ul>
<h3><span id="3-文件搜索和过滤"><strong>3. 文件搜索和过滤</strong></span></h3><ul>
<li><p><strong>搜索文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /home/&lt;用户名&gt; -name <span class="string">&quot;filename.c&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>/home/&lt;用户名&gt;</code> 目录下搜索名为 <code>filename.c</code> 的文件。</p>
</li>
<li><p><strong>搜索文本</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;search_text&quot;</span> filename.c</span><br></pre></td></tr></table></figure>
<p>在 <code>filename.c</code> 中搜索包含 <code>search_text</code> 的行。</p>
</li>
<li><p><strong>过滤输出</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l | grep <span class="string">&quot;filename.c&quot;</span></span><br></pre></td></tr></table></figure>
<p>列出包含 <code>filename.c</code> 的行。</p>
</li>
</ul>
<h3><span id="4-程序编译和运行"><strong>4. 程序编译和运行</strong></span></h3><ul>
<li><p><strong>编译 C 语言程序</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc filename.c -o filename</span><br></pre></td></tr></table></figure>
<p>编译 <code>filename.c</code>，生成可执行文件 <code>filename</code>。</p>
</li>
<li><p><strong>运行程序</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filename</span><br></pre></td></tr></table></figure>
<p>运行生成的可执行文件 <code>filename</code>。</p>
</li>
<li><p><strong>清理编译文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> filename</span><br></pre></td></tr></table></figure>
<p>删除生成的可执行文件 <code>filename</code>。</p>
</li>
</ul>
<h3><span id="5-系统信息和网络"><strong>5. 系统信息和网络</strong></span></h3><ul>
<li><p><strong>查看系统信息</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>
<p>查看系统详细信息。</p>
</li>
<li><p><strong>查看磁盘使用情况</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>
<p>查看磁盘使用情况。</p>
</li>
<li><p><strong>查看当前目录</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure>
<p>显示当前工作目录。</p>
</li>
<li><p><strong>查看网络连接</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure>
<p>查看网络接口状态。</p>
</li>
<li><p><strong>ping 命令</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure>
<p>测试与 <code>google.com</code> 的网络连接。</p>
</li>
</ul>
<h3><span id="6-权限管理"><strong>6. 权限管理</strong></span></h3><ul>
<li><p><strong>查看文件权限</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l filename.c</span><br></pre></td></tr></table></figure>
<p>查看 <code>filename.c</code> 的权限。</p>
</li>
<li><p><strong>修改文件权限</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 filename.c</span><br></pre></td></tr></table></figure>
<p>将 <code>filename.c</code> 的权限修改为 <code>755</code>。</p>
</li>
<li><p><strong>修改文件所有者</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> &lt;用户名&gt; filename.c</span><br></pre></td></tr></table></figure>
<p>将 <code>filename.c</code> 的所有者修改为 <code>&lt;用户名&gt;</code>。</p>
</li>
</ul>
<h3><span id="7-压缩和解压缩"><strong>7. 压缩和解压缩</strong></span></h3><ul>
<li><p><strong>压缩文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cvf filename.tar filename.c</span><br></pre></td></tr></table></figure>
<p>将 <code>filename.c</code> 压缩为 <code>filename.tar</code>。</p>
</li>
<li><p><strong>解压缩文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf filename.tar</span><br></pre></td></tr></table></figure>
<p>解压缩 <code>filename.tar</code>。</p>
</li>
<li><p><strong>压缩为 gzip 格式</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf filename.tar.gz filename.c</span><br></pre></td></tr></table></figure>
<p>将 <code>filename.c</code> 压缩为 <code>filename.tar.gz</code>。</p>
</li>
<li><p><strong>解压缩 gzip 文件</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf filename.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压缩 <code>filename.tar.gz</code>。</p>
</li>
</ul>
<h3><span id="8-其他常用命令"><strong>8. 其他常用命令</strong></span></h3><ul>
<li><p><strong>清屏</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure>
<p>清除终端屏幕。</p>
</li>
<li><p><strong>查看历史命令</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure>
<p>查看历史命令。</p>
</li>
<li><p><strong>退出终端</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>退出当前终端会话。</p>
</li>
<li><p><strong>后台运行程序</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./filename &amp;</span><br></pre></td></tr></table></figure>
<p>在后台运行 <code>filename</code>。</p>
</li>
<li><p><strong>查看进程</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<p>查看当前运行的进程。</p>
</li>
<li><p><strong>杀死进程</strong>：</p>
<p>bash复制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;PID&gt;</span><br></pre></td></tr></table></figure>
<p>杀死指定 PID 的进程。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql1</title>
    <url>/2025/02/03/mysql1/</url>
    <content><![CDATA[<p>命名：小写字母下划线或者驼峰命名法</p>
<p>表与对应程序名一致</p>
<p>表命名 业务名加表</p>
<p>列命名 表实体加属性</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统笔记-1</title>
    <url>/2025/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算机系统笔记-2</title>
    <url>/2025/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>离散数学-集合</title>
    <url>/2025/02/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java笔记1</title>
    <url>/2025/09/03/Java%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<h4><span id="程序格式">程序格式</span></h4><p>class 关键字，标识类</p>
<p>main方法： public static void main，程序入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,world,a new travel begin now!&quot;</span>);	<span class="comment">//打印完后会换行</span></span><br><span class="line">        System.out.print(<span class="string">&quot;hello,world,a new travel begin now!&quot;</span>);	<span class="comment">//打印完后不会换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="关键字">关键字</span></h4><p><img src="../imgs/Java%E7%AC%94%E8%AE%B01/image-20250903191718305-17569048116792-17569048172624.png" alt="image-20250903191718305"></p>
<p>Java中变量、方法、类等要素命名时使用的字符序列，称为标识符。</p>
<p>变量起名规则和C++一样</p>
<h4><span id="变量">变量</span></h4><p><strong>基本数据类型：</strong></p>
<p>整型：byte \ short \ int \ long</p>
<p>浮点型：float \ double</p>
<p>字符型：char</p>
<p>布尔型：boolean</p>
<p><strong>引用数据类型：</strong></p>
<p>类 class</p>
<p>数组 array</p>
<p>接口 interface</p>
<p>枚举 enum</p>
<p>注解 annotation</p>
<p>记录 record</p>
<p><strong>注意事项：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">variable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">0.1</span>+<span class="number">0.2</span>); 	<span class="comment">//0.30000000000000004,二进制产生误差</span></span><br><span class="line">        System.out.println(<span class="number">0.3</span>+<span class="number">0.1</span>);	<span class="comment">//0.4</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ff1</span> <span class="operator">=</span> <span class="number">123123123f</span>;			<span class="comment">//超过了int型上限需要加后缀，否则不需要</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ff2</span> <span class="operator">=</span> ff1+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> age=<span class="number">20</span>;</span><br><span class="line">        <span class="type">double</span> weight=<span class="number">83</span>;</span><br><span class="line">        <span class="type">char</span> gender=<span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">marry</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        String name= <span class="string">&quot;zjy&quot;</span>;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">12341256789L</span>;</span><br><span class="line">        System.out.println(ff1);				<span class="comment">//1.2312312E8</span></span><br><span class="line">        System.out.println(ff2);				<span class="comment">//1.2312312E8</span></span><br><span class="line">        System.out.println(ff1 == ff2);			<span class="comment">//true ，精度问题最后的3没保留</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>强制类型转换</strong></p>
<p><strong>转换格式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型<span class="number">1</span> 变量名 = (数据类型<span class="number">1</span>)被强转数据值;  <span class="comment">//()中的数据类型必须&lt;=变量值的数据类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">3.14</span>;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)d;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;<span class="comment">//溢出</span></span><br></pre></td></tr></table></figure>
<p>有可能损失精度</p>
<p><strong>字符串String</strong></p>
<ul>
<li>字符串运算用+来表示字符拼接</li>
<li>字符串不能用强制类型转换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span> + <span class="number">1</span> + <span class="number">2</span>);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1 + num + b1;</span><br><span class="line">System.out.println(s2);<span class="comment">//abc10true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)str;<span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h3><span id>#</span></h3>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记3</title>
    <url>/2025/09/17/Java%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>[toc]</p>
<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<h4><span id="数组">数组</span></h4><h5><span id="声明数组格式">声明数组格式：</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[] 一维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  一维数组名[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//例</span></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line"><span class="type">int</span> arr[];</span><br><span class="line"><span class="comment">//[]表示一维数组，[][]则表示二维数组</span></span><br></pre></td></tr></table></figure>
<h5><span id="一维数组的初始化">一维数组的初始化：</span></h5><p>静态初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,...&#125;;</span><br><span class="line"></span><br><span class="line">数据类型[] 数组名;</span><br><span class="line">数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,...&#125;;</span><br><span class="line"></span><br><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">但是</span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">是不正确的</span><br></pre></td></tr></table></figure>
<p>动态初始化（先确定长度，之后一个个赋值）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组存储的元素的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的元素的数据类型[长度];</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数组存储的数据类型[] 数组名字;</span><br><span class="line">数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h5><span id="数组默认值">数组默认值：</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest6</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String argv[])</span>&#123;</span><br><span class="line">		<span class="type">int</span> a[]= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; </span><br><span class="line">		System.out.println(a[<span class="number">3</span>]); <span class="comment">//a[3]输出为0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>数组初始化时有默认值，如下表：</p>
<p><img src="../imgs/Java%E7%AC%94%E8%AE%B03/image-20250918122037099.png" alt="image-20250918122037099"></p>
<h5><span id="多维数组">多维数组：</span></h5><p>声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称;</span><br><span class="line"><span class="type">int</span>[][] arr;</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态</span></span><br><span class="line"><span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;&#125;;<span class="comment">//每一行列数可以不同</span></span><br><span class="line"><span class="comment">//动态</span></span><br><span class="line"><span class="type">int</span>[][] data = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>];<span class="comment">//然后挨个赋值</span></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];<span class="comment">//int[][] arr = new int[][3];是非法的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;二维数组名.length; i++)&#123; <span class="comment">//二维数组对象.length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;二维数组名[i].length; j++)&#123;<span class="comment">//二维数组行对象.length</span></span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+springboot学习1：Maven</title>
    <url>/2025/09/17/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<!-- toc -->
<!-- tocstop -->
<span id="more"></span>
<h4><span id="maven配置">maven配置：</span></h4><p>1、下载：<a href="https://maven.apache.org/download.cgi这是下载地址，**下载以bin.zip**结束的压缩包，下载一般比较慢">https://maven.apache.org/download.cgi这是下载地址，**下载以bin.zip**结束的压缩包，下载一般比较慢</a></p>
<p>2、下载完解压到本地，我选择了3.8.9，解压到了<code>D:\programme\Maven\apache-maven-3.8.9</code></p>
<p>3、下一步添加环境变量：在系统变量里添加：<img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918013801328-175813395646913.png" alt="image-20250918013801328"></p>
<p>然后在path里加入<code>%MAVEN_HOOME%\b</code>，一路确定保存配置</p>
<p>这之后可以在CMD中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -version</span><br></pre></td></tr></table></figure>
<p>结果如图<img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918014951860-175813396332715.png" alt="image-20250918014951860"></p>
<p>这样就配置成功了。</p>
<p>4、配置本地仓库，我的仓库位置是<code>D:\programme\Maven\repository</code>，接下来找到D:\programme\Maven\apache-maven-3.8.9\conf里的settings.xml，</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918014453414-175813396652717.png" alt="image-20250918014453414"></p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918014529230-175813396801919.png" alt="image-20250918014529230"></p>
<p>进行如图所示的两处修改，第一处是改仓库，默认C盘占用C盘内存，第二处是修改远程仓库，maven在获取需要的jar包时会首先从本地仓库获取，当本地仓库不存在需要的jar包时会从setting.<a href="https://so.csdn.net/so/search?q=xml&amp;spm=1001.2101.3001.7020">xml</a>的远程仓库获取到本地仓库，我们一般会修改远程仓库地址为阿里云的远程仓库，比较快。</p>
<p>5、创建本地项目来测试功能</p>
<p>首先新建一个项目<img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918015347245-175813396969821.png" alt="image-20250918015347245"></p>
<p>按上面的步骤来，服务器URL就是<code>http://start.spring.io</code>，项目名称和位置不多说，重点是类型一定要选择<strong>Maven</strong>，（默认的Gradle - Groovy需要直接从services.gradle.org上下载，非常慢，该国内镜像，改了国内镜像还是构建不成功，花了很多时间到最后也没解决）</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918020236068-175813397253623.png" alt="image-20250918020236068"></p>
<p>接下来选择<code>Web-&gt;Spring Web-&gt;创建</code> 即可</p>
<p><strong>注意：</strong>这里可能会报<code>错误: Cannot download ‘https://start.spring.io/starter.zip</code>的错误，解决方法是：</p>
<p>1.将上方的URL替换为：<code>https://start.spring.io/</code><br>2.将上方的URL替换为：<code>http://start.spring.io</code></p>
<p>这样就没问题了。</p>
<p>6、修改IDEA里的本地仓库设置：</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918020741031-175813397837625-175813399199027-175813399419529.png" alt="image-20250918020741031"></p>
<p>在建完项目后点击设置，弹出的窗口中修改如下内容：</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918020855236-175813400576831.png" alt="image-20250918020855236"></p>
<p>Maven主路径切换为自己的安装路径，设置文件重写为自己修改过的settings.xml，一般会自动修改本地仓库，不需要手动重写</p>
<p>7、修改完之后，点击下面这里的重新运行即可</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918021319360-175813401018333.png" alt="image-20250918021319360">重新运行之后可能会报<code>未解析的插件: &#39;org.springframework.boot:spring-boot-maven-plugin:3.5.5&#39;</code>的错误，这是因为IDEA自动帮你创建的时候不智能，漏写了版本，解决方法很简单，首先确定版本号：</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918021555288.png" alt="image-20250918021555288"></p>
<p>按我图中的路径可以找到版本，这里我是<code>3.5.5</code>，所以在项目的pom.xml中的相应位置（如图）插入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918021508978-175813401273135.png" alt="image-20250918021508978"></p>
<p>然后返回到上面，把父版本也改成3.5.5。</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918021937146-175813401517137-175813402130539.png" alt="image-20250918021937146"></p>
<p>8、最后我们就可以用Maven查看项目结构了：</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/image-20250918023353355-175813403634241.png" alt="image-20250918023353355"></p>
<p>参考：<br><a href="https://blog.csdn.net/weixin_54259646/article/details/145871705?ops_request_misc=elastic_search_misc&amp;request_id=9e4b6f4d7ee7ff3fd6a19bcf9588a9e2&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-145871705-null-null.142^v102^pc_search_result_base3&amp;utm_term=Maven%E4%B8%8B%E8%BD%BD%E9%85%8D%E7%BD%AEidea&amp;spm=1018.2226.3001.4187">IDEA从下载到配置本地仓库MAVEN</a></p>
<p><a href="https://blog.csdn.net/alongbigbig/article/details/117467544?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E9%94%99%E8%AF%AF:%20Cannot%20download%20%27https://s&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-117467544.142^v102^pc_search_result_base3&amp;spm=1018.2226.3001.4187">错误: Cannot download ‘https://start.spring.io/starter.zip</a></p>
<p><a href="https://blog.csdn.net/m0_62407354/article/details/132832762?ops_request_misc=elastic_search_misc&amp;request_id=f2a4fd32faf1ad66df38c1fe0bb141ac&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-132832762-null-null.142^v102^pc_search_result_base3&amp;utm_term=%E6%9C%AA%E8%A7%A3%E6%9E%90%E7%9A%84%E6%8F%92%E4%BB%B6%3A%20org.springframework.boot%3Aspring-boot-maven-plugin%3A3.5.5&amp;spm=1018.2226.3001.4187">完美解决未解析插件：spring-boot-maven-plugin</a></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Java笔记2</title>
    <url>/2025/09/17/Java%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>[toc]</p>
<!-- toc -->
<!-- tocstop -->
<span id="more"></span> 
<h4><span id="流程控制语句">流程控制语句</span></h4><p>程序设计的三种流程结构：</p>
<ul>
<li>顺序结构：自上而下执行，没有跳转和判断</li>
<li>分支结构：根据条件，选择性执行代码<ul>
<li>if······else</li>
<li>switch······case</li>
</ul>
</li>
<li>循环结构：根据循环条件，重复性执行某段代码<ul>
<li>for</li>
<li>while</li>
<li>do{  ···  }while</li>
</ul>
</li>
</ul>
<h4><span id="顺序结构不做赘述">顺序结构不做赘述。</span></h4><h4><span id="分支结构">分支结构：</span></h4><h5><span id="单分支判断">单分支判断：</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">	语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="双分支判断">双分支判断：</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">	语句块；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="多分支判断">多分支判断：</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)&#123;</span><br><span class="line">	语句块；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    语句块；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    语句块；</span><br><span class="line">&#125;......&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    语句块；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="if-else嵌套">if … else嵌套：</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(条件<span class="number">2</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch…case选择结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//break;</span></span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//break; </span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   [<span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习1：</strong>小明参加期末Java考试，通过考试成绩，判断其Java等级，成绩范围[0,100]</p>
<ul>
<li>90-100      优秀</li>
<li>80-89        好</li>
<li>70-79        良</li>
<li>60-69        及格</li>
<li>60以下    不及格</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line">        <span class="keyword">if</span> (score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">90</span> &amp;&amp; score &lt;= <span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span> &amp;&amp; score &lt; <span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;好&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span> &amp;&amp; score &lt; <span class="number">80</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;良&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">70</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line">		<span class="keyword">switch</span>(score/<span class="number">10</span>)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;良&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;好&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			<span class="keyword">case</span> <span class="number">10</span>:<span class="comment">//这里100-109的score都会出现优的结果，有缺陷</span></span><br><span class="line">                System.out.println(<span class="string">&quot;优&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>练习二：键盘输入年月日，判断这一天是当年的第几天：</p>
<p>注：判断闰年：可被4整除但不可被100整除或者可被400整除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;input year:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;input month:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;input day:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sumDays</span> <span class="operator">=</span> day;</span><br><span class="line">        <span class="keyword">switch</span>(month)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                sumDays+=<span class="number">31</span>;  <span class="comment">//11月份的天数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                sumDays+=<span class="number">30</span>;  <span class="comment">//10月份的天数</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                sumDays+=<span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                sumDays+=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                sumDays+=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sumDays+=<span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sumDays+=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                sumDays+=<span class="number">30</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                sumDays+=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                sumDays+=<span class="number">28</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                sumDays+=<span class="number">31</span>;</span><br><span class="line">                <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span> || year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    sumDays++;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日是这一年的第&quot;</span> + sumDays + <span class="string">&quot;天&quot;</span>);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="循环结构">循环结构</span></h4><h5><span id="for循环">for循环：</span></h5><p><strong>语法格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (①初始化部分; ②循环条件部分; ④迭代部分)｛</span><br><span class="line">         	③循环体部分;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>例1：实现1到100的累加求和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sum1to100</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2：输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身。例如： <code>153 = 1*1*1 + 3*3*3 + 5*5*5</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;水仙花数：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">999</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d1</span> <span class="operator">=</span> i%<span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> i/<span class="number">10</span>%<span class="number">10</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d3</span> <span class="operator">=</span> i/<span class="number">100</span>;</span><br><span class="line">            <span class="comment">//个、十、百位</span></span><br><span class="line">            <span class="keyword">if</span>(d1*d1*d1+d2*d2*d2+d3*d3*d3 == i)&#123;</span><br><span class="line">                System.out,println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for循环可以结合break使用，如下面的代码（求最大公约数）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">9992</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=num-<span class="number">1</span>;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num%i==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，break只能跳出两层结构，if一层，for一层，如下面的代码，i就可以从1完整遍历到100，continue只能结束当次循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i*j&gt;<span class="number">100</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="while循环">while循环：</span></h5><p><strong>语法格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①初始化部分</span><br><span class="line"><span class="keyword">while</span>(②循环条件部分)｛</span><br><span class="line">    ③循环体部分;</span><br><span class="line">    ④迭代部分;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：②是boolean类型</p>
<p>for和while可以互相转换，二者没有性能上的差异</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//需求1：控制台输出5行Hello World!</span></span><br><span class="line">		<span class="comment">//写法1：</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//写法2：</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//写法3：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="do-while循环">do-while循环</span></h5><p><strong>语法格式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">①初始化部分;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	③循环体部分</span><br><span class="line">	④迭代部分</span><br><span class="line">&#125;<span class="keyword">while</span>(②循环条件部分); </span><br></pre></td></tr></table></figure>
<p>注意：这个循环是先do再while判断，所以它至少会跑一次，这是它与while的区别</p>
<h5><span id="无限循环">无限循环：</span></h5><p>while(true),for(;;)</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+springboot学习笔记1</title>
    <url>/2025/09/18/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>vue+springboot学习笔记2</title>
    <url>/2025/09/19/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<!--toc-->
<span id="more"></span>
<h4><span id="学习笔记">学习笔记</span></h4><p>@Controller                请求页面和数据</p>
<p>@RestController        请求数据</p>
<p>两个注解</p>
<p>HTTP状态码：</p>
<p>1xx：信息，通信传输协议及信息</p>
<p>2xx：成功，表示客户端的请求已成功接受</p>
<p>3xx：重定向，表示客户端必须执行一些其他操作才能完成其请求</p>
<p>4xx：客户端错误，此类错误状态码指向客户端</p>
<p>5xx：服务器错误，服务器负责写这类错误状态码</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20250920161205011.png" alt="image-20250920161205011"></p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20250920161255388.png" alt="image-20250920161255388"></p>
<h4><span id="springdoc-openapi">Springdoc-OpenAPI</span></h4><p><code>OpenApi</code> 规范提供了很多注解，下面是一些常用的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">注解</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@Tag</td>
<td style="text-align:left">用在controller类上，描述此controller的信息</td>
</tr>
<tr>
<td style="text-align:left">@Operation</td>
<td style="text-align:left">用在controller的方法里，描述此api的信息</td>
</tr>
<tr>
<td style="text-align:left">@Parameter</td>
<td style="text-align:left">用在controller方法里的参数上，描述参数信息</td>
</tr>
<tr>
<td style="text-align:left">@Parameters</td>
<td style="text-align:left">用在controller方法里的参数上</td>
</tr>
<tr>
<td style="text-align:left">@Schema</td>
<td style="text-align:left">用于Entity，以及Entity的属性上</td>
</tr>
<tr>
<td style="text-align:left">@ApiResponse</td>
<td style="text-align:left">用在controller方法的返回值上</td>
</tr>
<tr>
<td style="text-align:left">@ApiResponses</td>
<td style="text-align:left">用在controller方法的返回值上</td>
</tr>
<tr>
<td style="text-align:left">@Hidden</td>
<td style="text-align:left">用在各种地方，用于隐藏其api</td>
</tr>
</tbody>
</table>
</div>
<h4><span id="端口占用问题">端口占用问题：</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.helloworld.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloController</span> &#123;</span><br><span class="line">    <span class="comment">//http://localhost:8080/hello</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初学者跑上面的测试时，网页跑不通，IDEA显示8080端口被占用：</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20250919024321705.png" alt="image-20250919024321705"></p>
<p>搜了下网上的解决方案:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | findstr 8080</span><br><span class="line"></span><br><span class="line">taskkill -PID &lt;pid&gt; -F</span><br></pre></td></tr></table></figure>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20250919024514765.png" alt="image-20250919024514765"></p>
<p>但是解决不了，进而查看任务管理器，这东西好像关不掉，有点难办。</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/image-20250919024657022.png" alt="image-20250919024657022"></p>
<p>最后是修改了配置文件，在项目的application.properties文件里添加了一行<code>server.port=8081</code>，改了端口解决了。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+springboot学习笔记3</title>
    <url>/2025/09/20/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h4><span id="idea配置swagger">IDEA配置swagger</span></h4><span id="more"></span>
<p>最近vue+springboot的学习遇到了一些问题，主要原因是教程太老，视频教程里使用的swagger版本与我的springboot不对应，只能令搜教程，但是网上此类的教程很少，所以花费了颇多的时间才配好swagger，这里分享下过程。</p>
<p>我使用的是SpringBoot 3.5.5 + Java21 + Maven 3.8.9</p>
<p>由于Springfox Swagger2/3已停止更新，我使用了Springdoc-OpenAPI代替。</p>
<p>首先新建一个Spring Initializr项目（我的项目名是helloworld），然后先编写个 Java类文件测试功能，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.helloworld.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloController</span> &#123;</span><br><span class="line">    <span class="comment">//http://localhost:8080/hello</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;你好 世界&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目运行后再浏览器输入<code>http://localhost:8080/hello</code>，显示“你好世界”则表示功能正常，可以进行下一步。</p>
<p>接下来在项目的org.example.helloworld里新建一个config文件夹，在这个文件夹里建一个Java类文件，我的Java类文件名是SwaggerConfig，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.helloworld.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;</span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">myOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(<span class="keyword">new</span> <span class="title class_">Info</span>()</span><br><span class="line">                        .title(<span class="string">&quot;测试网站API&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;测试用&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;v1.0.0&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后加依赖，打开pom.xml文件，在依赖中加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  &lt;dependencies&gt;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springdoc&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">2.5</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>这时偏右上角的位置会出现一个 m 字符，点击即可下载相应的依赖。</p>
<p><img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20250920190914752.png" alt="image-20250920190914752"></p>
<p>这样就成功了，运行之后，浏览器输入 <a href="http://localhost:8080">http://localhost:8080</a> 就会看到类似这样的画面：<img src="../imgs/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/image-20250920191623451.png" alt="image-20250920191623451"></p>
<p>这样swagger配置就完成了。</p>
<h4><span id="参考">参考：</span></h4><p><a href="https://blog.csdn.net/shusheng0007/article/details/131304104?ops_request_misc=elastic_search_misc&amp;request_id=082ef190ffef2f4942db7cca6ee8bda3&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-131304104-null-null.142^v102^pc_search_result_base3&amp;utm_term=%E7%A7%92%E6%87%82SpringBoot%E4%B9%8B%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90SpringDoc%EF%BC%88%E5%85%A8%E7%BD%91%E7%9B%AE%E5%89%8D%E6%9C%80%E6%96%B0%E6%9C%80%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84springdoc%E6%95%99%E7%A8%8B%EF%BC%89&amp;spm=1018.2226.3001.4187">秒懂SpringBoot之如何集成SpringDoc（全网目前最新最系统最全面的springdoc教程）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/1948752365122453540">SpringBoot项目集成Swagger指南</a></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+springboot学习笔记4</title>
    <url>/2025/09/20/vue-springboot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
